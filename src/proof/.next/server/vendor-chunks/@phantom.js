/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@phantom";
exports.ids = ["vendor-chunks/@phantom"];
exports.modules = {

/***/ "(ssr)/./node_modules/@phantom/base64url/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@phantom/base64url/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlDecodeToString: () => (/* binding */ base64urlDecodeToString),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   stringToBase64url: () => (/* binding */ stringToBase64url)\n/* harmony export */ });\n// src/index.ts\nvar isBrowser = typeof window !== \"undefined\" && typeof window.btoa !== \"undefined\";\nfunction base64urlEncode(data) {\n  let base64;\n  if (isBrowser) {\n    if (typeof data === \"string\") {\n      base64 = btoa(data);\n    } else {\n      base64 = btoa(String.fromCharCode(...Array.from(data)));\n    }\n  } else {\n    if (typeof data === \"string\") {\n      base64 = Buffer.from(data, \"utf8\").toString(\"base64\");\n    } else {\n      base64 = Buffer.from(data).toString(\"base64\");\n    }\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction base64urlDecode(str) {\n  const base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(str.length + (4 - str.length % 4) % 4, \"=\");\n  if (isBrowser) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  } else {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  }\n}\nfunction base64urlDecodeToString(str) {\n  const bytes = base64urlDecode(str);\n  if (isBrowser && typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(bytes);\n  } else if (!isBrowser) {\n    return Buffer.from(bytes).toString(\"utf8\");\n  } else {\n    return String.fromCharCode(...bytes);\n  }\n}\nfunction stringToBase64url(str) {\n  if (isBrowser && typeof TextEncoder !== \"undefined\") {\n    const bytes = new TextEncoder().encode(str);\n    return base64urlEncode(bytes);\n  } else if (!isBrowser) {\n    return base64urlEncode(str);\n  } else {\n    return base64urlEncode(str);\n  }\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYmFzZTY0dXJsL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9iYXNlNjR1cmwvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmJ0b2EgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBiYXNlNjR1cmxFbmNvZGUoZGF0YSkge1xuICBsZXQgYmFzZTY0O1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBiYXNlNjQgPSBidG9hKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlNjQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uQXJyYXkuZnJvbShkYXRhKSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZTY0ID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gYmFzZTY0dXJsRGVjb2RlKHN0cikge1xuICBjb25zdCBiYXNlNjQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIikucGFkRW5kKHN0ci5sZW5ndGggKyAoNCAtIHN0ci5sZW5ndGggJSA0KSAlIDQsIFwiPVwiKTtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNlNjR1cmxEZWNvZGVUb1N0cmluZyhzdHIpIHtcbiAgY29uc3QgYnl0ZXMgPSBiYXNlNjR1cmxEZWNvZGUoc3RyKTtcbiAgaWYgKGlzQnJvd3NlciAmJiB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZyhcInV0ZjhcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYnl0ZXMpO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NHVybChzdHIpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiB0eXBlb2YgVGV4dEVuY29kZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGUoYnl0ZXMpO1xuICB9IGVsc2UgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NHVybEVuY29kZShzdHIpO1xuICB9XG59XG5leHBvcnQge1xuICBiYXNlNjR1cmxEZWNvZGUsXG4gIGJhc2U2NHVybERlY29kZVRvU3RyaW5nLFxuICBiYXNlNjR1cmxFbmNvZGUsXG4gIHN0cmluZ1RvQmFzZTY0dXJsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/base64url/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/auto-confirm/index.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/auto-confirm/index.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAutoConfirmPlugin: () => (/* binding */ createAutoConfirmPlugin)\n/* harmony export */ });\n/* harmony import */ var _chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-GV6AIHPN.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n\n\n// src/auto-confirm/getProvider.ts\nfunction getProvider() {\n  if (typeof window === \"undefined\") {\n    return null;\n  }\n  const provider = window?.phantom?.app;\n  if (!provider) {\n    return null;\n  }\n  return provider;\n}\n\n// src/auto-confirm/autoConfirmEnable.ts\n\nasync function autoConfirmEnable(params) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  const transformedParams = params?.chains ? { chains: params.chains.map(_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.networkIdToInternalCaip) } : {};\n  const result = await provider.request({\n    method: \"phantom_auto_confirm_enable\",\n    params: transformedParams\n  });\n  return {\n    ...result,\n    chains: result.chains.map(_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.internalCaipToNetworkId)\n  };\n}\n\n// src/auto-confirm/autoConfirmDisable.ts\n\nasync function autoConfirmDisable() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  const result = await provider.request({\n    method: \"phantom_auto_confirm_disable\",\n    params: {}\n  });\n  return {\n    ...result,\n    chains: result.chains.map(_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.internalCaipToNetworkId)\n  };\n}\n\n// src/auto-confirm/autoConfirmStatus.ts\n\nasync function autoConfirmStatus() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  const result = await provider.request({\n    method: \"phantom_auto_confirm_status\",\n    params: {}\n  });\n  return {\n    ...result,\n    chains: result.chains.map(_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.internalCaipToNetworkId)\n  };\n}\n\n// src/auto-confirm/autoConfirmSupportedChains.ts\n\nasync function autoConfirmSupportedChains() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  const result = await provider.request({\n    method: \"phantom_auto_confirm_supported_chains\",\n    params: {}\n  });\n  return {\n    chains: result.chains.map(_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.internalCaipToNetworkId)\n  };\n}\n\n// src/auto-confirm/plugin.ts\nvar autoConfirm = {\n  autoConfirmEnable,\n  autoConfirmDisable,\n  autoConfirmStatus,\n  autoConfirmSupportedChains\n};\nfunction createAutoConfirmPlugin() {\n  return {\n    name: \"autoConfirm\",\n    create: () => autoConfirm\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9hdXRvLWNvbmZpcm0vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQix1RUFBdUIsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4Qix1RUFBdUI7QUFDckQ7QUFDQTs7QUFFQTtBQUN5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsdUVBQXdCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLHVFQUF3QjtBQUN0RDtBQUNBOztBQUVBO0FBQ3lGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsdUVBQXdCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9hdXRvLWNvbmZpcm0vaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4uL2NodW5rLUdWNkFJSFBOLm1qc1wiO1xuXG4vLyBzcmMvYXV0by1jb25maXJtL2dldFByb3ZpZGVyLnRzXG5mdW5jdGlvbiBnZXRQcm92aWRlcigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwcm92aWRlciA9IHdpbmRvdz8ucGhhbnRvbT8uYXBwO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuXG4vLyBzcmMvYXV0by1jb25maXJtL2F1dG9Db25maXJtRW5hYmxlLnRzXG5pbXBvcnQgeyBuZXR3b3JrSWRUb0ludGVybmFsQ2FpcCwgaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQgfSBmcm9tIFwiQHBoYW50b20vY29uc3RhbnRzXCI7XG5hc3luYyBmdW5jdGlvbiBhdXRvQ29uZmlybUVuYWJsZShwYXJhbXMpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IHBhcmFtcz8uY2hhaW5zID8geyBjaGFpbnM6IHBhcmFtcy5jaGFpbnMubWFwKG5ldHdvcmtJZFRvSW50ZXJuYWxDYWlwKSB9IDoge307XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogXCJwaGFudG9tX2F1dG9fY29uZmlybV9lbmFibGVcIixcbiAgICBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBjaGFpbnM6IHJlc3VsdC5jaGFpbnMubWFwKGludGVybmFsQ2FpcFRvTmV0d29ya0lkKVxuICB9O1xufVxuXG4vLyBzcmMvYXV0by1jb25maXJtL2F1dG9Db25maXJtRGlzYWJsZS50c1xuaW1wb3J0IHsgaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQgYXMgaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQyIH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xuYXN5bmMgZnVuY3Rpb24gYXV0b0NvbmZpcm1EaXNhYmxlKCkge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogXCJwaGFudG9tX2F1dG9fY29uZmlybV9kaXNhYmxlXCIsXG4gICAgcGFyYW1zOiB7fVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgY2hhaW5zOiByZXN1bHQuY2hhaW5zLm1hcChpbnRlcm5hbENhaXBUb05ldHdvcmtJZDIpXG4gIH07XG59XG5cbi8vIHNyYy9hdXRvLWNvbmZpcm0vYXV0b0NvbmZpcm1TdGF0dXMudHNcbmltcG9ydCB7IGludGVybmFsQ2FpcFRvTmV0d29ya0lkIGFzIGludGVybmFsQ2FpcFRvTmV0d29ya0lkMyB9IGZyb20gXCJAcGhhbnRvbS9jb25zdGFudHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGF1dG9Db25maXJtU3RhdHVzKCkge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgIG1ldGhvZDogXCJwaGFudG9tX2F1dG9fY29uZmlybV9zdGF0dXNcIixcbiAgICBwYXJhbXM6IHt9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBjaGFpbnM6IHJlc3VsdC5jaGFpbnMubWFwKGludGVybmFsQ2FpcFRvTmV0d29ya0lkMylcbiAgfTtcbn1cblxuLy8gc3JjL2F1dG8tY29uZmlybS9hdXRvQ29uZmlybVN1cHBvcnRlZENoYWlucy50c1xuaW1wb3J0IHsgaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQgYXMgaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQ0IH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xuYXN5bmMgZnVuY3Rpb24gYXV0b0NvbmZpcm1TdXBwb3J0ZWRDaGFpbnMoKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgbWV0aG9kOiBcInBoYW50b21fYXV0b19jb25maXJtX3N1cHBvcnRlZF9jaGFpbnNcIixcbiAgICBwYXJhbXM6IHt9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNoYWluczogcmVzdWx0LmNoYWlucy5tYXAoaW50ZXJuYWxDYWlwVG9OZXR3b3JrSWQ0KVxuICB9O1xufVxuXG4vLyBzcmMvYXV0by1jb25maXJtL3BsdWdpbi50c1xudmFyIGF1dG9Db25maXJtID0ge1xuICBhdXRvQ29uZmlybUVuYWJsZSxcbiAgYXV0b0NvbmZpcm1EaXNhYmxlLFxuICBhdXRvQ29uZmlybVN0YXR1cyxcbiAgYXV0b0NvbmZpcm1TdXBwb3J0ZWRDaGFpbnNcbn07XG5mdW5jdGlvbiBjcmVhdGVBdXRvQ29uZmlybVBsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImF1dG9Db25maXJtXCIsXG4gICAgY3JlYXRlOiAoKSA9PiBhdXRvQ29uZmlybVxuICB9O1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQXV0b0NvbmZpcm1QbHVnaW5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/auto-confirm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-CS23VDDD.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/chunk-CS23VDDD.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEthereumPlugin: () => (/* binding */ createEthereumPlugin),\n/* harmony export */   createSiweMessage: () => (/* binding */ createSiweMessage)\n/* harmony export */ });\n/* harmony import */ var _chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-GV6AIHPN.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\");\n\n\n// src/ethereum/siwe.ts\nvar ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nvar DOMAIN_REGEX = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;\nvar IP_REGEX = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;\nvar LOCALHOST_REGEX = /^localhost(:[0-9]{1,5})?$/;\nvar NONCE_REGEX = /^[a-zA-Z0-9]{8,}$/;\nvar SCHEME_REGEX = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;\nfunction createSiweMessage({\n  address,\n  chainId,\n  domain,\n  nonce,\n  uri,\n  version,\n  scheme,\n  statement: _statement,\n  requestId,\n  resources,\n  issuedAt = /* @__PURE__ */ new Date(),\n  expirationTime,\n  notBefore\n}) {\n  if (!ADDRESS_REGEX.test(address)) {\n    throw new Error(\"address must be a hex value of 20 bytes (40 hex characters).\");\n  }\n  if (chainId !== Math.floor(chainId)) {\n    throw new Error(\"chainId must be a EIP-155 chain ID.\");\n  }\n  if (!(DOMAIN_REGEX.test(domain) || IP_REGEX.test(domain) || LOCALHOST_REGEX.test(domain))) {\n    throw new Error(\"domain must be an RFC 3986 authority.\");\n  }\n  if (!NONCE_REGEX.test(nonce)) {\n    throw new Error(\"nonce must be at least 8 characters.\");\n  }\n  if (!_isUri(uri)) {\n    throw new Error(\"uri must be a RFC 3986 URI referring to the resource that is the subject of the signing.\");\n  }\n  if (version !== \"1\") {\n    throw new Error(\"version must be '1'.\");\n  }\n  if (scheme && !SCHEME_REGEX.test(scheme)) {\n    throw new Error(\"scheme must be an RFC 3986 URI scheme.\");\n  }\n  if (_statement?.includes(\"\\n\")) {\n    throw new Error(\"statement must not include '\\\\n'.\");\n  }\n  const origin = scheme ? `${scheme}://${domain}` : domain;\n  const statement = _statement ? `${_statement}\n` : \"\";\n  const prefix = `${origin} wants you to sign in with your Ethereum account:\n${address}\n\n${statement}`;\n  let suffix = `URI: ${uri}\nVersion: ${version}\nChain ID: ${chainId}\nNonce: ${nonce}\nIssued At: ${issuedAt.toISOString()}`;\n  if (expirationTime) {\n    suffix += `\nExpiration Time: ${expirationTime.toISOString()}`;\n  }\n  if (notBefore) {\n    suffix += `\nNot Before: ${notBefore.toISOString()}`;\n  }\n  if (requestId) {\n    suffix += `\nRequest ID: ${requestId}`;\n  }\n  if (resources) {\n    let content = \"\\nResources:\";\n    for (const resource of resources) {\n      if (!_isUri(resource)) {\n        throw new Error(\"resources must be RFC 3986 URIs.\");\n      }\n      content += `\n- ${resource}`;\n    }\n    suffix += content;\n  }\n  return `${prefix}\n${suffix}`;\n}\nfunction _isUri(value) {\n  if (/[^a-z0-9:/?#[\\]@!$&'()*+,;=.\\-_~%]/i.test(value))\n    return false;\n  if (/%[^0-9a-f]/i.test(value))\n    return false;\n  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))\n    return false;\n  const splitted = splitUri(value);\n  const scheme = splitted[1];\n  const authority = splitted[2];\n  const path = splitted[3];\n  const query = splitted[4];\n  const fragment = splitted[5];\n  if (!(scheme?.length && path.length >= 0))\n    return false;\n  if (authority?.length) {\n    if (!(path.length === 0 || /^\\//.test(path)))\n      return false;\n  } else {\n    if (/^\\/\\//.test(path))\n      return false;\n  }\n  if (!/^[a-z][a-z0-9+\\-.]*$/.test(scheme.toLowerCase()))\n    return false;\n  let out = \"\";\n  out += `${scheme}:`;\n  if (authority?.length)\n    out += `//${authority}`;\n  out += path;\n  if (query?.length)\n    out += `?${query}`;\n  if (fragment?.length)\n    out += `#${fragment}`;\n  return out;\n}\nfunction splitUri(value) {\n  return value.match(/(?:([^:/?#]+):)?(?:\\/\\/([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n}\n\n// src/ethereum/strategies/injected.ts\nvar MAX_RETRIES = 4;\nvar BASE_DELAY = 100;\nvar _getProvider, getProvider_fn;\nvar InjectedEthereumStrategy = class {\n  constructor() {\n    (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateAdd)(this, _getProvider);\n    this.type = \"injected\" /* INJECTED */;\n  }\n  load() {\n    let retryCount = 0;\n    const scheduleRetry = (resolve, reject) => {\n      const delay = BASE_DELAY * Math.pow(2, Math.min(retryCount, 5));\n      setTimeout(() => {\n        if ((0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this)) {\n          resolve();\n          return;\n        }\n        retryCount++;\n        if (retryCount >= MAX_RETRIES) {\n          reject();\n        } else {\n          scheduleRetry(resolve, reject);\n        }\n      }, delay);\n    };\n    return new Promise((resolve, reject) => {\n      scheduleRetry(() => resolve(this), reject);\n    });\n  }\n  getProvider() {\n    return (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this) || null;\n  }\n  get isConnected() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    return provider?.isConnected && provider.selectedAddress ? true : false;\n  }\n  async connect({ onlyIfTrusted }) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (provider.isConnected && provider.selectedAddress) {\n      return this.getAccounts();\n    }\n    try {\n      const accounts = await provider.request({\n        method: onlyIfTrusted ? \"eth_accounts\" : \"eth_requestAccounts\"\n      });\n      return accounts;\n    } catch (_) {\n      return void 0;\n    }\n  }\n  async disconnect() {\n    return Promise.resolve();\n  }\n  async getAccounts() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      return [];\n    }\n    try {\n      const accounts = await provider.request({ method: \"eth_accounts\" });\n      return accounts || [];\n    } catch (_) {\n      return [];\n    }\n  }\n  async signMessage(message, address) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const signature = await provider.request({\n      method: \"eth_sign\",\n      params: [address, message]\n    });\n    return signature;\n  }\n  async signPersonalMessage(message, address) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const signature = await provider.request({\n      method: \"personal_sign\",\n      params: [message, address]\n    });\n    return signature;\n  }\n  async signTypedData(typedData, address) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const signature = await provider.request({\n      method: \"eth_signTypedData_v4\",\n      params: [address, JSON.stringify(typedData)]\n    });\n    return signature;\n  }\n  async signIn(signInData) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    const message = createSiweMessage(signInData);\n    const address = provider.selectedAddress;\n    if (!address) {\n      throw new Error(\"No address available.\");\n    }\n    const signature = await this.signPersonalMessage(message, address);\n    return {\n      address,\n      signature,\n      signedMessage: message\n    };\n  }\n  async sendTransaction(transaction) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const txHash = await provider.request({\n      method: \"eth_sendTransaction\",\n      params: [transaction]\n    });\n    return txHash;\n  }\n  async signTransaction(transaction) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const signedTx = await provider.request({\n      method: \"eth_signTransaction\",\n      params: [transaction]\n    });\n    return signedTx;\n  }\n  async getChainId() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    const chainId = await provider.request({ method: \"eth_chainId\" });\n    return chainId;\n  }\n  async switchChain(chainId) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId }]\n    });\n  }\n  async request(args) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_0__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    return await provider.request(args);\n  }\n};\n_getProvider = new WeakSet();\ngetProvider_fn = function() {\n  if (typeof window === \"undefined\") {\n    return void 0;\n  }\n  return window?.phantom?.ethereum;\n};\n\n// src/ethereum/getProvider.ts\nasync function getProvider(strategy = \"injected\" /* INJECTED */) {\n  if (strategy === \"injected\") {\n    const provider = new InjectedEthereumStrategy();\n    try {\n      await provider.load();\n      return provider;\n    } catch (error) {\n      throw new Error(\"Provider not found.\");\n    }\n  } else {\n    throw new Error(\"Invalid provider type.\");\n  }\n}\n\n// src/ethereum/eventListeners.ts\nvar eventListeners = /* @__PURE__ */ new Map();\nfunction addEventListener(event, callback) {\n  if (!eventListeners.has(event)) {\n    eventListeners.set(event, /* @__PURE__ */ new Set());\n  }\n  const listeners = eventListeners.get(event);\n  listeners?.add(callback);\n  return () => removeEventListener(event, callback);\n}\nfunction removeEventListener(event, callback) {\n  const listeners = eventListeners.get(event);\n  if (listeners) {\n    listeners.delete(callback);\n  }\n}\nfunction triggerEvent(event, data) {\n  const listeners = eventListeners.get(event);\n  if (listeners) {\n    listeners.forEach((callback) => {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in ${event} event listener:`, error);\n      }\n    });\n  }\n}\n\n// src/ethereum/connect.ts\nasync function connect({ onlyIfTrusted = false } = {}) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (provider.isConnected) {\n    const accounts = await provider.getAccounts();\n    return accounts;\n  }\n  try {\n    const accounts = await provider.connect({ onlyIfTrusted: true });\n    if (accounts && accounts.length > 0) {\n      triggerEvent(\"connect\", accounts);\n      return accounts;\n    }\n  } catch (error) {\n  }\n  if (onlyIfTrusted) {\n    throw new Error(\"No trusted connection available.\");\n  }\n  try {\n    const accounts = await provider.connect({ onlyIfTrusted: false });\n    if (accounts && accounts.length > 0) {\n      triggerEvent(\"connect\", accounts);\n      return accounts;\n    }\n  } catch (error) {\n  }\n  throw new Error(\"Failed to connect to Phantom.\");\n}\n\n// src/ethereum/disconnect.ts\nasync function disconnect() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  await provider.disconnect();\n  triggerEvent(\"disconnect\", []);\n}\n\n// src/ethereum/getAccounts.ts\nasync function getAccounts() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  return provider.getAccounts();\n}\n\n// src/ethereum/signMessage.ts\nasync function signPersonalMessage(message, address) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signPersonalMessage(message, address);\n}\nasync function signTypedData(typedData, address) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signTypedData(typedData, address);\n}\n\n// src/ethereum/sendTransaction.ts\nasync function sendTransaction(transaction) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.sendTransaction(transaction);\n}\nasync function signTransaction(transaction) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signTransaction(transaction);\n}\n\n// src/ethereum/chainUtils.ts\nasync function getChainId() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  return provider.getChainId();\n}\nasync function switchChain(chainId) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  return provider.switchChain(chainId);\n}\n\n// src/ethereum/plugin.ts\nvar Ethereum = class {\n  constructor() {\n    this._chainId = \"0x1\";\n    this._accounts = [];\n    this.bindProviderEvents();\n  }\n  get connected() {\n    return this._accounts.length > 0;\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  get accounts() {\n    return this._accounts;\n  }\n  async request(args) {\n    const provider = await getProvider();\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    const providerInstance = provider.getProvider();\n    if (!providerInstance) {\n      throw new Error(\"Provider instance not found.\");\n    }\n    return providerInstance.request(args);\n  }\n  async connect() {\n    const accounts = await connect();\n    this._accounts = accounts;\n    return accounts;\n  }\n  async disconnect() {\n    await disconnect();\n    this._accounts = [];\n  }\n  signPersonalMessage(message, address) {\n    return signPersonalMessage(message, address);\n  }\n  signTypedData(data, address) {\n    return signTypedData(data, address);\n  }\n  signTransaction(transaction) {\n    return signTransaction(transaction);\n  }\n  sendTransaction(transaction) {\n    return sendTransaction(transaction);\n  }\n  async switchChain(chainId) {\n    const hexChainId = typeof chainId === \"string\" ? chainId.toLowerCase().startsWith(\"0x\") ? chainId.toLowerCase() : `0x${parseInt(chainId, 10).toString(16)}` : `0x${chainId.toString(16)}`;\n    await switchChain(hexChainId);\n    this._chainId = hexChainId;\n  }\n  async getChainId() {\n    const chainId = await getChainId();\n    const parsed = parseInt(chainId, 16);\n    this._chainId = chainId;\n    return parsed;\n  }\n  async getAccounts() {\n    const accounts = await getAccounts();\n    this._accounts = accounts;\n    return accounts;\n  }\n  isConnected() {\n    return this._accounts.length > 0;\n  }\n  on(event, listener) {\n    addEventListener(event, listener);\n  }\n  off(event, listener) {\n    removeEventListener(event, listener);\n  }\n  async bindProviderEvents() {\n    try {\n      const strategy = await getProvider();\n      const provider = strategy.getProvider();\n      if (provider) {\n        provider.on(\"connect\", async () => {\n          try {\n            const accounts = await provider.request({ method: \"eth_accounts\" });\n            if (accounts?.length > 0) {\n              this._accounts = accounts;\n              triggerEvent(\"connect\", accounts);\n            }\n          } catch {\n          }\n        });\n        provider.on(\"disconnect\", () => {\n          this._accounts = [];\n          const error = {\n            code: 4900,\n            message: \"Provider disconnected\"\n          };\n          triggerEvent(\"disconnect\", error);\n        });\n        provider.on(\"accountsChanged\", (accounts) => {\n          this._accounts = accounts;\n          triggerEvent(\"accountsChanged\", accounts);\n          if (accounts && accounts.length > 0) {\n            triggerEvent(\"connect\", accounts);\n          }\n        });\n        provider.on(\"chainChanged\", (chainId) => {\n          this._chainId = chainId;\n          triggerEvent(\"chainChanged\", chainId);\n        });\n      }\n    } catch (error) {\n    }\n  }\n};\nfunction createEthereumPlugin() {\n  return {\n    name: \"ethereum\",\n    create: () => {\n      return new Ethereum();\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9jaHVuay1DUzIzVkRERC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRzhCOztBQUU5QjtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDLCtDQUErQyxLQUFLLDBCQUEwQixHQUFHLFFBQVEsSUFBSTtBQUM3Rix1TEFBdUwsSUFBSTtBQUMzTCx5Q0FBeUMsSUFBSTtBQUM3QyxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU8sS0FBSyxPQUFPO0FBQ2hELG9DQUFvQztBQUNwQztBQUNBLG9CQUFvQixRQUFRO0FBQzVCLEVBQUU7O0FBRUYsRUFBRSxVQUFVO0FBQ1osdUJBQXVCO0FBQ3ZCLFdBQVc7QUFDWCxZQUFZO0FBQ1osU0FBUztBQUNULGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxTQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNkay9kaXN0L2NodW5rLUNTMjNWRERELm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBfX3ByaXZhdGVBZGQsXG4gIF9fcHJpdmF0ZU1ldGhvZFxufSBmcm9tIFwiLi9jaHVuay1HVjZBSUhQTi5tanNcIjtcblxuLy8gc3JjL2V0aGVyZXVtL3Npd2UudHNcbnZhciBBRERSRVNTX1JFR0VYID0gL14weFthLWZBLUYwLTldezQwfSQvO1xudmFyIERPTUFJTl9SRUdFWCA9IC9eKFthLXpBLVowLTldKFthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsfSg6WzAtOV17MSw1fSk/JC87XG52YXIgSVBfUkVHRVggPSAvXigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pKDpbMC05XXsxLDV9KT8kLztcbnZhciBMT0NBTEhPU1RfUkVHRVggPSAvXmxvY2FsaG9zdCg6WzAtOV17MSw1fSk/JC87XG52YXIgTk9OQ0VfUkVHRVggPSAvXlthLXpBLVowLTldezgsfSQvO1xudmFyIFNDSEVNRV9SRUdFWCA9IC9eKFthLXpBLVpdW2EtekEtWjAtOSstLl0qKSQvO1xuZnVuY3Rpb24gY3JlYXRlU2l3ZU1lc3NhZ2Uoe1xuICBhZGRyZXNzLFxuICBjaGFpbklkLFxuICBkb21haW4sXG4gIG5vbmNlLFxuICB1cmksXG4gIHZlcnNpb24sXG4gIHNjaGVtZSxcbiAgc3RhdGVtZW50OiBfc3RhdGVtZW50LFxuICByZXF1ZXN0SWQsXG4gIHJlc291cmNlcyxcbiAgaXNzdWVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgZXhwaXJhdGlvblRpbWUsXG4gIG5vdEJlZm9yZVxufSkge1xuICBpZiAoIUFERFJFU1NfUkVHRVgudGVzdChhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgbXVzdCBiZSBhIGhleCB2YWx1ZSBvZiAyMCBieXRlcyAoNDAgaGV4IGNoYXJhY3RlcnMpLlwiKTtcbiAgfVxuICBpZiAoY2hhaW5JZCAhPT0gTWF0aC5mbG9vcihjaGFpbklkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNoYWluSWQgbXVzdCBiZSBhIEVJUC0xNTUgY2hhaW4gSUQuXCIpO1xuICB9XG4gIGlmICghKERPTUFJTl9SRUdFWC50ZXN0KGRvbWFpbikgfHwgSVBfUkVHRVgudGVzdChkb21haW4pIHx8IExPQ0FMSE9TVF9SRUdFWC50ZXN0KGRvbWFpbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZG9tYWluIG11c3QgYmUgYW4gUkZDIDM5ODYgYXV0aG9yaXR5LlwiKTtcbiAgfVxuICBpZiAoIU5PTkNFX1JFR0VYLnRlc3Qobm9uY2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm9uY2UgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMuXCIpO1xuICB9XG4gIGlmICghX2lzVXJpKHVyaSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmkgbXVzdCBiZSBhIFJGQyAzOTg2IFVSSSByZWZlcnJpbmcgdG8gdGhlIHJlc291cmNlIHRoYXQgaXMgdGhlIHN1YmplY3Qgb2YgdGhlIHNpZ25pbmcuXCIpO1xuICB9XG4gIGlmICh2ZXJzaW9uICE9PSBcIjFcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInZlcnNpb24gbXVzdCBiZSAnMScuXCIpO1xuICB9XG4gIGlmIChzY2hlbWUgJiYgIVNDSEVNRV9SRUdFWC50ZXN0KHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWUgbXVzdCBiZSBhbiBSRkMgMzk4NiBVUkkgc2NoZW1lLlwiKTtcbiAgfVxuICBpZiAoX3N0YXRlbWVudD8uaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLlwiKTtcbiAgfVxuICBjb25zdCBvcmlnaW4gPSBzY2hlbWUgPyBgJHtzY2hlbWV9Oi8vJHtkb21haW59YCA6IGRvbWFpbjtcbiAgY29uc3Qgc3RhdGVtZW50ID0gX3N0YXRlbWVudCA/IGAke19zdGF0ZW1lbnR9XG5gIDogXCJcIjtcbiAgY29uc3QgcHJlZml4ID0gYCR7b3JpZ2lufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcbiR7YWRkcmVzc31cblxuJHtzdGF0ZW1lbnR9YDtcbiAgbGV0IHN1ZmZpeCA9IGBVUkk6ICR7dXJpfVxuVmVyc2lvbjogJHt2ZXJzaW9ufVxuQ2hhaW4gSUQ6ICR7Y2hhaW5JZH1cbk5vbmNlOiAke25vbmNlfVxuSXNzdWVkIEF0OiAke2lzc3VlZEF0LnRvSVNPU3RyaW5nKCl9YDtcbiAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgc3VmZml4ICs9IGBcbkV4cGlyYXRpb24gVGltZTogJHtleHBpcmF0aW9uVGltZS50b0lTT1N0cmluZygpfWA7XG4gIH1cbiAgaWYgKG5vdEJlZm9yZSkge1xuICAgIHN1ZmZpeCArPSBgXG5Ob3QgQmVmb3JlOiAke25vdEJlZm9yZS50b0lTT1N0cmluZygpfWA7XG4gIH1cbiAgaWYgKHJlcXVlc3RJZCkge1xuICAgIHN1ZmZpeCArPSBgXG5SZXF1ZXN0IElEOiAke3JlcXVlc3RJZH1gO1xuICB9XG4gIGlmIChyZXNvdXJjZXMpIHtcbiAgICBsZXQgY29udGVudCA9IFwiXFxuUmVzb3VyY2VzOlwiO1xuICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICBpZiAoIV9pc1VyaShyZXNvdXJjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb3VyY2VzIG11c3QgYmUgUkZDIDM5ODYgVVJJcy5cIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGBcbi0gJHtyZXNvdXJjZX1gO1xuICAgIH1cbiAgICBzdWZmaXggKz0gY29udGVudDtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4fVxuJHtzdWZmaXh9YDtcbn1cbmZ1bmN0aW9uIF9pc1VyaSh2YWx1ZSkge1xuICBpZiAoL1teYS16MC05Oi8/I1tcXF1AISQmJygpKissOz0uXFwtX34lXS9pLnRlc3QodmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKC8lW14wLTlhLWZdL2kudGVzdCh2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoLyVbMC05YS1mXSg6P1teMC05YS1mXXwkKS9pLnRlc3QodmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gIGNvbnN0IHNjaGVtZSA9IHNwbGl0dGVkWzFdO1xuICBjb25zdCBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgY29uc3QgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICBjb25zdCBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICBjb25zdCBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuICBpZiAoIShzY2hlbWU/Lmxlbmd0aCAmJiBwYXRoLmxlbmd0aCA+PSAwKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhdXRob3JpdHk/Lmxlbmd0aCkge1xuICAgIGlmICghKHBhdGgubGVuZ3RoID09PSAwIHx8IC9eXFwvLy50ZXN0KHBhdGgpKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoL15cXC9cXC8vLnRlc3QocGF0aCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEvXlthLXpdW2EtejAtOStcXC0uXSokLy50ZXN0KHNjaGVtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBvdXQgKz0gYCR7c2NoZW1lfTpgO1xuICBpZiAoYXV0aG9yaXR5Py5sZW5ndGgpXG4gICAgb3V0ICs9IGAvLyR7YXV0aG9yaXR5fWA7XG4gIG91dCArPSBwYXRoO1xuICBpZiAocXVlcnk/Lmxlbmd0aClcbiAgICBvdXQgKz0gYD8ke3F1ZXJ5fWA7XG4gIGlmIChmcmFnbWVudD8ubGVuZ3RoKVxuICAgIG91dCArPSBgIyR7ZnJhZ21lbnR9YDtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHNwbGl0VXJpKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaCgvKD86KFteOi8/I10rKTopPyg/OlxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/Lyk7XG59XG5cbi8vIHNyYy9ldGhlcmV1bS9zdHJhdGVnaWVzL2luamVjdGVkLnRzXG52YXIgTUFYX1JFVFJJRVMgPSA0O1xudmFyIEJBU0VfREVMQVkgPSAxMDA7XG52YXIgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbjtcbnZhciBJbmplY3RlZEV0aGVyZXVtU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZ2V0UHJvdmlkZXIpO1xuICAgIHRoaXMudHlwZSA9IFwiaW5qZWN0ZWRcIiAvKiBJTkpFQ1RFRCAqLztcbiAgfVxuICBsb2FkKCkge1xuICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICBjb25zdCBzY2hlZHVsZVJldHJ5ID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZGVsYXkgPSBCQVNFX0RFTEFZICogTWF0aC5wb3coMiwgTWF0aC5taW4ocmV0cnlDb3VudCwgNSkpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICBpZiAocmV0cnlDb3VudCA+PSBNQVhfUkVUUklFUykge1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnkocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNjaGVkdWxlUmV0cnkoKCkgPT4gcmVzb2x2ZSh0aGlzKSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBnZXRQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcykgfHwgbnVsbDtcbiAgfVxuICBnZXQgaXNDb25uZWN0ZWQoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gcHJvdmlkZXI/LmlzQ29ubmVjdGVkICYmIHByb3ZpZGVyLnNlbGVjdGVkQWRkcmVzcyA/IHRydWUgOiBmYWxzZTtcbiAgfVxuICBhc3luYyBjb25uZWN0KHsgb25seUlmVHJ1c3RlZCB9KSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBpZiAocHJvdmlkZXIuaXNDb25uZWN0ZWQgJiYgcHJvdmlkZXIuc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50cygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBvbmx5SWZUcnVzdGVkID8gXCJldGhfYWNjb3VudHNcIiA6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfYWNjb3VudHNcIiB9KTtcbiAgICAgIHJldHVybiBhY2NvdW50cyB8fCBbXTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UsIGFkZHJlc3MpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGlzIG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJldGhfc2lnblwiLFxuICAgICAgcGFyYW1zOiBbYWRkcmVzcywgbWVzc2FnZV1cbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbmF0dXJlO1xuICB9XG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZSwgYWRkcmVzcykge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgaWYgKCFwcm92aWRlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcInBlcnNvbmFsX3NpZ25cIixcbiAgICAgIHBhcmFtczogW21lc3NhZ2UsIGFkZHJlc3NdXG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgfVxuICBhc3luYyBzaWduVHlwZWREYXRhKHR5cGVkRGF0YSwgYWRkcmVzcykge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgaWYgKCFwcm92aWRlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsXG4gICAgICBwYXJhbXM6IFthZGRyZXNzLCBKU09OLnN0cmluZ2lmeSh0eXBlZERhdGEpXVxuICAgIH0pO1xuICAgIHJldHVybiBzaWduYXR1cmU7XG4gIH1cbiAgYXN5bmMgc2lnbkluKHNpZ25JbkRhdGEpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZShzaWduSW5EYXRhKTtcbiAgICBjb25zdCBhZGRyZXNzID0gcHJvdmlkZXIuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWRkcmVzcyBhdmFpbGFibGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZSwgYWRkcmVzcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBzaWduZWRNZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGlzIG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICBwYXJhbXM6IFt0cmFuc2FjdGlvbl1cbiAgICB9KTtcbiAgICByZXR1cm4gdHhIYXNoO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgaWYgKCFwcm92aWRlci5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgcGFyYW1zOiBbdHJhbnNhY3Rpb25dXG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ25lZFR4O1xuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiIH0pO1xuICAgIHJldHVybiBjaGFpbklkO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKGNoYWluSWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXG4gICAgICBwYXJhbXM6IFt7IGNoYWluSWQgfV1cbiAgICB9KTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KGFyZ3MpO1xuICB9XG59O1xuX2dldFByb3ZpZGVyID0gbmV3IFdlYWtTZXQoKTtcbmdldFByb3ZpZGVyX2ZuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gd2luZG93Py5waGFudG9tPy5ldGhlcmV1bTtcbn07XG5cbi8vIHNyYy9ldGhlcmV1bS9nZXRQcm92aWRlci50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXIoc3RyYXRlZ3kgPSBcImluamVjdGVkXCIgLyogSU5KRUNURUQgKi8pIHtcbiAgaWYgKHN0cmF0ZWd5ID09PSBcImluamVjdGVkXCIpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBJbmplY3RlZEV0aGVyZXVtU3RyYXRlZ3koKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlkZXIubG9hZCgpO1xuICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIHR5cGUuXCIpO1xuICB9XG59XG5cbi8vIHNyYy9ldGhlcmV1bS9ldmVudExpc3RlbmVycy50c1xudmFyIGV2ZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGlmICghZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuICAgIGV2ZW50TGlzdGVuZXJzLnNldChldmVudCwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgbGlzdGVuZXJzPy5hZGQoY2FsbGJhY2spO1xuICByZXR1cm4gKCkgPT4gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiAke2V2ZW50fSBldmVudCBsaXN0ZW5lcjpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2V0aGVyZXVtL2Nvbm5lY3QudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QoeyBvbmx5SWZUcnVzdGVkID0gZmFsc2UgfSA9IHt9KSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gIH1cbiAgaWYgKHByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5nZXRBY2NvdW50cygpO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IHRydWUgfSk7XG4gICAgaWYgKGFjY291bnRzICYmIGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyaWdnZXJFdmVudChcImNvbm5lY3RcIiwgYWNjb3VudHMpO1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxuICBpZiAob25seUlmVHJ1c3RlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRydXN0ZWQgY29ubmVjdGlvbiBhdmFpbGFibGUuXCIpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5jb25uZWN0KHsgb25seUlmVHJ1c3RlZDogZmFsc2UgfSk7XG4gICAgaWYgKGFjY291bnRzICYmIGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyaWdnZXJFdmVudChcImNvbm5lY3RcIiwgYWNjb3VudHMpO1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBQaGFudG9tLlwiKTtcbn1cblxuLy8gc3JjL2V0aGVyZXVtL2Rpc2Nvbm5lY3QudHNcbmFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gIH1cbiAgYXdhaXQgcHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICB0cmlnZ2VyRXZlbnQoXCJkaXNjb25uZWN0XCIsIFtdKTtcbn1cblxuLy8gc3JjL2V0aGVyZXVtL2dldEFjY291bnRzLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50cygpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICByZXR1cm4gcHJvdmlkZXIuZ2V0QWNjb3VudHMoKTtcbn1cblxuLy8gc3JjL2V0aGVyZXVtL3NpZ25NZXNzYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBzaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UsIGFkZHJlc3MpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UsIGFkZHJlc3MpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YSh0eXBlZERhdGEsIGFkZHJlc3MpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduVHlwZWREYXRhKHR5cGVkRGF0YSwgYWRkcmVzcyk7XG59XG5cbi8vIHNyYy9ldGhlcmV1bS9zZW5kVHJhbnNhY3Rpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICBhd2FpdCBwcm92aWRlci5jb25uZWN0KHsgb25seUlmVHJ1c3RlZDogZmFsc2UgfSk7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xufVxuXG4vLyBzcmMvZXRoZXJldW0vY2hhaW5VdGlscy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q2hhaW5JZCgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICByZXR1cm4gcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gc3dpdGNoQ2hhaW4oY2hhaW5JZCkge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zd2l0Y2hDaGFpbihjaGFpbklkKTtcbn1cblxuLy8gc3JjL2V0aGVyZXVtL3BsdWdpbi50c1xudmFyIEV0aGVyZXVtID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jaGFpbklkID0gXCIweDFcIjtcbiAgICB0aGlzLl9hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuYmluZFByb3ZpZGVyRXZlbnRzKCk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudHMubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgY2hhaW5JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW5JZDtcbiAgfVxuICBnZXQgYWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY291bnRzO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlckluc3RhbmNlID0gcHJvdmlkZXIuZ2V0UHJvdmlkZXIoKTtcbiAgICBpZiAoIXByb3ZpZGVySW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGluc3RhbmNlIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlckluc3RhbmNlLnJlcXVlc3QoYXJncyk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICB0aGlzLl9hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGF3YWl0IGRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9hY2NvdW50cyA9IFtdO1xuICB9XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZSwgYWRkcmVzcykge1xuICAgIHJldHVybiBzaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UsIGFkZHJlc3MpO1xuICB9XG4gIHNpZ25UeXBlZERhdGEoZGF0YSwgYWRkcmVzcykge1xuICAgIHJldHVybiBzaWduVHlwZWREYXRhKGRhdGEsIGFkZHJlc3MpO1xuICB9XG4gIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICB9XG4gIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICB9XG4gIGFzeW5jIHN3aXRjaENoYWluKGNoYWluSWQpIHtcbiAgICBjb25zdCBoZXhDaGFpbklkID0gdHlwZW9mIGNoYWluSWQgPT09IFwic3RyaW5nXCIgPyBjaGFpbklkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcIjB4XCIpID8gY2hhaW5JZC50b0xvd2VyQ2FzZSgpIDogYDB4JHtwYXJzZUludChjaGFpbklkLCAxMCkudG9TdHJpbmcoMTYpfWAgOiBgMHgke2NoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgYXdhaXQgc3dpdGNoQ2hhaW4oaGV4Q2hhaW5JZCk7XG4gICAgdGhpcy5fY2hhaW5JZCA9IGhleENoYWluSWQ7XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgICB0aGlzLl9jaGFpbklkID0gY2hhaW5JZDtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLl9hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudHMubGVuZ3RoID4gMDtcbiAgfVxuICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBhc3luYyBiaW5kUHJvdmlkZXJFdmVudHMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3RyYXRlZ3kuZ2V0UHJvdmlkZXIoKTtcbiAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICBwcm92aWRlci5vbihcImNvbm5lY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX2FjY291bnRzXCIgfSk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwiY29ubmVjdFwiLCBhY2NvdW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9hY2NvdW50cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0ge1xuICAgICAgICAgICAgY29kZTogNDkwMCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiUHJvdmlkZXIgZGlzY29ubmVjdGVkXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcImRpc2Nvbm5lY3RcIiwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJhY2NvdW50c0NoYW5nZWRcIiwgYWNjb3VudHMpO1xuICAgICAgICAgIGlmIChhY2NvdW50cyAmJiBhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJjb25uZWN0XCIsIGFjY291bnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwcm92aWRlci5vbihcImNoYWluQ2hhbmdlZFwiLCAoY2hhaW5JZCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcImNoYWluQ2hhbmdlZFwiLCBjaGFpbklkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVFdGhlcmV1bVBsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcImV0aGVyZXVtXCIsXG4gICAgY3JlYXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IEV0aGVyZXVtKCk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQge1xuICBjcmVhdGVTaXdlTWVzc2FnZSxcbiAgY3JlYXRlRXRoZXJldW1QbHVnaW5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-CS23VDDD.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __privateAdd: () => (/* binding */ __privateAdd),\n/* harmony export */   __privateMethod: () => (/* binding */ __privateMethod)\n/* harmony export */ });\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9jaHVuay1HVjZBSUhQTi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9jaHVuay1HVjZBSUhQTi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZU1ldGhvZCA9IChvYmosIG1lbWJlciwgbWV0aG9kKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpO1xuICByZXR1cm4gbWV0aG9kO1xufTtcblxuZXhwb3J0IHtcbiAgX19wcml2YXRlQWRkLFxuICBfX3ByaXZhdGVNZXRob2Rcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-WUKYLWAZ.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/chunk-WUKYLWAZ.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/ethereum/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/ethereum/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEthereumPlugin: () => (/* reexport safe */ _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__.createEthereumPlugin),\n/* harmony export */   createSiweMessage: () => (/* reexport safe */ _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__.createSiweMessage)\n/* harmony export */ });\n/* harmony import */ var _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-CS23VDDD.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-CS23VDDD.mjs\");\n/* harmony import */ var _chunk_WUKYLWAZ_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-WUKYLWAZ.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-WUKYLWAZ.mjs\");\n/* harmony import */ var _chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../chunk-GV6AIHPN.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9ldGhlcmV1bS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHK0I7QUFDQTtBQUNBO0FBSTdCIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNkay9kaXN0L2V0aGVyZXVtL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjcmVhdGVFdGhlcmV1bVBsdWdpbixcbiAgY3JlYXRlU2l3ZU1lc3NhZ2Vcbn0gZnJvbSBcIi4uL2NodW5rLUNTMjNWRERELm1qc1wiO1xuaW1wb3J0IFwiLi4vY2h1bmstV1VLWUxXQVoubWpzXCI7XG5pbXBvcnQgXCIuLi9jaHVuay1HVjZBSUhQTi5tanNcIjtcbmV4cG9ydCB7XG4gIGNyZWF0ZUV0aGVyZXVtUGx1Z2luLFxuICBjcmVhdGVTaXdlTWVzc2FnZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/ethereum/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEthereumPlugin: () => (/* reexport safe */ _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__.createEthereumPlugin),\n/* harmony export */   createExtensionPlugin: () => (/* binding */ createExtensionPlugin),\n/* harmony export */   createPhantom: () => (/* binding */ createPhantom),\n/* harmony export */   createSiweMessage: () => (/* reexport safe */ _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__.createSiweMessage),\n/* harmony export */   isPhantomExtensionInstalled: () => (/* binding */ isInstalled)\n/* harmony export */ });\n/* harmony import */ var _chunk_CS23VDDD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-CS23VDDD.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-CS23VDDD.mjs\");\n/* harmony import */ var _chunk_WUKYLWAZ_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-WUKYLWAZ.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-WUKYLWAZ.mjs\");\n/* harmony import */ var _chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-GV6AIHPN.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\");\n\n\n\n\n// src/extension/isInstalled.ts\nfunction isInstalled() {\n  try {\n    const phantom = window?.phantom;\n    return !!phantom;\n  } catch (error) {\n    return false;\n  }\n}\n\n// src/extension/plugin.ts\nvar extension = {\n  isInstalled\n};\nfunction createExtensionPlugin() {\n  return {\n    name: \"extension\",\n    create: () => extension\n  };\n}\n\n// src/index.ts\nfunction createPhantom({ plugins = [] }) {\n  const phantom = {};\n  for (const plugin of plugins) {\n    phantom[plugin.name] = plugin.create();\n  }\n  return phantom;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFHOEI7QUFDQTtBQUNBOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9FIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNkay9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjcmVhdGVFdGhlcmV1bVBsdWdpbixcbiAgY3JlYXRlU2l3ZU1lc3NhZ2Vcbn0gZnJvbSBcIi4vY2h1bmstQ1MyM1ZEREQubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLVdVS1lMV0FaLm1qc1wiO1xuaW1wb3J0IFwiLi9jaHVuay1HVjZBSUhQTi5tanNcIjtcblxuLy8gc3JjL2V4dGVuc2lvbi9pc0luc3RhbGxlZC50c1xuZnVuY3Rpb24gaXNJbnN0YWxsZWQoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGhhbnRvbSA9IHdpbmRvdz8ucGhhbnRvbTtcbiAgICByZXR1cm4gISFwaGFudG9tO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvZXh0ZW5zaW9uL3BsdWdpbi50c1xudmFyIGV4dGVuc2lvbiA9IHtcbiAgaXNJbnN0YWxsZWRcbn07XG5mdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJleHRlbnNpb25cIixcbiAgICBjcmVhdGU6ICgpID0+IGV4dGVuc2lvblxuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZVBoYW50b20oeyBwbHVnaW5zID0gW10gfSkge1xuICBjb25zdCBwaGFudG9tID0ge307XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBwaGFudG9tW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5jcmVhdGUoKTtcbiAgfVxuICByZXR1cm4gcGhhbnRvbTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUV0aGVyZXVtUGx1Z2luLFxuICBjcmVhdGVFeHRlbnNpb25QbHVnaW4sXG4gIGNyZWF0ZVBoYW50b20sXG4gIGNyZWF0ZVNpd2VNZXNzYWdlLFxuICBpc0luc3RhbGxlZCBhcyBpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/solana/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@phantom/browser-injected-sdk/dist/solana/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSolanaPlugin: () => (/* binding */ createSolanaPlugin)\n/* harmony export */ });\n/* harmony import */ var _chunk_WUKYLWAZ_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-WUKYLWAZ.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-WUKYLWAZ.mjs\");\n/* harmony import */ var _chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-GV6AIHPN.mjs */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/chunk-GV6AIHPN.mjs\");\n\n\n\n// src/solana/strategies/injected.ts\nvar MAX_RETRIES = 4;\nvar BASE_DELAY = 100;\nvar _getProvider, getProvider_fn;\nvar InjectedSolanaStrategy = class {\n  constructor() {\n    (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateAdd)(this, _getProvider);\n    this.type = \"injected\" /* INJECTED */;\n  }\n  load() {\n    let retryCount = 0;\n    const scheduleRetry = (resolve, reject) => {\n      const delay = BASE_DELAY * Math.pow(2, Math.min(retryCount, 5));\n      setTimeout(() => {\n        if ((0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this)) {\n          resolve();\n          return;\n        }\n        retryCount++;\n        if (retryCount >= MAX_RETRIES) {\n          reject();\n        } else {\n          scheduleRetry(resolve, reject);\n        }\n      }, delay);\n    };\n    return new Promise((resolve, reject) => {\n      scheduleRetry(() => resolve(this), reject);\n    });\n  }\n  getProvider() {\n    return (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this) || null;\n  }\n  get isConnected() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    return provider?.isConnected && provider.publicKey ? true : false;\n  }\n  async connect({ onlyIfTrusted }) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (provider.isConnected && provider.publicKey) {\n      return this.getAccount() ?? void 0;\n    }\n    try {\n      const result = await provider.connect({ onlyIfTrusted });\n      return result.publicKey.toString();\n    } catch (_) {\n      return void 0;\n    }\n  }\n  async disconnect() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    await provider.disconnect();\n  }\n  async getAccount() {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (provider && provider.isConnected && provider.publicKey) {\n      return Promise.resolve(provider.publicKey.toString());\n    }\n    return Promise.resolve(void 0);\n  }\n  async signMessage(message, display) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const result = await provider.signMessage(message, display);\n    return {\n      signature: result.signature,\n      address: result.publicKey.toString()\n    };\n  }\n  async signIn(signInData) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    const result = await provider.signIn(signInData);\n    return {\n      address: result.address.toString(),\n      signature: result.signature,\n      signedMessage: result.signedMessage\n    };\n  }\n  async signAndSendTransaction(transaction) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const result = await provider.signAndSendTransaction(transaction);\n    return {\n      signature: result.signature,\n      address: result.publicKey\n    };\n  }\n  async signAndSendAllTransactions(transactions) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    if (!provider.signAndSendAllTransactions) {\n      throw new Error(\"Provider does not support signAndSendAllTransactions.\");\n    }\n    const results = await provider.signAndSendAllTransactions(transactions);\n    return {\n      signatures: results.signatures,\n      address: results.publicKey\n    };\n  }\n  async signTransaction(transaction) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const result = await provider.signTransaction(transaction);\n    return result;\n  }\n  async signAllTransactions(transactions) {\n    const provider = (0,_chunk_GV6AIHPN_mjs__WEBPACK_IMPORTED_MODULE_1__.__privateMethod)(this, _getProvider, getProvider_fn).call(this);\n    if (!provider) {\n      throw new Error(\"Provider not found.\");\n    }\n    if (!provider.isConnected) {\n      throw new Error(\"Provider is not connected.\");\n    }\n    const result = await provider.signAllTransactions(transactions);\n    return result;\n  }\n};\n_getProvider = new WeakSet();\ngetProvider_fn = function() {\n  if (typeof window === \"undefined\") {\n    return void 0;\n  }\n  return window?.phantom?.solana;\n};\n\n// src/solana/getProvider.ts\nasync function getProvider(strategy = \"injected\" /* INJECTED */) {\n  if (strategy === \"injected\") {\n    const provider = new InjectedSolanaStrategy();\n    try {\n      await provider.load();\n      return provider;\n    } catch (error) {\n      throw new Error(\"Provider not found.\");\n    }\n  } else {\n    throw new Error(\"Invalid provider type.\");\n  }\n}\n\n// src/solana/eventListeners.ts\nvar eventCallbacks = /* @__PURE__ */ new Map();\nfunction addEventListener(event, callback) {\n  if (!eventCallbacks.has(event)) {\n    eventCallbacks.set(event, /* @__PURE__ */ new Set());\n  }\n  eventCallbacks.get(event)?.add(callback);\n  return () => {\n    removeEventListener(event, callback);\n  };\n}\nfunction removeEventListener(event, callback) {\n  if (eventCallbacks.has(event)) {\n    eventCallbacks.get(event)?.delete(callback);\n    if (eventCallbacks.get(event)?.size === 0) {\n      eventCallbacks.delete(event);\n    }\n  }\n}\nfunction triggerEvent(event, ...args) {\n  if (eventCallbacks.has(event)) {\n    eventCallbacks.get(event)?.forEach((cb) => {\n      try {\n        cb(...args);\n      } catch (error) {\n        console.error(`Error in ${event} event listener:`, error);\n      }\n    });\n  }\n}\n\n// src/solana/connect.ts\nasync function connect({ onlyIfTrusted = false } = {}) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (provider.isConnected) {\n    return provider.getAccount();\n  }\n  try {\n    const address = await provider.connect({ onlyIfTrusted: true });\n    if (address) {\n      triggerEvent(\"connect\", address);\n      return address;\n    }\n  } catch (error) {\n  }\n  if (onlyIfTrusted) {\n    throw new Error(\"No trusted connection available.\");\n  }\n  try {\n    const address = await provider.connect({ onlyIfTrusted: false });\n    if (address) {\n      triggerEvent(\"connect\", address);\n      return address;\n    }\n  } catch (error) {\n  }\n  throw new Error(\"Failed to connect to Phantom.\");\n}\n\n// src/solana/disconnect.ts\nasync function disconnect() {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  await provider.disconnect();\n  triggerEvent(\"disconnect\");\n}\n\n// src/solana/getAccount.ts\nasync function getAccount() {\n  const provider = await getProvider();\n  return provider.getAccount();\n}\n\n// src/solana/signAndSendTransaction.ts\nasync function signAndSendTransaction(transaction) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signAndSendTransaction(transaction);\n}\n\n// src/solana/signAndSendAllTransactions.ts\nasync function signAndSendAllTransactions(transactions) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signAndSendAllTransactions(transactions);\n}\n\n// src/solana/signTransaction.ts\nasync function signTransaction(transaction) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signTransaction(transaction);\n}\n\n// src/solana/signAllTransactions.ts\nasync function signAllTransactions(transactions) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signAllTransactions(transactions);\n}\n\n// src/solana/signMessage.ts\nasync function signMessage(message, display) {\n  const provider = await getProvider();\n  if (!provider) {\n    throw new Error(\"Provider not found.\");\n  }\n  if (!provider.isConnected) {\n    await provider.connect({ onlyIfTrusted: false });\n  }\n  return provider.signMessage(message, display);\n}\n\n// src/solana/plugin.ts\nvar Solana = class {\n  constructor() {\n    this._publicKey = null;\n    this.bindProviderEvents();\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  get connected() {\n    return this._publicKey !== null;\n  }\n  async connect(options) {\n    const address = await connect(options);\n    if (!address) {\n      throw new Error(\"Failed to connect to Solana wallet\");\n    }\n    this._publicKey = address;\n    return { publicKey: address };\n  }\n  async disconnect() {\n    await disconnect();\n    this._publicKey = null;\n  }\n  async signMessage(message) {\n    const messageBytes = typeof message === \"string\" ? new TextEncoder().encode(message) : message;\n    const result = await signMessage(messageBytes);\n    return {\n      signature: result.signature instanceof Uint8Array ? result.signature : new Uint8Array(result.signature),\n      publicKey: result.address || this._publicKey || \"\"\n    };\n  }\n  signTransaction(transaction) {\n    return signTransaction(transaction);\n  }\n  async signAndSendTransaction(transaction) {\n    const result = await signAndSendTransaction(transaction);\n    return { signature: result.signature };\n  }\n  signAllTransactions(transactions) {\n    return signAllTransactions(transactions);\n  }\n  async signAndSendAllTransactions(transactions) {\n    const result = await signAndSendAllTransactions(transactions);\n    return { signatures: result.signatures };\n  }\n  async switchNetwork(_network) {\n    return Promise.resolve();\n  }\n  async getPublicKey() {\n    if (this._publicKey) {\n      return this._publicKey;\n    }\n    try {\n      const account = await getAccount();\n      this._publicKey = account || null;\n      return this._publicKey;\n    } catch {\n      return null;\n    }\n  }\n  isConnected() {\n    return this._publicKey !== null;\n  }\n  on(event, listener) {\n    addEventListener(event, listener);\n  }\n  off(event, listener) {\n    removeEventListener(event, listener);\n  }\n  async bindProviderEvents() {\n    try {\n      const strategy = await getProvider();\n      const provider = strategy.getProvider();\n      if (provider) {\n        provider.on(\"connect\", (publicKey) => {\n          if (publicKey) {\n            const pubKey = publicKey.toString();\n            this._publicKey = pubKey;\n            triggerEvent(\"connect\", pubKey);\n          }\n        });\n        provider.on(\"disconnect\", () => {\n          this._publicKey = null;\n          triggerEvent(\"disconnect\");\n        });\n        provider.on(\"accountChanged\", (publicKey) => {\n          if (publicKey) {\n            const pubKey = publicKey.toString();\n            this._publicKey = pubKey;\n            triggerEvent(\"accountChanged\", pubKey);\n            triggerEvent(\"connect\", pubKey);\n          } else {\n            this._publicKey = null;\n            triggerEvent(\"accountChanged\", null);\n          }\n        });\n      }\n    } catch (error) {\n    }\n  }\n};\nfunction createSolanaPlugin() {\n  return {\n    name: \"solana\",\n    create: () => {\n      return new Solana();\n    }\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvZGlzdC9zb2xhbmEvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUlBOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0VBQWU7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQixvRUFBZTtBQUNwQztBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvRUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvRUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsd0JBQXdCLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL2Jyb3dzZXItaW5qZWN0ZWQtc2RrL2Rpc3Qvc29sYW5hL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuLi9jaHVuay1XVUtZTFdBWi5tanNcIjtcbmltcG9ydCB7XG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlTWV0aG9kXG59IGZyb20gXCIuLi9jaHVuay1HVjZBSUhQTi5tanNcIjtcblxuLy8gc3JjL3NvbGFuYS9zdHJhdGVnaWVzL2luamVjdGVkLnRzXG52YXIgTUFYX1JFVFJJRVMgPSA0O1xudmFyIEJBU0VfREVMQVkgPSAxMDA7XG52YXIgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbjtcbnZhciBJbmplY3RlZFNvbGFuYVN0cmF0ZWd5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFByb3ZpZGVyKTtcbiAgICB0aGlzLnR5cGUgPSBcImluamVjdGVkXCIgLyogSU5KRUNURUQgKi87XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgY29uc3Qgc2NoZWR1bGVSZXRyeSA9IChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGRlbGF5ID0gQkFTRV9ERUxBWSAqIE1hdGgucG93KDIsIE1hdGgubWluKHJldHJ5Q291bnQsIDUpKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcykpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5KHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzY2hlZHVsZVJldHJ5KCgpID0+IHJlc29sdmUodGhpcyksIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpIHx8IG51bGw7XG4gIH1cbiAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHByb3ZpZGVyPy5pc0Nvbm5lY3RlZCAmJiBwcm92aWRlci5wdWJsaWNLZXkgPyB0cnVlIDogZmFsc2U7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQgfSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyLmlzQ29ubmVjdGVkICYmIHByb3ZpZGVyLnB1YmxpY0tleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjb3VudCgpID8/IHZvaWQgMDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmNvbm5lY3QoeyBvbmx5SWZUcnVzdGVkIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgYXdhaXQgcHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGFzeW5jIGdldEFjY291bnQoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAocHJvdmlkZXIgJiYgcHJvdmlkZXIuaXNDb25uZWN0ZWQgJiYgcHJvdmlkZXIucHVibGljS2V5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb3ZpZGVyLnB1YmxpY0tleS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UsIGRpc3BsYXkpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGlzIG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5zaWduTWVzc2FnZShtZXNzYWdlLCBkaXNwbGF5KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiByZXN1bHQuc2lnbmF0dXJlLFxuICAgICAgYWRkcmVzczogcmVzdWx0LnB1YmxpY0tleS50b1N0cmluZygpXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduSW4oc2lnbkluRGF0YSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQcm92aWRlciwgZ2V0UHJvdmlkZXJfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuc2lnbkluKHNpZ25JbkRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiByZXN1bHQuYWRkcmVzcy50b1N0cmluZygpLFxuICAgICAgc2lnbmF0dXJlOiByZXN1bHQuc2lnbmF0dXJlLFxuICAgICAgc2lnbmVkTWVzc2FnZTogcmVzdWx0LnNpZ25lZE1lc3NhZ2VcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGlzIG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiByZXN1bHQuc2lnbmF0dXJlLFxuICAgICAgYWRkcmVzczogcmVzdWx0LnB1YmxpY0tleVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBpcyBub3QgY29ubmVjdGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFwcm92aWRlci5zaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwcm92aWRlci5zaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmVzOiByZXN1bHRzLnNpZ25hdHVyZXMsXG4gICAgICBhZGRyZXNzOiByZXN1bHRzLnB1YmxpY0tleVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBpcyBub3QgY29ubmVjdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFByb3ZpZGVyLCBnZXRQcm92aWRlcl9mbikuY2FsbCh0aGlzKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBpcyBub3QgY29ubmVjdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5fZ2V0UHJvdmlkZXIgPSBuZXcgV2Vha1NldCgpO1xuZ2V0UHJvdmlkZXJfZm4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB3aW5kb3c/LnBoYW50b20/LnNvbGFuYTtcbn07XG5cbi8vIHNyYy9zb2xhbmEvZ2V0UHJvdmlkZXIudHNcbmFzeW5jIGZ1bmN0aW9uIGdldFByb3ZpZGVyKHN0cmF0ZWd5ID0gXCJpbmplY3RlZFwiIC8qIElOSkVDVEVEICovKSB7XG4gIGlmIChzdHJhdGVneSA9PT0gXCJpbmplY3RlZFwiKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5qZWN0ZWRTb2xhbmFTdHJhdGVneSgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwcm92aWRlci5sb2FkKCk7XG4gICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvdmlkZXIgdHlwZS5cIik7XG4gIH1cbn1cblxuLy8gc3JjL3NvbGFuYS9ldmVudExpc3RlbmVycy50c1xudmFyIGV2ZW50Q2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGlmICghZXZlbnRDYWxsYmFja3MuaGFzKGV2ZW50KSkge1xuICAgIGV2ZW50Q2FsbGJhY2tzLnNldChldmVudCwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgZXZlbnRDYWxsYmFja3MuZ2V0KGV2ZW50KT8uYWRkKGNhbGxiYWNrKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjayk7XG4gIH07XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAoZXZlbnRDYWxsYmFja3MuaGFzKGV2ZW50KSkge1xuICAgIGV2ZW50Q2FsbGJhY2tzLmdldChldmVudCk/LmRlbGV0ZShjYWxsYmFjayk7XG4gICAgaWYgKGV2ZW50Q2FsbGJhY2tzLmdldChldmVudCk/LnNpemUgPT09IDApIHtcbiAgICAgIGV2ZW50Q2FsbGJhY2tzLmRlbGV0ZShldmVudCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGV2ZW50Q2FsbGJhY2tzLmhhcyhldmVudCkpIHtcbiAgICBldmVudENhbGxiYWNrcy5nZXQoZXZlbnQpPy5mb3JFYWNoKChjYikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoLi4uYXJncyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiAke2V2ZW50fSBldmVudCBsaXN0ZW5lcjpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3NvbGFuYS9jb25uZWN0LnRzXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0KHsgb25seUlmVHJ1c3RlZCA9IGZhbHNlIH0gPSB7fSkge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIGlmIChwcm92aWRlci5pc0Nvbm5lY3RlZCkge1xuICAgIHJldHVybiBwcm92aWRlci5nZXRBY2NvdW50KCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IHRydWUgfSk7XG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgIHRyaWdnZXJFdmVudChcImNvbm5lY3RcIiwgYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gIH1cbiAgaWYgKG9ubHlJZlRydXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0cnVzdGVkIGNvbm5lY3Rpb24gYXZhaWxhYmxlLlwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBwcm92aWRlci5jb25uZWN0KHsgb25seUlmVHJ1c3RlZDogZmFsc2UgfSk7XG4gICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgIHRyaWdnZXJFdmVudChcImNvbm5lY3RcIiwgYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gUGhhbnRvbS5cIik7XG59XG5cbi8vIHNyYy9zb2xhbmEvZGlzY29ubmVjdC50c1xuYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBhd2FpdCBwcm92aWRlci5kaXNjb25uZWN0KCk7XG4gIHRyaWdnZXJFdmVudChcImRpc2Nvbm5lY3RcIik7XG59XG5cbi8vIHNyYy9zb2xhbmEvZ2V0QWNjb3VudC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudCgpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICByZXR1cm4gcHJvdmlkZXIuZ2V0QWNjb3VudCgpO1xufVxuXG4vLyBzcmMvc29sYW5hL3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbn1cblxuLy8gc3JjL3NvbGFuYS9zaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucy50c1xuYXN5bmMgZnVuY3Rpb24gc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgaWYgKCFwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBmb3VuZC5cIik7XG4gIH1cbiAgaWYgKCFwcm92aWRlci5pc0Nvbm5lY3RlZCkge1xuICAgIGF3YWl0IHByb3ZpZGVyLmNvbm5lY3QoeyBvbmx5SWZUcnVzdGVkOiBmYWxzZSB9KTtcbiAgfVxuICByZXR1cm4gcHJvdmlkZXIuc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbn1cblxuLy8gc3JjL3NvbGFuYS9zaWduVHJhbnNhY3Rpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgZm91bmQuXCIpO1xuICB9XG4gIGlmICghcHJvdmlkZXIuaXNDb25uZWN0ZWQpIHtcbiAgICBhd2FpdCBwcm92aWRlci5jb25uZWN0KHsgb25seUlmVHJ1c3RlZDogZmFsc2UgfSk7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG59XG5cbi8vIHNyYy9zb2xhbmEvc2lnbkFsbFRyYW5zYWN0aW9ucy50c1xuYXN5bmMgZnVuY3Rpb24gc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG59XG5cbi8vIHNyYy9zb2xhbmEvc2lnbk1lc3NhZ2UudHNcbmFzeW5jIGZ1bmN0aW9uIHNpZ25NZXNzYWdlKG1lc3NhZ2UsIGRpc3BsYXkpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IGZvdW5kLlwiKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyLmlzQ29ubmVjdGVkKSB7XG4gICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCh7IG9ubHlJZlRydXN0ZWQ6IGZhbHNlIH0pO1xuICB9XG4gIHJldHVybiBwcm92aWRlci5zaWduTWVzc2FnZShtZXNzYWdlLCBkaXNwbGF5KTtcbn1cblxuLy8gc3JjL3NvbGFuYS9wbHVnaW4udHNcbnZhciBTb2xhbmEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgdGhpcy5iaW5kUHJvdmlkZXJFdmVudHMoKTtcbiAgfVxuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5ICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGNvbm5lY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb25uZWN0KG9wdGlvbnMpO1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gU29sYW5hIHdhbGxldFwiKTtcbiAgICB9XG4gICAgdGhpcy5fcHVibGljS2V5ID0gYWRkcmVzcztcbiAgICByZXR1cm4geyBwdWJsaWNLZXk6IGFkZHJlc3MgfTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGF3YWl0IGRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlQnl0ZXMgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShtZXNzYWdlKSA6IG1lc3NhZ2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbk1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiByZXN1bHQuc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHJlc3VsdC5zaWduYXR1cmUgOiBuZXcgVWludDhBcnJheShyZXN1bHQuc2lnbmF0dXJlKSxcbiAgICAgIHB1YmxpY0tleTogcmVzdWx0LmFkZHJlc3MgfHwgdGhpcy5fcHVibGljS2V5IHx8IFwiXCJcbiAgICB9O1xuICB9XG4gIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICB9XG4gIGFzeW5jIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4geyBzaWduYXR1cmU6IHJlc3VsdC5zaWduYXR1cmUgfTtcbiAgfVxuICBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgIHJldHVybiBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4geyBzaWduYXR1cmVzOiByZXN1bHQuc2lnbmF0dXJlcyB9O1xuICB9XG4gIGFzeW5jIHN3aXRjaE5ldHdvcmsoX25ldHdvcmspIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgYXN5bmMgZ2V0UHVibGljS2V5KCkge1xuICAgIGlmICh0aGlzLl9wdWJsaWNLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgZ2V0QWNjb3VudCgpO1xuICAgICAgdGhpcy5fcHVibGljS2V5ID0gYWNjb3VudCB8fCBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5ICE9PSBudWxsO1xuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIGFzeW5jIGJpbmRQcm92aWRlckV2ZW50cygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBzdHJhdGVneS5nZXRQcm92aWRlcigpO1xuICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgIHByb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCAocHVibGljS2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHB1YmxpY0tleSkge1xuICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBwdWJLZXk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJjb25uZWN0XCIsIHB1YktleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudChcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm92aWRlci5vbihcImFjY291bnRDaGFuZ2VkXCIsIChwdWJsaWNLZXkpID0+IHtcbiAgICAgICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHB1YktleTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcImFjY291bnRDaGFuZ2VkXCIsIHB1YktleSk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJjb25uZWN0XCIsIHB1YktleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJhY2NvdW50Q2hhbmdlZFwiLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU29sYW5hUGx1Z2luKCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic29sYW5hXCIsXG4gICAgY3JlYXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFNvbGFuYSgpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZVNvbGFuYVBsdWdpblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/solana/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/browser-sdk/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@phantom/browser-sdk/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressType: () => (/* reexport safe */ _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType),\n/* harmony export */   BrowserSDK: () => (/* binding */ BrowserSDK),\n/* harmony export */   DebugCategory: () => (/* binding */ DebugCategory),\n/* harmony export */   DebugLevel: () => (/* binding */ DebugLevel),\n/* harmony export */   NetworkId: () => (/* reexport safe */ _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.NetworkId),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   detectBrowser: () => (/* binding */ detectBrowser),\n/* harmony export */   getBrowserDisplayName: () => (/* binding */ getBrowserDisplayName),\n/* harmony export */   getDeeplinkToPhantom: () => (/* binding */ getDeeplinkToPhantom),\n/* harmony export */   getPlatformName: () => (/* binding */ getPlatformName),\n/* harmony export */   isMobileDevice: () => (/* binding */ isMobileDevice),\n/* harmony export */   isPhantomLoginAvailable: () => (/* binding */ isPhantomLoginAvailable),\n/* harmony export */   parseBrowserFromUserAgent: () => (/* binding */ parseBrowserFromUserAgent),\n/* harmony export */   waitForPhantomExtension: () => (/* binding */ waitForPhantomExtension)\n/* harmony export */ });\n/* harmony import */ var _phantom_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @phantom/client */ \"(ssr)/./node_modules/@phantom/client/dist/index.mjs\");\n/* harmony import */ var _phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @phantom/browser-injected-sdk */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/index.mjs\");\n/* harmony import */ var _phantom_browser_injected_sdk_solana__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/browser-injected-sdk/solana */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/solana/index.mjs\");\n/* harmony import */ var _phantom_browser_injected_sdk_ethereum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @phantom/browser-injected-sdk/ethereum */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/ethereum/index.mjs\");\n/* harmony import */ var _phantom_browser_injected_sdk_auto_confirm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @phantom/browser-injected-sdk/auto-confirm */ \"(ssr)/./node_modules/@phantom/browser-injected-sdk/dist/auto-confirm/index.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var _phantom_parsers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @phantom/parsers */ \"(ssr)/./node_modules/@phantom/parsers/dist/index.mjs\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/src/esm/index.js\");\n/* harmony import */ var _phantom_embedded_provider_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @phantom/embedded-provider-core */ \"(ssr)/./node_modules/@phantom/embedded-provider-core/dist/index.mjs\");\n/* harmony import */ var _phantom_indexed_db_stamper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @phantom/indexed-db-stamper */ \"(ssr)/./node_modules/@phantom/indexed-db-stamper/dist/index.mjs\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n// src/types.ts\n\n\n// src/providers/injected/index.ts\n\n\n// src/debug.ts\nvar DebugLevel = /* @__PURE__ */ ((DebugLevel2) => {\n  DebugLevel2[DebugLevel2[\"ERROR\"] = 0] = \"ERROR\";\n  DebugLevel2[DebugLevel2[\"WARN\"] = 1] = \"WARN\";\n  DebugLevel2[DebugLevel2[\"INFO\"] = 2] = \"INFO\";\n  DebugLevel2[DebugLevel2[\"DEBUG\"] = 3] = \"DEBUG\";\n  return DebugLevel2;\n})(DebugLevel || {});\nvar Debug = class {\n  constructor() {\n    this.level = 0 /* ERROR */;\n    this.enabled = false;\n  }\n  static getInstance() {\n    if (!Debug.instance) {\n      Debug.instance = new Debug();\n    }\n    return Debug.instance;\n  }\n  setCallback(callback) {\n    this.callback = callback;\n  }\n  setLevel(level) {\n    this.level = level;\n  }\n  enable() {\n    this.enabled = true;\n  }\n  disable() {\n    this.enabled = false;\n  }\n  writeLog(level, category, message, data) {\n    if (!this.enabled || level > this.level) {\n      return;\n    }\n    const debugMessage = {\n      timestamp: Date.now(),\n      level,\n      category,\n      message,\n      data\n    };\n    if (this.callback) {\n      this.callback(debugMessage);\n    }\n  }\n  error(category, message, data) {\n    this.writeLog(0 /* ERROR */, category, message, data);\n  }\n  warn(category, message, data) {\n    this.writeLog(1 /* WARN */, category, message, data);\n  }\n  info(category, message, data) {\n    this.writeLog(2 /* INFO */, category, message, data);\n  }\n  debug(category, message, data) {\n    this.writeLog(3 /* DEBUG */, category, message, data);\n  }\n  log(category, message, data) {\n    this.writeLog(3 /* DEBUG */, category, message, data);\n  }\n};\nvar debug = Debug.getInstance();\nvar DebugCategory = {\n  BROWSER_SDK: \"BrowserSDK\",\n  PROVIDER_MANAGER: \"ProviderManager\",\n  EMBEDDED_PROVIDER: \"EmbeddedProvider\",\n  INJECTED_PROVIDER: \"InjectedProvider\",\n  PHANTOM_CONNECT_AUTH: \"PhantomConnectAuth\",\n  JWT_AUTH: \"JWTAuth\",\n  STORAGE: \"Storage\",\n  SESSION: \"Session\"\n};\n\n// src/wallets/discovery.ts\n\n\n\n\n\n\nfunction generateWalletIdFromEIP6963(info) {\n  if (info.rdns) {\n    return info.rdns.split(\".\").reverse().join(\"-\");\n  }\n  return info.name.toLowerCase().replace(/\\s+/g, \"-\");\n}\nfunction generateWalletIdFromName(name) {\n  return name.toLowerCase().replace(/\\s+/g, \"-\");\n}\nfunction processEIP6963Providers(providers) {\n  const wallets = [];\n  debug.log(DebugCategory.BROWSER_SDK, \"Processing EIP-6963 providers\", {\n    providerCount: providers.size,\n    providerNames: Array.from(providers.values()).map((d) => d.info.name)\n  });\n  for (const [, detail] of providers) {\n    const { info, provider } = detail;\n    const isPhantom = info.name.toLowerCase().includes(\"phantom\") || info.rdns && (info.rdns.toLowerCase().includes(\"phantom\") || info.rdns.toLowerCase() === \"app.phantom\");\n    if (isPhantom) {\n      debug.log(DebugCategory.BROWSER_SDK, \"Skipping Phantom from EIP-6963\", { name: info.name, rdns: info.rdns });\n      continue;\n    }\n    const walletId = generateWalletIdFromEIP6963(info);\n    debug.log(DebugCategory.BROWSER_SDK, \"Discovered EIP-6963 wallet\", {\n      walletId,\n      walletName: info.name,\n      rdns: info.rdns\n    });\n    wallets.push({\n      id: walletId,\n      name: info.name,\n      icon: info.icon,\n      addressTypes: [_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum],\n      providers: {\n        // EIP-6963 provider implements EIP-1193 interface (IEthereumChain)\n        ethereum: provider\n      },\n      rdns: info.rdns,\n      // Store rdns for potential future matching\n      discovery: \"eip6963\"\n    });\n  }\n  debug.log(DebugCategory.BROWSER_SDK, \"EIP-6963 discovery completed\", {\n    discoveredCount: wallets.length,\n    walletIds: wallets.map((w) => w.id)\n  });\n  return wallets;\n}\nfunction discoverEthereumWallets() {\n  return new Promise((resolve) => {\n    const discoveredProviders = /* @__PURE__ */ new Map();\n    if (typeof window === \"undefined\") {\n      resolve([]);\n      return;\n    }\n    const handleAnnounce = (event) => {\n      const detail = event.detail;\n      if (detail?.info && detail?.provider) {\n        discoveredProviders.set(detail.info.uuid, detail);\n      }\n    };\n    window.addEventListener(\"eip6963:announceProvider\", handleAnnounce);\n    window.dispatchEvent(new Event(\"eip6963:requestProvider\"));\n    const processProviders = () => {\n      const wallets = processEIP6963Providers(discoveredProviders);\n      window.removeEventListener(\"eip6963:announceProvider\", handleAnnounce);\n      resolve(wallets);\n    };\n    setTimeout(processProviders, 400);\n  });\n}\nasync function discoverSolanaWallets() {\n  const wallets = [];\n  if (typeof window === \"undefined\" || typeof navigator === \"undefined\") {\n    debug.log(DebugCategory.BROWSER_SDK, \"Wallet Standard discovery skipped (not in browser environment)\");\n    return wallets;\n  }\n  const registeredWalletsSet = /* @__PURE__ */ new Set();\n  let cachedWalletsArray;\n  function addRegisteredWallet(wallet) {\n    cachedWalletsArray = void 0;\n    registeredWalletsSet.add(wallet);\n    const featureKeys = wallet.features ? Object.keys(wallet.features) : [];\n    debug.log(DebugCategory.BROWSER_SDK, \"Wallet registered\", {\n      name: wallet.name,\n      chains: wallet.chains,\n      featureKeys,\n      totalWallets: registeredWalletsSet.size\n    });\n  }\n  function removeRegisteredWallet(wallet) {\n    cachedWalletsArray = void 0;\n    registeredWalletsSet.delete(wallet);\n  }\n  function getRegisteredWallets() {\n    if (!cachedWalletsArray) {\n      cachedWalletsArray = [...registeredWalletsSet];\n    }\n    return cachedWalletsArray;\n  }\n  function register(...wallets2) {\n    wallets2 = wallets2.filter((wallet) => !registeredWalletsSet.has(wallet));\n    if (!wallets2.length) {\n      return () => {\n      };\n    }\n    wallets2.forEach((wallet) => addRegisteredWallet(wallet));\n    return function unregister() {\n      wallets2.forEach((wallet) => removeRegisteredWallet(wallet));\n    };\n  }\n  const registerAPI = Object.freeze({ register });\n  const handleRegisterWalletEvent = (event) => {\n    const callback = event.detail;\n    if (typeof callback === \"function\") {\n      try {\n        callback(registerAPI);\n      } catch (error) {\n        debug.warn(DebugCategory.BROWSER_SDK, \"Error calling wallet registration callback\", { error });\n      }\n    }\n  };\n  try {\n    window.addEventListener(\"wallet-standard:register-wallet\", handleRegisterWalletEvent);\n  } catch (error) {\n    debug.warn(DebugCategory.BROWSER_SDK, \"Could not add register-wallet event listener\", { error });\n  }\n  class AppReadyEvent extends Event {\n    constructor(api) {\n      super(\"wallet-standard:app-ready\", {\n        bubbles: false,\n        cancelable: false,\n        composed: false\n      });\n      this.detail = api;\n    }\n  }\n  try {\n    window.dispatchEvent(new AppReadyEvent(registerAPI));\n    debug.log(DebugCategory.BROWSER_SDK, \"Dispatched wallet-standard:app-ready event\");\n  } catch (error) {\n    debug.warn(DebugCategory.BROWSER_SDK, \"Could not dispatch app-ready event\", { error });\n  }\n  const walletsAPI = {\n    getWallets: () => {\n      return {\n        get: getRegisteredWallets,\n        on: (_event, _listener) => {\n          return () => {\n          };\n        },\n        register\n      };\n    }\n  };\n  if (!navigator.wallets) {\n    navigator.wallets = walletsAPI;\n  }\n  debug.log(DebugCategory.BROWSER_SDK, \"Initialized Wallet Standard registry\");\n  await new Promise((resolve) => setTimeout(resolve, 100));\n  const existingWalletsAPI = navigator.wallets || window.wallets;\n  if (!existingWalletsAPI || typeof existingWalletsAPI.getWallets !== \"function\") {\n    const logData = {\n      hasNavigator: !!navigator,\n      hasWindow: typeof window !== \"undefined\",\n      note: \"Wallet Standard API not properly initialized\"\n    };\n    debug.log(DebugCategory.BROWSER_SDK, \"Wallet Standard API not available\", logData);\n    return wallets;\n  }\n  const walletsGetter = existingWalletsAPI.getWallets();\n  const getWalletsFn = () => Promise.resolve([...walletsGetter.get()]);\n  debug.log(DebugCategory.BROWSER_SDK, \"Wallet Standard API detected, starting discovery\");\n  try {\n    let registeredWallets = [];\n    let attempts = 0;\n    const maxAttempts = 5;\n    const initialDelay = 100;\n    const eip6963Timeout = 400;\n    await new Promise((resolve) => setTimeout(resolve, initialDelay));\n    while (attempts < maxAttempts) {\n      registeredWallets = await getWalletsFn();\n      const logData = {\n        attempt: attempts + 1,\n        walletCount: registeredWallets.length,\n        walletNames: registeredWallets.map((w) => w.name),\n        chains: registeredWallets.flatMap((w) => w.chains)\n      };\n      debug.log(DebugCategory.BROWSER_SDK, `Wallet Standard getWallets attempt ${attempts + 1}`, logData);\n      if (registeredWallets.length > 0 || attempts === maxAttempts - 1) {\n        break;\n      }\n      await new Promise((resolve) => setTimeout(resolve, initialDelay));\n      attempts++;\n    }\n    const totalWaitTime = initialDelay + attempts * initialDelay;\n    if (totalWaitTime < eip6963Timeout) {\n      const remainingWait = eip6963Timeout - totalWaitTime;\n      await new Promise((resolve) => setTimeout(resolve, remainingWait));\n      registeredWallets = await getWalletsFn();\n    }\n    debug.log(DebugCategory.BROWSER_SDK, \"Wallet Standard getWallets final result\", {\n      walletCount: registeredWallets.length,\n      walletNames: registeredWallets.map((w) => w.name),\n      attempts: attempts + 1\n    });\n    for (const wallet of registeredWallets) {\n      const supportsSolana = wallet.chains.some((chain) => {\n        const chainLower = chain.toLowerCase();\n        return chainLower.startsWith(\"solana:\") || chainLower === \"solana\";\n      }) || wallet.features && typeof wallet.features === \"object\" && Object.keys(wallet.features).some((featureKey) => {\n        const featureLower = featureKey.toLowerCase();\n        return featureLower.startsWith(\"solana:\");\n      });\n      if (!supportsSolana) {\n        const featureKeys = wallet.features ? Object.keys(wallet.features) : [];\n        debug.log(DebugCategory.BROWSER_SDK, \"Wallet does not support Solana\", {\n          walletName: wallet.name,\n          chains: wallet.chains,\n          featureKeys\n        });\n        continue;\n      }\n      if (wallet.name.toLowerCase().includes(\"phantom\")) {\n        debug.log(DebugCategory.BROWSER_SDK, \"Skipping Phantom from Wallet Standard (handled separately)\");\n        continue;\n      }\n      const walletId = generateWalletIdFromName(wallet.name);\n      const safeFeatures = wallet.features ? Object.keys(wallet.features) : [];\n      debug.log(DebugCategory.BROWSER_SDK, \"Discovered Wallet Standard Solana wallet\", {\n        walletId,\n        walletName: wallet.name,\n        chains: wallet.chains,\n        featureKeys: safeFeatures,\n        icon: wallet.icon,\n        version: wallet.version,\n        accountCount: wallet.accounts?.length || 0\n      });\n      wallets.push({\n        id: walletId,\n        name: wallet.name,\n        icon: wallet.icon,\n        addressTypes: [_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana],\n        providers: {\n          // Cast to ISolanaChain - Wallet Standard wallets have compatible methods\n          // The InjectedWalletSolanaChain wrapper will handle the actual method calls\n          solana: wallet\n        },\n        discovery: \"standard\"\n      });\n    }\n  } catch (error) {\n    debug.warn(DebugCategory.BROWSER_SDK, \"Wallet Standard API error\", {\n      error: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : void 0\n    });\n  }\n  const finalLogData = {\n    discoveredCount: wallets.length,\n    walletIds: wallets.map((w) => w.id),\n    walletNames: wallets.map((w) => w.name)\n  };\n  debug.log(DebugCategory.BROWSER_SDK, \"Wallet Standard Solana discovery completed\", finalLogData);\n  return wallets;\n}\nfunction discoverPhantomWallet(addressTypes) {\n  if (typeof window === \"undefined\") {\n    return null;\n  }\n  if (!(0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.isPhantomExtensionInstalled)()) {\n    return null;\n  }\n  const plugins = [(0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.createExtensionPlugin)()];\n  if (addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana)) {\n    plugins.push((0,_phantom_browser_injected_sdk_solana__WEBPACK_IMPORTED_MODULE_2__.createSolanaPlugin)());\n  }\n  if (addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum)) {\n    plugins.push((0,_phantom_browser_injected_sdk_ethereum__WEBPACK_IMPORTED_MODULE_3__.createEthereumPlugin)());\n  }\n  plugins.push((0,_phantom_browser_injected_sdk_auto_confirm__WEBPACK_IMPORTED_MODULE_4__.createAutoConfirmPlugin)());\n  const phantomInstance = (0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.createPhantom)({ plugins });\n  return {\n    id: \"phantom\",\n    name: \"Phantom\",\n    icon: void 0,\n    // Icon will be rendered from icons package in UI components\n    addressTypes,\n    providers: {\n      solana: addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana) ? phantomInstance.solana : void 0,\n      ethereum: addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum) ? phantomInstance.ethereum : void 0\n    },\n    isPhantom: true,\n    phantomInstance,\n    discovery: \"phantom\"\n  };\n}\nasync function discoverWallets(addressTypes) {\n  const requestedAddressTypes = addressTypes || [];\n  debug.log(DebugCategory.BROWSER_SDK, \"Starting all wallet discovery methods\", {\n    addressTypes: requestedAddressTypes\n  });\n  const [solanaWallets, ethereumWallets] = await Promise.all([discoverSolanaWallets(), discoverEthereumWallets()]);\n  const phantomWallet = discoverPhantomWallet(requestedAddressTypes);\n  debug.log(DebugCategory.BROWSER_SDK, \"All wallet discovery methods completed\", {\n    phantomFound: !!phantomWallet,\n    solanaWalletsCount: solanaWallets.length,\n    ethereumWalletsCount: ethereumWallets.length,\n    solanaWalletIds: solanaWallets.map((w) => w.id),\n    ethereumWalletIds: ethereumWallets.map((w) => w.id)\n  });\n  const walletMap = /* @__PURE__ */ new Map();\n  if (phantomWallet) {\n    walletMap.set(\"phantom\", phantomWallet);\n  }\n  for (const wallet of [...solanaWallets, ...ethereumWallets]) {\n    const existing = walletMap.get(wallet.id);\n    if (existing) {\n      const mergedAddressTypes = Array.from(/* @__PURE__ */ new Set([...existing.addressTypes, ...wallet.addressTypes]));\n      const mergedProviders = {\n        ...existing.providers,\n        ...wallet.providers\n      };\n      const mergedWallet = {\n        ...existing,\n        addressTypes: mergedAddressTypes,\n        // Prefer icon from the most recent discovery\n        icon: wallet.icon || existing.icon,\n        providers: mergedProviders\n      };\n      walletMap.set(wallet.id, mergedWallet);\n      debug.log(DebugCategory.BROWSER_SDK, \"Merged wallet by ID\", {\n        walletName: wallet.name,\n        walletId: wallet.id,\n        existingAddressTypes: existing.addressTypes,\n        newAddressTypes: wallet.addressTypes,\n        mergedAddressTypes,\n        existingProviders: Object.keys(existing.providers || {}),\n        newProviders: Object.keys(wallet.providers || {}),\n        mergedProviders: Object.keys(mergedProviders)\n      });\n      debug.log(DebugCategory.BROWSER_SDK, \"Merged wallet from multiple discovery methods\", {\n        walletId: wallet.id,\n        walletName: wallet.name,\n        existingAddressTypes: existing.addressTypes,\n        newAddressTypes: wallet.addressTypes,\n        mergedAddressTypes\n      });\n    } else {\n      walletMap.set(wallet.id, wallet);\n    }\n  }\n  return Array.from(walletMap.values());\n}\n\n// src/providers/injected/chains/InjectedWalletSolanaChain.ts\n\n\nvar InjectedWalletSolanaChain = class {\n  constructor(provider, walletId, walletName) {\n    // Expose eventEmitter for testing - allows tests to trigger events directly\n    this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();\n    this._connected = false;\n    this._publicKey = null;\n    this.provider = provider;\n    this.walletId = walletId;\n    this.walletName = walletName;\n    this.setupEventListeners();\n  }\n  get connected() {\n    return this._connected;\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  async connect(options) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana connect\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      onlyIfTrusted: options?.onlyIfTrusted\n    });\n    try {\n      const result = await this.provider.connect(options);\n      if (typeof result === \"string\") {\n        this._connected = true;\n        this._publicKey = result;\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana connected\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          publicKey: result\n        });\n        return { publicKey: result };\n      }\n      if (typeof result === \"object\" && result !== null && \"publicKey\" in result) {\n        this._connected = true;\n        this._publicKey = result.publicKey;\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana connected\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          publicKey: result.publicKey\n        });\n        return result;\n      }\n      if (Array.isArray(result) && result.length > 0) {\n        const firstAccount = result[0];\n        if (typeof firstAccount === \"object\" && firstAccount !== null && \"address\" in firstAccount) {\n          this._connected = true;\n          this._publicKey = firstAccount.address;\n          debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana connected\", {\n            walletId: this.walletId,\n            walletName: this.walletName,\n            publicKey: firstAccount.address\n          });\n          return { publicKey: firstAccount.address };\n        }\n      }\n      throw new Error(\"Unexpected connect result format\");\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana connect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async disconnect() {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana disconnect\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    try {\n      await this.provider.disconnect();\n      this._connected = false;\n      this._publicKey = null;\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana disconnected\", {\n        walletId: this.walletId,\n        walletName: this.walletName\n      });\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana disconnect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signMessage(message) {\n    const messageBytes = typeof message === \"string\" ? new TextEncoder().encode(message) : message;\n    const messagePreview = typeof message === \"string\" ? message.substring(0, 50) : `${messageBytes.length} bytes`;\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signMessage\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      messagePreview,\n      messageLength: messageBytes.length\n    });\n    try {\n      const result = await this.provider.signMessage(message);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signMessage success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signatureLength: result.signature.length\n      });\n      return {\n        signature: result.signature instanceof Uint8Array ? result.signature : new Uint8Array(buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from(result.signature, \"base64\")),\n        publicKey: result.publicKey || this._publicKey || \"\"\n      };\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signMessage failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signTransaction\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    try {\n      const result = await this.provider.signTransaction(transaction);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signTransaction success\", {\n        walletId: this.walletId,\n        walletName: this.walletName\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAndSendTransaction(transaction) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendTransaction\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    try {\n      const result = await this.provider.signAndSendTransaction(transaction);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendTransaction success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signature: result.signature\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAllTransactions\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      transactionCount: transactions.length\n    });\n    try {\n      const result = await this.provider.signAllTransactions(transactions);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAllTransactions success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signedCount: result.length\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAllTransactions failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAndSendAllTransactions(transactions) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendAllTransactions\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      transactionCount: transactions.length\n    });\n    try {\n      const result = await this.provider.signAndSendAllTransactions(transactions);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendAllTransactions success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signatureCount: result.signatures.length\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Solana signAndSendAllTransactions failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  switchNetwork(_network) {\n    return Promise.resolve();\n  }\n  getPublicKey() {\n    return Promise.resolve(this._publicKey);\n  }\n  isConnected() {\n    return this._connected;\n  }\n  setupEventListeners() {\n    if (typeof this.provider.on === \"function\") {\n      this.provider.on(\"connect\", (publicKey) => {\n        this._connected = true;\n        this._publicKey = publicKey;\n        this.eventEmitter.emit(\"connect\", publicKey);\n      });\n      this.provider.on(\"disconnect\", () => {\n        this._connected = false;\n        this._publicKey = null;\n        this.eventEmitter.emit(\"disconnect\");\n      });\n      this.provider.on(\"accountChanged\", (publicKey) => {\n        this._publicKey = publicKey;\n        this._connected = publicKey != null && publicKey.length > 0;\n        this.eventEmitter.emit(\"accountChanged\", publicKey);\n      });\n    }\n  }\n  on(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n  }\n};\n\n// src/providers/injected/chains/WalletStandardSolanaAdapter.ts\n\n\n\n\nvar WalletStandardSolanaAdapter = class {\n  constructor(wallet, walletId, walletName) {\n    this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();\n    this._publicKey = null;\n    this.wallet = wallet;\n    this.walletId = walletId;\n    this.walletName = walletName;\n    this.setupEventListeners();\n  }\n  get connected() {\n    return this._publicKey !== null;\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  async connect(_options) {\n    try {\n      const connectFeature = this.wallet.features[\"standard:connect\"];\n      if (!connectFeature) {\n        throw new Error(\"Wallet Standard connect feature not available\");\n      }\n      const connectResult = await connectFeature.connect();\n      let accounts;\n      if (Array.isArray(connectResult) && connectResult.length > 0) {\n        accounts = connectResult;\n      } else if (this.wallet.accounts && this.wallet.accounts.length > 0) {\n        accounts = Array.from(this.wallet.accounts);\n      }\n      if (!accounts || accounts.length === 0) {\n        throw new Error(\"No accounts available after connecting to wallet\");\n      }\n      const firstAccount = accounts[0];\n      if (!firstAccount) {\n        throw new Error(\"First account is null or undefined\");\n      }\n      let address;\n      if (typeof firstAccount === \"string\") {\n        address = firstAccount;\n      } else if (typeof firstAccount === \"object\" && firstAccount !== null) {\n        address = firstAccount.address || firstAccount.publicKey?.toString() || (firstAccount.publicKey instanceof Uint8Array ? buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from(firstAccount.publicKey).toString(\"hex\") : void 0);\n      }\n      if (!address) {\n        throw new Error(\n          `Could not extract address from account. Account structure: ${JSON.stringify(firstAccount, null, 2)}`\n        );\n      }\n      this._publicKey = address;\n      return { publicKey: address };\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana connect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async disconnect() {\n    try {\n      const disconnectFeature = this.wallet.features[\"standard:disconnect\"];\n      if (disconnectFeature) {\n        await disconnectFeature.disconnect();\n      }\n      this._publicKey = null;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana disconnect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signMessage(message) {\n    try {\n      const signMessageFeature = this.wallet.features[\"solana:signMessage\"];\n      if (!signMessageFeature) {\n        throw new Error(\"Wallet Standard signMessage feature not available\");\n      }\n      const messageBytes = typeof message === \"string\" ? new TextEncoder().encode(message) : message;\n      const result = await signMessageFeature.signMessage({\n        message: messageBytes,\n        account: this.wallet.accounts[0]\n      });\n      if (!Array.isArray(result) || result.length === 0) {\n        throw new Error(`Expected array result from signMessage, got: ${typeof result}`);\n      }\n      const signedMessageResult = result[0];\n      if (!signedMessageResult || !signedMessageResult.signature) {\n        throw new Error(`Invalid signMessage result structure: ${JSON.stringify(result)}`);\n      }\n      const signature = this.parseUint8Array(signedMessageResult.signature);\n      if (signature.length === 0) {\n        throw new Error(`Signature is empty`);\n      }\n      const publicKey = signedMessageResult.account?.address || this.wallet.accounts[0]?.address || this._publicKey || \"\";\n      return { signature, publicKey };\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana signMessage failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    try {\n      const signTransactionFeature = this.wallet.features[\"solana:signTransaction\"];\n      if (!signTransactionFeature) {\n        throw new Error(\"Wallet Standard signTransaction feature not available\");\n      }\n      if (!this.wallet.accounts || this.wallet.accounts.length === 0) {\n        throw new Error(\"No accounts available. Please connect first.\");\n      }\n      const account = this.wallet.accounts[0];\n      const serializedTransaction = this.serializeTransaction(transaction);\n      const results = await signTransactionFeature.signTransaction({\n        transaction: serializedTransaction,\n        account\n      });\n      let transactionData;\n      if (Array.isArray(results) && results.length > 0) {\n        const firstItem = results[0];\n        if (firstItem && typeof firstItem === \"object\") {\n          transactionData = firstItem.signedTransaction || firstItem.transaction;\n        }\n      } else if (results && typeof results === \"object\" && !Array.isArray(results)) {\n        const resultObj = results;\n        transactionData = resultObj.transaction || resultObj.signedTransaction;\n      }\n      if (!transactionData) {\n        throw new Error(\"No transaction data found in Wallet Standard result\");\n      }\n      const signedBytes = this.parseUint8Array(transactionData);\n      if (signedBytes.length === 0) {\n        throw new Error(\"Empty signed transaction returned from Wallet Standard\");\n      }\n      const signedTx = (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_7__.deserializeSolanaTransaction)(signedBytes);\n      return signedTx;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana signTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAndSendTransaction(transaction) {\n    try {\n      const signAndSendTransactionFeature = this.wallet.features[\"solana:signAndSendTransaction\"];\n      if (!signAndSendTransactionFeature) {\n        throw new Error(\"Wallet Standard signAndSendTransaction feature not available\");\n      }\n      if (!this.wallet.accounts || this.wallet.accounts.length === 0) {\n        throw new Error(\"No accounts available. Please connect first.\");\n      }\n      const account = this.wallet.accounts[0];\n      const chain = account.chains?.[0] || \"solana:mainnet\";\n      const serializedTransaction = this.serializeTransaction(transaction);\n      const results = await signAndSendTransactionFeature.signAndSendTransaction({\n        transaction: serializedTransaction,\n        account,\n        chain\n      });\n      let signatureOutput;\n      if (Array.isArray(results) && results.length > 0) {\n        signatureOutput = results[0];\n      } else if (results && typeof results === \"object\" && !Array.isArray(results)) {\n        signatureOutput = results;\n      } else {\n        throw new Error(\"Invalid signAndSendTransaction result format\");\n      }\n      if (!signatureOutput.signature) {\n        throw new Error(\"No signature found in signAndSendTransaction result\");\n      }\n      const signatureBytes = this.parseUint8Array(signatureOutput.signature);\n      const signature = bs58__WEBPACK_IMPORTED_MODULE_8__[\"default\"].encode(signatureBytes);\n      return { signature };\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana signAndSendTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    try {\n      const signedTransactions = [];\n      for (const transaction of transactions) {\n        const signedTx = await this.signTransaction(transaction);\n        signedTransactions.push(signedTx);\n      }\n      return signedTransactions;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana signAllTransactions failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signAndSendAllTransactions(transactions) {\n    try {\n      const signatures = [];\n      for (const transaction of transactions) {\n        const result = await this.signAndSendTransaction(transaction);\n        signatures.push(result.signature);\n      }\n      return { signatures };\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard Solana signAndSendAllTransactions failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async switchNetwork(_network) {\n    return Promise.resolve();\n  }\n  getPublicKey() {\n    return Promise.resolve(this._publicKey);\n  }\n  isConnected() {\n    return this._publicKey !== null;\n  }\n  /**\n   * Set up event listeners for Wallet Standard events\n   * Maps Wallet Standard \"change\" events to \"accountChanged\" events\n   *\n   * Note: Wallet Standard only has a \"change\" event. There are no \"connect\" or \"disconnect\" events.\n   * Connection/disconnection is indicated by the presence or absence of accounts in the change event.\n   */\n  setupEventListeners() {\n    const eventsFeature = this.wallet.features[\"standard:events\"];\n    if (!eventsFeature) {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard events feature not available\", {\n        walletId: this.walletId,\n        walletName: this.walletName\n      });\n      return;\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Setting up Wallet Standard event listeners\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    eventsFeature.on(\"change\", (properties) => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Wallet Standard change event received\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        hasAccounts: !!properties.accounts,\n        accountCount: properties.accounts?.length || 0\n      });\n      if (properties.accounts !== void 0) {\n        if (properties.accounts.length > 0) {\n          const firstAccount = properties.accounts[0];\n          const address = this.extractAccountAddress(firstAccount);\n          if (address) {\n            this._publicKey = address;\n            this.eventEmitter.emit(\"accountChanged\", address);\n            this.eventEmitter.emit(\"connect\", address);\n            debug.log(DebugCategory.INJECTED_PROVIDER, \"Emitted accountChanged and connect events\", {\n              walletId: this.walletId,\n              walletName: this.walletName,\n              address\n            });\n          } else {\n            this._publicKey = null;\n            this.eventEmitter.emit(\"accountChanged\", null);\n            debug.log(DebugCategory.INJECTED_PROVIDER, \"Emitted accountChanged event (null - invalid account)\", {\n              walletId: this.walletId,\n              walletName: this.walletName\n            });\n          }\n        } else {\n          this._publicKey = null;\n          this.eventEmitter.emit(\"accountChanged\", null);\n          this.eventEmitter.emit(\"disconnect\");\n          debug.log(DebugCategory.INJECTED_PROVIDER, \"Emitted accountChanged and disconnect events\", {\n            walletId: this.walletId,\n            walletName: this.walletName\n          });\n        }\n      }\n    });\n  }\n  extractAccountAddress(account) {\n    return account.address;\n  }\n  on(event, listener) {\n    this.eventEmitter.on(event, listener);\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Added event listener\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      event\n    });\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Removed event listener\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      event\n    });\n  }\n  /**\n   * Serialize a transaction to Uint8Array for Wallet Standard API\n   */\n  serializeTransaction(transaction) {\n    if (typeof transaction.serialize === \"function\") {\n      return transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      });\n    }\n    if (transaction instanceof Uint8Array) {\n      return transaction;\n    }\n    return new Uint8Array(0);\n  }\n  /**\n   * Parse a Uint8Array from various formats\n   * Handles: Uint8Array, Array, object with numeric keys (JSON-serialized Uint8Array)\n   */\n  parseUint8Array(value) {\n    if (value instanceof Uint8Array) {\n      return value;\n    }\n    if (Array.isArray(value)) {\n      return new Uint8Array(value);\n    }\n    if (typeof value === \"object\" && value !== null) {\n      const keys = Object.keys(value).map(Number).filter((k) => !isNaN(k) && k >= 0).sort((a, b) => a - b);\n      if (keys.length > 0) {\n        const maxKey = Math.max(...keys);\n        const array = new Uint8Array(maxKey + 1);\n        for (const key of keys) {\n          array[key] = Number(value[key]) || 0;\n        }\n        return array;\n      }\n    }\n    return new Uint8Array(0);\n  }\n};\n\n// src/providers/injected/chains/InjectedWalletEthereumChain.ts\n\nvar InjectedWalletEthereumChain = class {\n  constructor(provider, walletId, walletName) {\n    // Expose eventEmitter for testing - allows tests to trigger events directly\n    this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_5__.EventEmitter();\n    this._connected = false;\n    this._chainId = \"0x1\";\n    this._accounts = [];\n    this.provider = provider;\n    this.walletId = walletId;\n    this.walletName = walletName;\n    this.setupEventListeners();\n  }\n  get connected() {\n    return this._connected;\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  get accounts() {\n    return this._accounts;\n  }\n  async request(args) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum request\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      method: args.method\n    });\n    try {\n      const requiresAuth = [\n        \"personal_sign\",\n        \"eth_sign\",\n        \"eth_signTypedData\",\n        \"eth_signTypedData_v4\",\n        \"eth_sendTransaction\",\n        \"eth_signTransaction\"\n      ].includes(args.method);\n      if (requiresAuth && (!this._connected || this._accounts.length === 0)) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Method requires authorization, ensuring connection\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          method: args.method\n        });\n        await this.connect();\n      }\n      const result = await this.provider.request(args);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum request success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        method: args.method\n      });\n      return result;\n    } catch (error) {\n      if (error?.code === 4100) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Got 4100 Unauthorized, attempting to re-authorize\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          method: args.method\n        });\n        try {\n          await this.provider.request({ method: \"eth_requestAccounts\" });\n          const result = await this.provider.request(args);\n          debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum request success (after re-auth)\", {\n            walletId: this.walletId,\n            walletName: this.walletName,\n            method: args.method\n          });\n          return result;\n        } catch (retryError) {\n          debug.error(DebugCategory.INJECTED_PROVIDER, \"Failed after re-authorization\", {\n            walletId: this.walletId,\n            walletName: this.walletName,\n            method: args.method,\n            error: retryError instanceof Error ? retryError.message : String(retryError)\n          });\n          throw retryError;\n        }\n      }\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum request failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        method: args.method,\n        error: error instanceof Error ? error.message : String(error),\n        errorCode: error?.code\n      });\n      throw error;\n    }\n  }\n  async connect() {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum connect\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    try {\n      const accounts = await this.provider.request({ method: \"eth_requestAccounts\" });\n      this._connected = accounts.length > 0;\n      this._accounts = accounts;\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum connected (via eth_requestAccounts)\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        accountCount: accounts.length,\n        accounts\n      });\n      return accounts;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum connect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async disconnect() {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum disconnect\", {\n      walletId: this.walletId,\n      walletName: this.walletName\n    });\n    try {\n      await this.provider.disconnect();\n      this._connected = false;\n      this._accounts = [];\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum disconnected\", {\n        walletId: this.walletId,\n        walletName: this.walletName\n      });\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum disconnect failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signPersonalMessage(message, address) {\n    const messagePreview = message.length > 50 ? message.substring(0, 50) + \"...\" : message;\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signPersonalMessage\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      messagePreview,\n      messageLength: message.length,\n      address\n    });\n    try {\n      const providerConnected = this.provider.isConnected?.() || this.provider.connected || false;\n      if (!this._connected || this._accounts.length === 0 || !providerConnected) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Not connected, attempting to connect before signing\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          internalConnected: this._connected,\n          accountsLength: this._accounts.length,\n          providerConnected\n        });\n        await this.connect();\n      }\n      const normalizedAddress = address.toLowerCase();\n      const normalizedAccounts = this._accounts.map((acc) => acc.toLowerCase());\n      if (!normalizedAccounts.includes(normalizedAddress)) {\n        debug.warn(DebugCategory.INJECTED_PROVIDER, \"Address not in connected accounts, refreshing connection\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          requestedAddress: address,\n          connectedAccounts: this._accounts\n        });\n        const currentAccounts = await this.getAccounts();\n        const normalizedCurrentAccounts = currentAccounts.map((acc) => acc.toLowerCase());\n        if (!normalizedCurrentAccounts.includes(normalizedAddress)) {\n          throw new Error(`Address ${address} is not connected. Connected accounts: ${currentAccounts.join(\", \")}`);\n        }\n        this._accounts = currentAccounts;\n      }\n      if (typeof this.provider.signPersonalMessage === \"function\") {\n        const result2 = await this.provider.signPersonalMessage(message, address);\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signPersonalMessage success\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          signatureLength: result2.length\n        });\n        return result2;\n      }\n      const result = await this.request({\n        method: \"personal_sign\",\n        params: [message, address]\n      });\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signPersonalMessage success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signatureLength: result.length\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signPersonalMessage failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error),\n        errorCode: error?.code\n      });\n      throw error;\n    }\n  }\n  async signTypedData(typedData, address) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTypedData\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      primaryType: typedData?.primaryType,\n      address\n    });\n    try {\n      if (typeof this.provider.signTypedData === \"function\") {\n        const result2 = await this.provider.signTypedData(typedData, address);\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTypedData success\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          signatureLength: result2.length\n        });\n        return result2;\n      }\n      const result = await this.request({\n        method: \"eth_signTypedData_v4\",\n        params: [address, typedData]\n      });\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTypedData success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signatureLength: result.length\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTypedData failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async signTransaction(transaction) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTransaction\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      from: transaction.from,\n      to: transaction.to\n    });\n    try {\n      if (typeof this.provider.signTransaction === \"function\") {\n        const result2 = await this.provider.signTransaction(transaction);\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTransaction success\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          signatureLength: result2.length\n        });\n        return result2;\n      }\n      const result = await this.request({\n        method: \"eth_signTransaction\",\n        params: [transaction]\n      });\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTransaction success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        signatureLength: result.length\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum signTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async sendTransaction(transaction) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum sendTransaction\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      from: transaction.from,\n      to: transaction.to,\n      value: transaction.value\n    });\n    try {\n      if (typeof this.provider.sendTransaction === \"function\") {\n        const result2 = await this.provider.sendTransaction(transaction);\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum sendTransaction success\", {\n          walletId: this.walletId,\n          walletName: this.walletName,\n          txHash: result2\n        });\n        return result2;\n      }\n      const result = await this.request({\n        method: \"eth_sendTransaction\",\n        params: [transaction]\n      });\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum sendTransaction success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        txHash: result\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum sendTransaction failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async switchChain(chainId) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum switchChain\", {\n      walletId: this.walletId,\n      walletName: this.walletName,\n      chainId\n    });\n    try {\n      const hexChainId = typeof chainId === \"string\" ? chainId.toLowerCase().startsWith(\"0x\") ? chainId : `0x${parseInt(chainId, 10).toString(16)}` : `0x${chainId.toString(16)}`;\n      if (typeof this.provider.switchChain === \"function\") {\n        await this.provider.switchChain(hexChainId);\n      } else {\n        await this.request({ method: \"wallet_switchEthereumChain\", params: [{ chainId: hexChainId }] });\n      }\n      this._chainId = hexChainId;\n      this.eventEmitter.emit(\"chainChanged\", this._chainId);\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum switchChain success\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        chainId: hexChainId\n      });\n    } catch (error) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"External wallet Ethereum switchChain failed\", {\n        walletId: this.walletId,\n        walletName: this.walletName,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  async getChainId() {\n    if (typeof this.provider.getChainId === \"function\") {\n      const chainId2 = await this.provider.getChainId();\n      this._chainId = `0x${chainId2.toString(16)}`;\n      return chainId2;\n    }\n    const chainId = await this.request({ method: \"eth_chainId\" });\n    const parsed = parseInt(chainId, 16);\n    this._chainId = chainId;\n    return parsed;\n  }\n  async getAccounts() {\n    if (typeof this.provider.getAccounts === \"function\") {\n      const accounts2 = await this.provider.getAccounts();\n      this._accounts = accounts2;\n      return accounts2;\n    }\n    const accounts = await this.request({ method: \"eth_accounts\" });\n    this._accounts = accounts;\n    return accounts;\n  }\n  isConnected() {\n    return this._connected;\n  }\n  setupEventListeners() {\n    if (typeof this.provider.on === \"function\") {\n      this.provider.on(\"connect\", (info) => {\n        this._connected = true;\n        this._chainId = info.chainId;\n        this.eventEmitter.emit(\"connect\", info);\n      });\n      this.provider.on(\"disconnect\", (error) => {\n        this._connected = false;\n        this._accounts = [];\n        this.eventEmitter.emit(\"disconnect\", error);\n        this.eventEmitter.emit(\"accountsChanged\", []);\n      });\n      this.provider.on(\"accountsChanged\", (accounts) => {\n        this._accounts = accounts;\n        this._connected = accounts.length > 0;\n        this.eventEmitter.emit(\"accountsChanged\", accounts);\n      });\n      this.provider.on(\"chainChanged\", (chainId) => {\n        this._chainId = chainId;\n        this.eventEmitter.emit(\"chainChanged\", chainId);\n      });\n    }\n  }\n  on(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n  }\n};\n\n// src/wallets/registry.ts\nfunction isPhantomWallet(wallet) {\n  return wallet !== void 0 && wallet.id === \"phantom\" && \"isPhantom\" in wallet && wallet.isPhantom === true;\n}\nfunction isWalletStandardWallet(provider) {\n  return provider !== null && typeof provider === \"object\" && \"features\" in provider && typeof provider.features === \"object\";\n}\nvar InjectedWalletRegistry = class {\n  constructor() {\n    this.wallets = /* @__PURE__ */ new Map();\n    this.discoveryPromise = null;\n  }\n  register(info) {\n    const wrappedProviders = {};\n    if (info.providers?.solana) {\n      if (isWalletStandardWallet(info.providers.solana)) {\n        wrappedProviders.solana = new WalletStandardSolanaAdapter(info.providers.solana, info.id, info.name);\n        debug.log(DebugCategory.BROWSER_SDK, \"Wrapped Wallet Standard Solana wallet with adapter\", {\n          walletId: info.id,\n          walletName: info.name\n        });\n      } else {\n        wrappedProviders.solana = new InjectedWalletSolanaChain(info.providers.solana, info.id, info.name);\n        debug.log(DebugCategory.BROWSER_SDK, \"Wrapped Solana provider with InjectedWalletSolanaChain\", {\n          walletId: info.id,\n          walletName: info.name\n        });\n      }\n    }\n    if (info.providers?.ethereum) {\n      wrappedProviders.ethereum = new InjectedWalletEthereumChain(info.providers.ethereum, info.id, info.name);\n      debug.log(DebugCategory.BROWSER_SDK, \"Wrapped Ethereum provider with InjectedWalletEthereumChain\", {\n        walletId: info.id,\n        walletName: info.name\n      });\n    }\n    const wrappedInfo = {\n      ...info,\n      providers: Object.keys(wrappedProviders).length > 0 ? wrappedProviders : info.providers\n    };\n    this.wallets.set(info.id, wrappedInfo);\n  }\n  /**\n   * Register Phantom wallet with its instance\n   * This creates wrapped providers and stores the Phantom instance for auto-confirm access\n   * Uses unified InjectedWallet chains for both Phantom and external wallets\n   */\n  registerPhantom(phantomInstance, addressTypes) {\n    const wrappedProviders = {};\n    if (addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana) && phantomInstance.solana) {\n      wrappedProviders.solana = new InjectedWalletSolanaChain(phantomInstance.solana, \"phantom\", \"Phantom\");\n      debug.log(DebugCategory.BROWSER_SDK, \"Created InjectedWalletSolanaChain wrapper for Phantom\", {\n        walletId: \"phantom\"\n      });\n    }\n    if (addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum) && phantomInstance.ethereum) {\n      wrappedProviders.ethereum = new InjectedWalletEthereumChain(phantomInstance.ethereum, \"phantom\", \"Phantom\");\n      debug.log(DebugCategory.BROWSER_SDK, \"Created InjectedWalletEthereumChain wrapper for Phantom\", {\n        walletId: \"phantom\"\n      });\n    }\n    const phantomWallet = {\n      id: \"phantom\",\n      name: \"Phantom\",\n      icon: \"\",\n      // Icon will be rendered from icons package in UI components\n      addressTypes,\n      providers: wrappedProviders,\n      isPhantom: true,\n      phantomInstance,\n      discovery: \"phantom\"\n    };\n    this.wallets.set(\"phantom\", phantomWallet);\n    debug.log(DebugCategory.BROWSER_SDK, \"Registered Phantom wallet with chain wrappers\", {\n      addressTypes,\n      hasSolana: !!wrappedProviders.solana,\n      hasEthereum: !!wrappedProviders.ethereum\n    });\n  }\n  unregister(id) {\n    this.wallets.delete(id);\n  }\n  has(id) {\n    return this.wallets.has(id);\n  }\n  getById(id) {\n    return this.wallets.get(id);\n  }\n  getAll() {\n    return Array.from(this.wallets.values());\n  }\n  getByAddressTypes(addressTypes) {\n    if (addressTypes.length === 0) {\n      return this.getAll();\n    }\n    const allowed = new Set(addressTypes);\n    return this.getAll().filter((wallet) => wallet.addressTypes.some((t) => allowed.has(t)));\n  }\n  discover(addressTypes) {\n    if (this.discoveryPromise) {\n      return this.discoveryPromise;\n    }\n    debug.log(DebugCategory.BROWSER_SDK, \"Starting wallet discovery\", { addressTypes });\n    this.discoveryPromise = discoverWallets(addressTypes).then((discoveredWallets) => {\n      const relevantWallets = addressTypes ? discoveredWallets.filter((wallet) => wallet.addressTypes.some((type) => addressTypes.includes(type))) : discoveredWallets;\n      for (const wallet of relevantWallets) {\n        if (wallet.id === \"phantom\" && isPhantomWallet(wallet)) {\n          this.registerPhantom(wallet.phantomInstance, wallet.addressTypes);\n        } else {\n          this.register(wallet);\n        }\n        debug.log(DebugCategory.BROWSER_SDK, \"Registered discovered wallet\", {\n          id: wallet.id,\n          name: wallet.name,\n          addressTypes: wallet.addressTypes\n        });\n      }\n      debug.info(DebugCategory.BROWSER_SDK, \"Wallet discovery completed\", {\n        totalDiscovered: discoveredWallets.length,\n        relevantWallets: relevantWallets.length\n      });\n    }).catch((error) => {\n      debug.warn(DebugCategory.BROWSER_SDK, \"Wallet discovery failed\", { error });\n      this.discoveryPromise = null;\n      throw error;\n    });\n    return this.discoveryPromise;\n  }\n};\nvar walletRegistry = null;\nfunction getWalletRegistry() {\n  if (!walletRegistry) {\n    walletRegistry = new InjectedWalletRegistry();\n  }\n  return walletRegistry;\n}\n\n// src/providers/injected/index.ts\nvar WAS_CONNECTED_KEY = \"phantom-injected-was-connected\";\nvar WAS_CONNECTED_VALUE = \"true\";\nvar LAST_WALLET_ID_KEY = \"phantom-injected-last-wallet-id\";\nvar InjectedProvider = class {\n  // Store cleanups per walletId\n  constructor(config) {\n    this.selectedWalletId = null;\n    this.walletStates = /* @__PURE__ */ new Map();\n    // Event management\n    this.eventListeners = /* @__PURE__ */ new Map();\n    this.eventsInitialized = false;\n    this.eventListenersSetup = /* @__PURE__ */ new Set();\n    // Track walletId that have listeners set up\n    this.eventListenerCleanups = /* @__PURE__ */ new Map();\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Initializing InjectedProvider\", { config });\n    this.addressTypes = config.addressTypes;\n    this.walletRegistry = getWalletRegistry();\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Address types configured\", { addressTypes: this.addressTypes });\n    this.walletRegistry.discover(this.addressTypes).catch((error) => {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Wallet discovery failed during initialization\", { error });\n    });\n    debug.info(DebugCategory.INJECTED_PROVIDER, \"InjectedProvider initialized\");\n  }\n  /**\n   * Wait for wallet discovery to complete if the wallet is not yet in the registry\n   * This is needed for auto-connect when the last wallet was an external wallet\n   */\n  async waitForWalletDiscovery(walletId) {\n    if (this.walletRegistry.has(walletId)) {\n      return;\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Wallet not found in registry, waiting for discovery\", {\n      walletId\n    });\n    try {\n      await this.walletRegistry.discover(this.addressTypes);\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Wallet discovery completed\", { walletId });\n    } catch (error) {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Wallet discovery failed\", {\n        walletId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n  /**\n   * Helper method to get a chain provider with consistent error handling\n   */\n  getChainProvider(addressType, providerKey, chainName) {\n    if (!this.addressTypes.includes(addressType)) {\n      throw new Error(`${chainName} not enabled for this provider`);\n    }\n    const walletId = this.selectedWalletId || \"phantom\";\n    const walletInfo = this.walletRegistry.getById(walletId);\n    if (!walletInfo) {\n      const registry = this.walletRegistry;\n      if (registry.discoveryPromise) {\n        throw new Error(\n          `Wallet \"${walletId}\" not found. Wallet discovery is still in progress. Please wait for sdk.discoverWallets() to complete before accessing chain properties.`\n        );\n      }\n      throw new Error(\n        `Wallet \"${walletId}\" not found. Please ensure wallet discovery has completed. Make sure you call sdk.discoverWallets() and await it before accessing chain properties.`\n      );\n    }\n    const provider = walletInfo.providers?.[providerKey];\n    if (!provider) {\n      throw new Error(\n        `Selected wallet \"${walletInfo.name}\" does not support ${chainName}. This wallet only supports: ${walletInfo.addressTypes.join(\", \")}. Make sure your SDK config includes ${chainName} in addressTypes.`\n      );\n    }\n    return provider;\n  }\n  get solana() {\n    return this.getChainProvider(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana, \"solana\", \"Solana\");\n  }\n  /**\n   * Access to Ethereum chain operations\n   */\n  get ethereum() {\n    return this.getChainProvider(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum, \"ethereum\", \"Ethereum\");\n  }\n  validateAndSelectWallet(requestedWalletId) {\n    if (!this.walletRegistry.has(requestedWalletId)) {\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Unknown injected wallet id requested\", {\n        walletId: requestedWalletId\n      });\n      throw new Error(`Unknown injected wallet id: ${requestedWalletId}`);\n    }\n    const walletInfo = this.walletRegistry.getById(requestedWalletId);\n    if (!walletInfo || !walletInfo.providers) {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Wallet not available for connection\", {\n        walletId: requestedWalletId\n      });\n      throw new Error(`Wallet not available for connection: ${requestedWalletId}`);\n    }\n    this.selectedWalletId = requestedWalletId;\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Selected injected wallet for connection\", {\n      walletId: requestedWalletId\n    });\n    return walletInfo;\n  }\n  async connectToWallet(walletInfo, options) {\n    if (!walletInfo.providers) {\n      const error = new Error(`Wallet adapter not available for wallet: ${this.selectedWalletId}`);\n      debug.error(DebugCategory.INJECTED_PROVIDER, \"Wallet adapter not available\", { walletId: this.selectedWalletId });\n      this.emit(\"connect_error\", {\n        error: error.message,\n        source: options?.skipEventListeners ? \"auto-connect\" : \"manual-connect\"\n      });\n      throw error;\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Connecting via wallet\", {\n      walletId: this.selectedWalletId,\n      walletName: walletInfo.name,\n      options\n    });\n    if (!options?.skipEventListeners) {\n      this.setupEventListeners(walletInfo);\n    }\n    const connectedAddresses = [];\n    if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana) && walletInfo.providers?.solana) {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Attempting Solana connection\", {\n        walletId: this.selectedWalletId,\n        walletName: walletInfo.name,\n        onlyIfTrusted: options?.onlyIfTrusted\n      });\n      try {\n        const result = await walletInfo.providers.solana.connect(\n          options?.onlyIfTrusted ? { onlyIfTrusted: true } : void 0\n        );\n        const address = result.publicKey;\n        connectedAddresses.push({\n          addressType: _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana,\n          address\n        });\n        debug.info(DebugCategory.INJECTED_PROVIDER, \"Solana connected successfully\", {\n          address,\n          walletId: this.selectedWalletId,\n          walletName: walletInfo.name\n        });\n      } catch (err) {\n        debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to connect Solana, stopping\", {\n          error: err,\n          walletId: this.selectedWalletId,\n          walletName: walletInfo.name\n        });\n        this.emit(\"connect_error\", {\n          error: err instanceof Error ? err.message : \"Failed to connect\",\n          source: options?.skipEventListeners ? \"auto-connect\" : \"manual-connect\"\n        });\n        throw err;\n      }\n    }\n    if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum) && walletInfo.providers?.ethereum) {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Attempting Ethereum connection\", {\n        walletId: this.selectedWalletId,\n        walletName: walletInfo.name,\n        silent: options?.silent\n      });\n      try {\n        let accounts;\n        if (options?.silent) {\n          accounts = await walletInfo.providers.ethereum.request({ method: \"eth_accounts\" });\n        } else {\n          accounts = await walletInfo.providers.ethereum.connect();\n        }\n        if (accounts.length > 0) {\n          connectedAddresses.push(\n            ...accounts.map((address) => ({\n              addressType: _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum,\n              address\n            }))\n          );\n          debug.info(DebugCategory.INJECTED_PROVIDER, \"Ethereum connected successfully\", {\n            addresses: accounts,\n            walletId: this.selectedWalletId,\n            walletName: walletInfo.name\n          });\n        }\n      } catch (err) {\n        debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to connect Ethereum, stopping\", {\n          error: err,\n          walletId: this.selectedWalletId,\n          walletName: walletInfo.name\n        });\n        this.emit(\"connect_error\", {\n          error: err instanceof Error ? err.message : \"Failed to connect\",\n          source: options?.skipEventListeners ? \"auto-connect\" : \"manual-connect\"\n        });\n        throw err;\n      }\n    }\n    return connectedAddresses;\n  }\n  async finalizeConnection(connectedAddresses, authProvider, walletId) {\n    if (connectedAddresses.length === 0) {\n      const error = new Error(\"Failed to connect to any supported wallet provider\");\n      this.emit(\"connect_error\", {\n        error: error.message,\n        source: \"manual-connect\"\n      });\n      throw error;\n    }\n    if (this.selectedWalletId) {\n      this.setWalletState(this.selectedWalletId, {\n        connected: true,\n        addresses: connectedAddresses\n      });\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Finalized connection with addresses\", {\n      addressCount: connectedAddresses.length,\n      addresses: connectedAddresses.map((addr) => ({\n        type: addr.addressType,\n        address: addr.address.substring(0, 10) + \"...\"\n      }))\n    });\n    const authUserId = await this.getAuthUserId(\"manual-connect\");\n    try {\n      localStorage.setItem(WAS_CONNECTED_KEY, WAS_CONNECTED_VALUE);\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Set was-connected flag - auto-reconnect enabled\");\n      if (this.selectedWalletId) {\n        localStorage.setItem(LAST_WALLET_ID_KEY, this.selectedWalletId);\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Stored last injected wallet id\", {\n          walletId: this.selectedWalletId\n        });\n      }\n    } catch (error) {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to persist injected provider state\", { error });\n    }\n    const walletInfo = walletId ? this.walletRegistry.getById(walletId) : void 0;\n    const wallet = walletInfo ? {\n      id: walletInfo.id,\n      name: walletInfo.name,\n      icon: walletInfo.icon,\n      addressTypes: walletInfo.addressTypes,\n      rdns: walletInfo.rdns,\n      discovery: walletInfo.discovery\n    } : void 0;\n    const result = {\n      addresses: connectedAddresses,\n      status: \"completed\",\n      authUserId,\n      authProvider,\n      walletId,\n      wallet\n    };\n    this.emit(\"connect\", {\n      addresses: connectedAddresses,\n      source: \"manual-connect\",\n      authUserId\n    });\n    return result;\n  }\n  async connect(authOptions) {\n    debug.info(DebugCategory.INJECTED_PROVIDER, \"Starting injected provider connect\", {\n      addressTypes: this.addressTypes,\n      provider: authOptions.provider\n    });\n    if (authOptions.provider !== \"injected\") {\n      throw new Error(`Invalid provider for injected connection: ${authOptions.provider}. Must be \"injected\"`);\n    }\n    this.emit(\"connect_start\", {\n      source: \"manual-connect\",\n      providerType: \"injected\"\n    });\n    try {\n      const requestedWalletId = authOptions.walletId || \"phantom\";\n      const walletInfo = this.validateAndSelectWallet(requestedWalletId);\n      const connectedAddresses = await this.connectToWallet(walletInfo);\n      return await this.finalizeConnection(connectedAddresses, \"injected\", this.selectedWalletId || void 0);\n    } catch (error) {\n      this.emit(\"connect_error\", {\n        error: error instanceof Error ? error.message : \"Failed to connect\",\n        source: \"manual-connect\"\n      });\n      throw error;\n    }\n  }\n  async disconnect() {\n    debug.info(DebugCategory.INJECTED_PROVIDER, \"Starting injected provider disconnect\");\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (walletInfo?.providers) {\n      if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana) && walletInfo.providers.solana) {\n        try {\n          await walletInfo.providers.solana.disconnect();\n          debug.log(DebugCategory.INJECTED_PROVIDER, \"Solana disconnected successfully\");\n        } catch (err) {\n          debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to disconnect Solana\", { error: err });\n        }\n      }\n      if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum) && walletInfo.providers.ethereum) {\n        try {\n          await walletInfo.providers.ethereum.disconnect();\n          debug.log(DebugCategory.INJECTED_PROVIDER, \"Ethereum disconnected successfully\");\n        } catch (err) {\n          debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to disconnect Ethereum\", { error: err });\n        }\n      }\n    }\n    const walletId = this.selectedWalletId || \"phantom\";\n    const cleanups = this.eventListenerCleanups.get(walletId);\n    if (cleanups) {\n      cleanups.forEach((cleanup) => cleanup());\n      this.eventListenerCleanups.delete(walletId);\n    }\n    this.eventListenersSetup.delete(walletId);\n    if (this.selectedWalletId) {\n      this.setWalletState(this.selectedWalletId, {\n        connected: false,\n        addresses: []\n      });\n    }\n    try {\n      localStorage.removeItem(WAS_CONNECTED_KEY);\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Cleared was connected flag to prevent auto-reconnect\");\n    } catch (error) {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to clear was-connected flag\", { error });\n    }\n    this.emit(\"disconnect\", {\n      source: \"manual-disconnect\"\n    });\n    debug.info(DebugCategory.INJECTED_PROVIDER, \"Injected provider disconnected successfully\");\n  }\n  /**\n   * Attempt auto-connection if user was previously connected\n   * Only reconnects if the user connected before and didn't explicitly disconnect\n   * Should be called after setting up event listeners\n   */\n  async autoConnect() {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Attempting auto-connect\");\n    let lastWalletId = null;\n    try {\n      const wasConnected = localStorage.getItem(WAS_CONNECTED_KEY);\n      if (wasConnected !== WAS_CONNECTED_VALUE) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Skipping auto-connect: user was not previously connected\");\n        return;\n      }\n      lastWalletId = localStorage.getItem(LAST_WALLET_ID_KEY);\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"User was previously connected, attempting auto-connect\", {\n        lastWalletId: lastWalletId || \"phantom\"\n      });\n    } catch (error) {\n      debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to check was-connected flag\", { error });\n      return;\n    }\n    this.emit(\"connect_start\", {\n      source: \"auto-connect\",\n      providerType: \"injected\"\n    });\n    try {\n      const walletId = lastWalletId || \"phantom\";\n      await this.waitForWalletDiscovery(walletId);\n      const walletInfo = this.validateAndSelectWallet(walletId);\n      let connectedAddresses = [];\n      try {\n        connectedAddresses = await this.connectToWallet(walletInfo, {\n          onlyIfTrusted: true,\n          silent: true,\n          skipEventListeners: true\n          // Set up listeners only if connection succeeds\n        });\n      } catch (err) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Auto-connect failed (expected if not trusted)\", {\n          error: err,\n          walletId: this.selectedWalletId\n        });\n      }\n      if (connectedAddresses.length === 0) {\n        debug.log(DebugCategory.INJECTED_PROVIDER, \"Auto-connect failed: no trusted connections available\");\n        this.emit(\"connect_error\", {\n          error: \"No trusted connections available\",\n          source: \"auto-connect\"\n        });\n        return;\n      }\n      this.setupEventListeners(walletInfo);\n      if (this.selectedWalletId) {\n        this.setWalletState(this.selectedWalletId, {\n          connected: true,\n          addresses: connectedAddresses\n        });\n      }\n      const authUserId = await this.getAuthUserId(\"auto-connect\");\n      this.emit(\"connect\", {\n        addresses: connectedAddresses,\n        source: \"auto-connect\",\n        authUserId\n      });\n      debug.info(DebugCategory.INJECTED_PROVIDER, \"Auto-connect successful\", {\n        addressCount: connectedAddresses.length,\n        addresses: connectedAddresses.map((addr) => ({\n          type: addr.addressType,\n          address: addr.address.substring(0, 8) + \"...\"\n        })),\n        walletId: this.selectedWalletId,\n        authUserId\n      });\n    } catch (error) {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Auto-connect failed with error\", {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      this.emit(\"connect_error\", {\n        error: error instanceof Error ? error.message : \"Auto-connect failed\",\n        source: \"auto-connect\"\n      });\n    }\n  }\n  getWalletState(walletId) {\n    if (!this.walletStates.has(walletId)) {\n      this.walletStates.set(walletId, { connected: false, addresses: [] });\n    }\n    return this.walletStates.get(walletId);\n  }\n  setWalletState(walletId, state) {\n    this.walletStates.set(walletId, state);\n  }\n  /**\n   * Update wallet state with new addresses for a specific address type\n   * Replaces all existing addresses of the given type with the new addresses\n   * @param walletId - The wallet ID to update\n   * @param newAddresses - Array of new addresses (strings) for the address type\n   * @param addressType - The type of addresses being updated\n   * @returns The updated addresses array\n   */\n  updateWalletAddresses(walletId, newAddresses, addressType) {\n    const state = this.getWalletState(walletId);\n    const otherAddresses = state.addresses.filter((addr) => addr.addressType !== addressType);\n    const addressesOfType = newAddresses.map((address) => ({ addressType, address }));\n    const updatedAddresses = [...otherAddresses, ...addressesOfType];\n    this.setWalletState(walletId, {\n      connected: updatedAddresses.length > 0,\n      addresses: updatedAddresses\n    });\n    return updatedAddresses;\n  }\n  /**\n   * Helper to construct account change source string\n   */\n  getAccountChangeSource(source) {\n    return `${source}-account-change`;\n  }\n  /**\n   * Create a handler for Solana connect events\n   */\n  createSolanaConnectHandler(walletId, source) {\n    return async (publicKey) => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Solana connect event received\", { publicKey, walletId });\n      const newAddresses = this.updateWalletAddresses(walletId, [publicKey], _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana);\n      const authUserId = await this.getAuthUserId(\"Solana connect event\");\n      this.emit(\"connect\", {\n        addresses: newAddresses,\n        source,\n        authUserId\n      });\n    };\n  }\n  /**\n   * Create a handler for Solana disconnect events\n   */\n  createSolanaDisconnectHandler(walletId, source) {\n    return () => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Solana disconnect event received\", { walletId });\n      const state = this.getWalletState(walletId);\n      const filteredAddresses = state.addresses.filter((addr) => addr.addressType !== _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana);\n      this.setWalletState(walletId, {\n        connected: filteredAddresses.length > 0,\n        addresses: filteredAddresses\n      });\n      this.emit(\"disconnect\", {\n        source\n      });\n    };\n  }\n  /**\n   * Create a handler for Solana account change events\n   * Can receive string | null per Wallet Standard\n   */\n  createSolanaAccountChangeHandler(walletId, source) {\n    return async (publicKey) => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Solana account changed event received\", { publicKey, walletId });\n      if (publicKey) {\n        const newAddresses = this.updateWalletAddresses(walletId, [publicKey], _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana);\n        const authUserId = await this.getAuthUserId(\"Solana account changed event\");\n        this.emit(\"connect\", {\n          addresses: newAddresses,\n          source: this.getAccountChangeSource(source),\n          authUserId\n        });\n      } else {\n        const state = this.getWalletState(walletId);\n        const otherAddresses = state.addresses.filter((addr) => addr.addressType !== _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana);\n        this.setWalletState(walletId, {\n          connected: otherAddresses.length > 0,\n          addresses: otherAddresses\n        });\n        this.emit(\"disconnect\", {\n          source: this.getAccountChangeSource(source)\n        });\n      }\n    };\n  }\n  /**\n   * Create a handler for Ethereum connect events\n   * EIP-1193 connect event receives { chainId: string }, but we need to get accounts separately\n   */\n  createEthereumConnectHandler(walletId, source) {\n    return async (connectInfo) => {\n      let accounts = [];\n      if (Array.isArray(connectInfo)) {\n        accounts = connectInfo;\n      } else {\n        try {\n          const walletInfo = this.walletRegistry.getById(walletId);\n          if (walletInfo?.providers?.ethereum) {\n            accounts = await walletInfo.providers.ethereum.getAccounts();\n          }\n        } catch (error) {\n          debug.warn(DebugCategory.INJECTED_PROVIDER, \"Failed to get accounts on connect\", { error });\n        }\n      }\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Ethereum connect event received\", { accounts, walletId });\n      if (accounts.length > 0) {\n        const newAddresses = this.updateWalletAddresses(walletId, accounts, _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum);\n        const authUserId = await this.getAuthUserId(\"Ethereum connect event\");\n        this.emit(\"connect\", {\n          addresses: newAddresses,\n          source,\n          authUserId\n        });\n      }\n    };\n  }\n  /**\n   * Create a handler for Ethereum disconnect events\n   */\n  createEthereumDisconnectHandler(walletId, source) {\n    return () => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Ethereum disconnect event received\", { walletId });\n      const state = this.getWalletState(walletId);\n      const filteredAddresses = state.addresses.filter((addr) => addr.addressType !== _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum);\n      this.setWalletState(walletId, {\n        connected: filteredAddresses.length > 0,\n        addresses: filteredAddresses\n      });\n      this.emit(\"disconnect\", {\n        source\n      });\n    };\n  }\n  /**\n   * Create a handler for Ethereum account change events\n   */\n  createEthereumAccountChangeHandler(walletId, source) {\n    return async (accounts) => {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Ethereum accounts changed event received\", { accounts, walletId });\n      if (accounts && accounts.length > 0) {\n        const newAddresses = this.updateWalletAddresses(walletId, accounts, _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum);\n        const authUserId = await this.getAuthUserId(\"Ethereum accounts changed event\");\n        this.emit(\"connect\", {\n          addresses: newAddresses,\n          source: this.getAccountChangeSource(source),\n          authUserId\n        });\n      } else {\n        const state = this.getWalletState(walletId);\n        const otherAddresses = state.addresses.filter((addr) => addr.addressType !== _phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum);\n        this.setWalletState(walletId, {\n          connected: otherAddresses.length > 0,\n          addresses: otherAddresses\n        });\n        this.emit(\"disconnect\", {\n          source: this.getAccountChangeSource(source)\n        });\n      }\n    };\n  }\n  getAddresses() {\n    const walletId = this.selectedWalletId || \"phantom\";\n    return this.getWalletState(walletId).addresses;\n  }\n  /**\n   * Get enabled address types for the current selected wallet\n   * - For Phantom: returns config.addressTypes\n   * - For external wallets: returns the wallet's addressTypes from registry\n   */\n  getEnabledAddressTypes() {\n    if (!this.selectedWalletId || this.selectedWalletId === \"phantom\") {\n      return this.addressTypes;\n    }\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId);\n    if (walletInfo) {\n      return walletInfo.addressTypes;\n    }\n    return this.addressTypes;\n  }\n  isConnected() {\n    const walletId = this.selectedWalletId || \"phantom\";\n    return this.getWalletState(walletId).connected;\n  }\n  // AutoConfirm methods - only available for Phantom wallet\n  async enableAutoConfirm(params) {\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (!isPhantomWallet(walletInfo)) {\n      throw new Error(\"Auto-confirm is only available for Phantom wallet\");\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Enabling autoConfirm\", { params });\n    return await walletInfo.phantomInstance.autoConfirm.autoConfirmEnable(params);\n  }\n  async disableAutoConfirm() {\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (!isPhantomWallet(walletInfo)) {\n      throw new Error(\"Auto-confirm is only available for Phantom wallet\");\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Disabling autoConfirm\");\n    await walletInfo.phantomInstance.autoConfirm.autoConfirmDisable();\n  }\n  async getAutoConfirmStatus() {\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (!isPhantomWallet(walletInfo)) {\n      throw new Error(\"Auto-confirm is only available for Phantom wallet\");\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Getting autoConfirm status\");\n    return await walletInfo.phantomInstance.autoConfirm.autoConfirmStatus();\n  }\n  async getSupportedAutoConfirmChains() {\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (!isPhantomWallet(walletInfo)) {\n      throw new Error(\"Auto-confirm is only available for Phantom wallet\");\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Getting supported autoConfirm chains\");\n    return await walletInfo.phantomInstance.autoConfirm.autoConfirmSupportedChains();\n  }\n  /**\n   * Helper method to get authUserId from window.phantom.app.getUser()\n   * Returns undefined if the method is not available or fails, or if wallet is not Phantom\n   */\n  async getAuthUserId(context) {\n    const walletInfo = this.walletRegistry.getById(this.selectedWalletId || \"phantom\");\n    if (!isPhantomWallet(walletInfo)) {\n      return void 0;\n    }\n    try {\n      if (window.phantom?.app?.getUser) {\n        const userInfo = await window.phantom.app.getUser();\n        const authUserId = userInfo?.authUserId;\n        if (authUserId) {\n          debug.log(\n            DebugCategory.INJECTED_PROVIDER,\n            `Retrieved authUserId from window.phantom.app.getUser() during ${context}`,\n            {\n              authUserId\n            }\n          );\n        }\n        return authUserId;\n      }\n    } catch (error) {\n      debug.log(\n        DebugCategory.INJECTED_PROVIDER,\n        `Failed to get user info during ${context} (method may not be supported)`,\n        { error }\n      );\n    }\n    return void 0;\n  }\n  // Event management methods - implementing unified event interface\n  on(event, callback) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Adding event listener\", { event });\n    if (!this.eventsInitialized) {\n      const walletId = this.selectedWalletId || \"phantom\";\n      const walletInfo = this.walletRegistry.getById(walletId);\n      if (walletInfo) {\n        this.setupEventListeners(walletInfo);\n      }\n    }\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventListeners.get(event)?.add(callback);\n  }\n  off(event, callback) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Removing event listener\", { event });\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event)?.delete(callback);\n      if (this.eventListeners.get(event)?.size === 0) {\n        this.eventListeners.delete(event);\n      }\n    }\n  }\n  emit(event, data) {\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Emitting event\", {\n      event,\n      listenerCount: this.eventListeners.get(event)?.size || 0,\n      data\n    });\n    const listeners = this.eventListeners.get(event);\n    if (listeners && listeners.size > 0) {\n      listeners.forEach((callback) => {\n        try {\n          callback(data);\n        } catch (error) {\n          debug.error(DebugCategory.INJECTED_PROVIDER, \"Event callback error\", { event, error });\n        }\n      });\n    }\n  }\n  /**\n   * Set up Solana event listeners for any provider (Phantom or external)\n   */\n  setupSolanaEventListeners(provider, walletId, source) {\n    if (typeof provider.on !== \"function\")\n      return;\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Setting up Solana event listeners\", { walletId, source });\n    const handlers = {\n      connect: this.createSolanaConnectHandler(walletId, source),\n      disconnect: this.createSolanaDisconnectHandler(walletId, source),\n      accountChanged: this.createSolanaAccountChangeHandler(walletId, source)\n    };\n    provider.on(\"connect\", handlers.connect);\n    provider.on(\"disconnect\", handlers.disconnect);\n    provider.on(\"accountChanged\", handlers.accountChanged);\n    const cleanups = [];\n    if (typeof provider.off === \"function\") {\n      cleanups.push(\n        () => provider.off(\"connect\", handlers.connect),\n        () => provider.off(\"disconnect\", handlers.disconnect),\n        () => provider.off(\"accountChanged\", handlers.accountChanged)\n      );\n    }\n    const existingCleanups = this.eventListenerCleanups.get(walletId) || [];\n    this.eventListenerCleanups.set(walletId, [...existingCleanups, ...cleanups]);\n  }\n  /**\n   * Set up Ethereum event listeners for any provider (Phantom or external)\n   */\n  setupEthereumEventListeners(provider, walletId, source) {\n    if (typeof provider.on !== \"function\")\n      return;\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Setting up Ethereum event listeners\", { walletId, source });\n    const handlers = {\n      connect: this.createEthereumConnectHandler(walletId, source),\n      disconnect: this.createEthereumDisconnectHandler(walletId, source),\n      accountsChanged: this.createEthereumAccountChangeHandler(walletId, source)\n    };\n    provider.on(\"connect\", handlers.connect);\n    provider.on(\"disconnect\", handlers.disconnect);\n    provider.on(\"accountsChanged\", handlers.accountsChanged);\n    const cleanups = [];\n    if (typeof provider.off === \"function\") {\n      cleanups.push(\n        () => provider.off(\"connect\", handlers.connect),\n        () => provider.off(\"disconnect\", handlers.disconnect),\n        () => provider.off(\"accountsChanged\", handlers.accountsChanged)\n      );\n    }\n    const existingCleanups = this.eventListenerCleanups.get(walletId) || [];\n    this.eventListenerCleanups.set(walletId, [...existingCleanups, ...cleanups]);\n  }\n  /**\n   * Unified event listener setup for all wallet types (Phantom and external)\n   */\n  setupEventListeners(walletInfo) {\n    const walletId = this.selectedWalletId || \"phantom\";\n    if (this.eventListenersSetup.has(walletId)) {\n      debug.log(DebugCategory.INJECTED_PROVIDER, \"Event listeners already set up for wallet\", { walletId });\n      return;\n    }\n    debug.log(DebugCategory.INJECTED_PROVIDER, \"Setting up event listeners\", { walletId });\n    if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana) && walletInfo.providers?.solana) {\n      this.setupSolanaEventListeners(walletInfo.providers.solana, walletId, \"wallet\");\n    }\n    if (this.addressTypes.includes(_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.ethereum) && walletInfo.providers?.ethereum) {\n      this.setupEthereumEventListeners(walletInfo.providers.ethereum, walletId, \"wallet\");\n    }\n    this.eventListenersSetup.add(walletId);\n    this.eventsInitialized = true;\n  }\n};\n\n// src/providers/embedded/index.ts\n\n\n\n// src/providers/embedded/adapters/storage.ts\nvar BrowserStorage = class {\n  constructor() {\n    this.dbName = \"phantom-browser-sdk\";\n    this.storeName = \"sessions\";\n    this.version = 1;\n  }\n  async getDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n      };\n    });\n  }\n  async getSession() {\n    debug.log(DebugCategory.STORAGE, \"Getting session from IndexedDB\");\n    const db = await this.getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(\"currentSession\");\n      request.onsuccess = () => {\n        const session = request.result || null;\n        debug.log(DebugCategory.STORAGE, \"Retrieved session from IndexedDB\", {\n          hasSession: !!session,\n          sessionId: session?.sessionId\n        });\n        resolve(session);\n      };\n      request.onerror = () => {\n        debug.error(DebugCategory.STORAGE, \"Failed to get session from IndexedDB\", { error: request.error });\n        reject(request.error);\n      };\n    });\n  }\n  async saveSession(session) {\n    debug.log(DebugCategory.STORAGE, \"Saving session to IndexedDB\", {\n      sessionId: session.sessionId,\n      walletId: session.walletId,\n      status: session.status\n    });\n    const db = await this.getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put(session, \"currentSession\");\n      request.onsuccess = () => {\n        debug.log(DebugCategory.STORAGE, \"Successfully saved session to IndexedDB\");\n        resolve();\n      };\n      request.onerror = () => {\n        debug.error(DebugCategory.STORAGE, \"Failed to save session to IndexedDB\", { error: request.error });\n        reject(request.error);\n      };\n    });\n  }\n  async clearSession() {\n    debug.log(DebugCategory.STORAGE, \"Clearing session from IndexedDB\");\n    const db = await this.getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(\"currentSession\");\n      request.onsuccess = () => {\n        debug.log(DebugCategory.STORAGE, \"Successfully cleared session from IndexedDB\");\n        resolve();\n      };\n      request.onerror = () => {\n        debug.error(DebugCategory.STORAGE, \"Failed to clear session from IndexedDB\", { error: request.error });\n        reject(request.error);\n      };\n    });\n  }\n  async getShouldClearPreviousSession() {\n    debug.log(DebugCategory.STORAGE, \"Getting shouldClearPreviousSession flag from IndexedDB\");\n    const db = await this.getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(\"shouldClearPreviousSession\");\n      request.onsuccess = () => {\n        const shouldClear = request.result ?? false;\n        debug.log(DebugCategory.STORAGE, \"Retrieved shouldClearPreviousSession flag from IndexedDB\", {\n          shouldClear\n        });\n        resolve(shouldClear);\n      };\n      request.onerror = () => {\n        debug.error(DebugCategory.STORAGE, \"Failed to get shouldClearPreviousSession flag from IndexedDB\", {\n          error: request.error\n        });\n        reject(request.error);\n      };\n    });\n  }\n  async setShouldClearPreviousSession(should) {\n    debug.log(DebugCategory.STORAGE, \"Setting shouldClearPreviousSession flag in IndexedDB\", { should });\n    const db = await this.getDB();\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put(should, \"shouldClearPreviousSession\");\n      request.onsuccess = () => {\n        debug.log(DebugCategory.STORAGE, \"Successfully set shouldClearPreviousSession flag in IndexedDB\");\n        resolve();\n      };\n      request.onerror = () => {\n        debug.error(DebugCategory.STORAGE, \"Failed to set shouldClearPreviousSession flag in IndexedDB\", {\n          error: request.error\n        });\n        reject(request.error);\n      };\n    });\n  }\n};\n\n// src/providers/embedded/adapters/url-params.ts\nvar BrowserURLParamsAccessor = class {\n  getParam(key) {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(key);\n  }\n};\nvar browserUrlParamsAccessor = new BrowserURLParamsAccessor();\n\n// src/providers/embedded/adapters/auth.ts\n\n\n// src/utils/browser-detection.ts\nfunction parseBrowserFromUserAgent(userAgent, hasBraveAPI) {\n  let name = \"unknown\";\n  let version = \"unknown\";\n  if (!userAgent || typeof userAgent !== \"string\") {\n    return { name, version, userAgent: \"unknown\" };\n  }\n  try {\n    if (userAgent.includes(\"Edg/\")) {\n      name = \"edge\";\n      const match = userAgent.match(/Edg\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"OPR/\") || userAgent.includes(\"Opera/\")) {\n      name = \"opera\";\n      const match = userAgent.match(/(?:OPR|Opera)\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"SamsungBrowser/\")) {\n      name = \"samsung\";\n      const match = userAgent.match(/SamsungBrowser\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"DuckDuckGo/\")) {\n      name = \"duckduckgo\";\n      const match = userAgent.match(/DuckDuckGo\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"Chrome/\") && hasBraveAPI) {\n      name = \"brave\";\n      const match = userAgent.match(/Chrome\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"Mobile/\") || userAgent.includes(\"Android\")) {\n      if (userAgent.includes(\"Chrome/\")) {\n        name = \"chrome-mobile\";\n        const match = userAgent.match(/Chrome\\/([0-9]+(?:\\.[0-9]+)*)/);\n        if (match)\n          version = match[1].split(\".\")[0];\n      } else if (userAgent.includes(\"Firefox/\")) {\n        name = \"firefox-mobile\";\n        const match = userAgent.match(/Firefox\\/([0-9]+(?:\\.[0-9]+)*)/);\n        if (match)\n          version = match[1].split(\".\")[0];\n      } else if (userAgent.includes(\"Safari/\") && userAgent.includes(\"Mobile/\")) {\n        name = \"safari-mobile\";\n        const match = userAgent.match(/Version\\/([0-9]+(?:\\.[0-9]+)*)/);\n        if (match)\n          version = match[1].split(\".\")[0];\n      } else {\n        name = \"mobile\";\n      }\n    } else if (userAgent.includes(\"Chrome/\")) {\n      name = \"chrome\";\n      const match = userAgent.match(/Chrome\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"Firefox/\")) {\n      name = \"firefox\";\n      const match = userAgent.match(/Firefox\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    } else if (userAgent.includes(\"Safari/\") && !userAgent.includes(\"Chrome/\")) {\n      name = \"safari\";\n      const match = userAgent.match(/Version\\/([0-9]+(?:\\.[0-9]+)*)/);\n      if (match)\n        version = match[1].split(\".\")[0];\n    }\n    if (name === \"unknown\") {\n      const patterns = [\n        { regex: /Chrome\\/([0-9]+)/, name: \"chrome\" },\n        { regex: /Firefox\\/([0-9]+)/, name: \"firefox\" },\n        { regex: /Safari\\/([0-9]+)/, name: \"safari\" },\n        { regex: /Edge\\/([0-9]+)/, name: \"edge\" },\n        { regex: /Opera\\/([0-9]+)/, name: \"opera\" }\n      ];\n      for (const pattern of patterns) {\n        const match = userAgent.match(pattern.regex);\n        if (match) {\n          name = pattern.name;\n          version = match[1];\n          break;\n        }\n      }\n    }\n  } catch (error) {\n  }\n  return { name, version, userAgent };\n}\nfunction detectBrowser() {\n  if (typeof window === \"undefined\" || !window.navigator?.userAgent) {\n    return { name: \"unknown\", version: \"unknown\", userAgent: \"unknown\" };\n  }\n  const userAgent = window.navigator.userAgent;\n  const hasBraveAPI = !!navigator.brave;\n  return parseBrowserFromUserAgent(userAgent, hasBraveAPI);\n}\nfunction getPlatformName() {\n  const { name, version } = detectBrowser();\n  return version !== \"unknown\" ? `${name}-v${version}` : name;\n}\nfunction getBrowserDisplayName() {\n  const { name, version } = detectBrowser();\n  const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n  return version !== \"unknown\" ? `${capitalizedName} ${version}` : capitalizedName;\n}\nfunction isMobileDevice() {\n  if (typeof window === \"undefined\" || !window.navigator?.userAgent) {\n    return false;\n  }\n  const userAgent = window.navigator.userAgent.toLowerCase();\n  const mobilePatterns = [\n    /android/,\n    /iphone|ipad|ipod/,\n    /blackberry/,\n    /windows phone/,\n    /mobile/,\n    /tablet/,\n    /silk/,\n    /kindle/,\n    /opera mini/,\n    /opera mobi/\n  ];\n  const isMobileUA = mobilePatterns.some((pattern) => pattern.test(userAgent));\n  let isSmallScreen = false;\n  try {\n    isSmallScreen = window.screen.width <= 768 || window.screen.height <= 768;\n  } catch (error) {\n    isSmallScreen = false;\n  }\n  let isTouchDevice = false;\n  try {\n    isTouchDevice = \"ontouchstart\" in window || navigator.maxTouchPoints > 0;\n  } catch (error) {\n    isTouchDevice = false;\n  }\n  return isMobileUA || isSmallScreen && isTouchDevice;\n}\n\n// src/providers/embedded/adapters/auth.ts\nvar BrowserAuthProvider = class {\n  constructor(urlParamsAccessor) {\n    this.urlParamsAccessor = urlParamsAccessor;\n  }\n  getValidatedCurrentUrl() {\n    const currentUrl = window.location.href;\n    if (!currentUrl.startsWith(\"http:\") && !currentUrl.startsWith(\"https:\")) {\n      throw new Error(\"Invalid URL protocol - only HTTP/HTTPS URLs are supported\");\n    }\n    return currentUrl;\n  }\n  authenticate(options) {\n    return new Promise((resolve) => {\n      if (\"jwtToken\" in options) {\n        throw new Error(\"JWT authentication should be handled by the core JWTAuth class\");\n      }\n      const phantomOptions = options;\n      debug.info(DebugCategory.PHANTOM_CONNECT_AUTH, \"Starting Phantom Connect authentication\", {\n        publicKey: phantomOptions.publicKey,\n        appId: phantomOptions.appId,\n        provider: phantomOptions.provider,\n        authUrl: phantomOptions.authUrl\n      });\n      const baseUrl = phantomOptions.authUrl || _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_AUTH_URL;\n      debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"Using auth URL\", { baseUrl });\n      const params = new URLSearchParams({\n        public_key: phantomOptions.publicKey,\n        app_id: phantomOptions.appId,\n        redirect_uri: phantomOptions.redirectUrl || (typeof window !== \"undefined\" ? this.getValidatedCurrentUrl() : \"\"),\n        session_id: phantomOptions.sessionId,\n        // OAuth session management - defaults to allow refresh unless explicitly clearing after logout\n        clear_previous_session: (phantomOptions.clearPreviousSession ?? false).toString(),\n        allow_refresh: (phantomOptions.allowRefresh ?? true).toString(),\n        sdk_version: \"1.0.2\",\n        sdk_type: \"browser\",\n        platform: detectBrowser().name\n      });\n      if (phantomOptions.provider) {\n        debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"Provider specified, will skip selection\", {\n          provider: phantomOptions.provider\n        });\n        params.append(\"provider\", phantomOptions.provider);\n      } else {\n        debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"No provider specified, defaulting to Google\");\n        params.append(\"provider\", \"google\");\n      }\n      const authContext = {\n        publicKey: phantomOptions.publicKey,\n        appId: phantomOptions.appId,\n        provider: phantomOptions.provider,\n        sessionId: phantomOptions.sessionId\n      };\n      sessionStorage.setItem(\"phantom-auth-context\", JSON.stringify(authContext));\n      debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"Stored auth context in session storage\", { authContext });\n      const authUrl = `${baseUrl}?${params.toString()}`;\n      debug.info(DebugCategory.PHANTOM_CONNECT_AUTH, \"Redirecting to Phantom Connect\", { authUrl });\n      if (!authUrl.startsWith(\"https:\") && !authUrl.startsWith(\"http://localhost\")) {\n        throw new Error(\"Invalid auth URL - only HTTPS URLs are allowed for authentication\");\n      }\n      window.location.href = authUrl;\n      resolve();\n    });\n  }\n  resumeAuthFromRedirect(provider) {\n    try {\n      const walletId = this.urlParamsAccessor.getParam(\"wallet_id\");\n      const sessionId = this.urlParamsAccessor.getParam(\"session_id\");\n      const accountDerivationIndex = this.urlParamsAccessor.getParam(\"selected_account_index\");\n      const error = this.urlParamsAccessor.getParam(\"error\");\n      const errorDescription = this.urlParamsAccessor.getParam(\"error_description\");\n      if (error) {\n        const errorMsg = errorDescription || error;\n        switch (error) {\n          case \"access_denied\":\n            throw new Error(`Authentication cancelled: ${errorMsg}`);\n          case \"invalid_request\":\n            throw new Error(`Invalid authentication request: ${errorMsg}`);\n          case \"server_error\":\n            throw new Error(`Authentication server error: ${errorMsg}`);\n          case \"temporarily_unavailable\":\n            throw new Error(`Authentication service temporarily unavailable: ${errorMsg}`);\n          default:\n            throw new Error(`Authentication failed: ${errorMsg}`);\n        }\n      }\n      if (!walletId || !sessionId) {\n        debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"Missing auth parameters in URL\", {\n          hasWalletId: !!walletId,\n          hasSessionId: !!sessionId\n        });\n        return null;\n      }\n      const contextStr = sessionStorage.getItem(\"phantom-auth-context\");\n      let context = {};\n      if (contextStr) {\n        try {\n          context = JSON.parse(contextStr);\n        } catch (parseError) {\n          debug.warn(DebugCategory.PHANTOM_CONNECT_AUTH, \"Failed to parse stored auth context\", { error: parseError });\n        }\n      }\n      if (context.sessionId && sessionId !== context.sessionId) {\n        debug.error(DebugCategory.PHANTOM_CONNECT_AUTH, \"Session ID mismatch\", {\n          urlSessionId: sessionId,\n          storedSessionId: context.sessionId\n        });\n        throw new Error(\"Session ID mismatch - possible session corruption or replay attack\");\n      }\n      sessionStorage.removeItem(\"phantom-auth-context\");\n      debug.info(DebugCategory.PHANTOM_CONNECT_AUTH, \"Successfully resumed auth from redirect\", {\n        walletId,\n        sessionId,\n        accountDerivationIndex: accountDerivationIndex ? parseInt(accountDerivationIndex) : void 0\n      });\n      const organizationId = this.urlParamsAccessor.getParam(\"organization_id\");\n      const expiresInMs = this.urlParamsAccessor.getParam(\"expires_in_ms\");\n      const authUserId = this.urlParamsAccessor.getParam(\"auth_user_id\");\n      debug.log(DebugCategory.PHANTOM_CONNECT_AUTH, \"Auth redirect parameters\", {\n        walletId,\n        organizationId,\n        sessionId,\n        accountDerivationIndex,\n        expiresInMs,\n        authUserId\n      });\n      if (!organizationId) {\n        debug.error(DebugCategory.PHANTOM_CONNECT_AUTH, \"Missing organization_id in auth response\");\n        throw new Error(\"Missing organization_id in auth response\");\n      }\n      if (organizationId.startsWith(\"temp-\")) {\n        debug.warn(\n          DebugCategory.PHANTOM_CONNECT_AUTH,\n          \"Received temporary organization_id, server may not be configured properly\",\n          {\n            organizationId\n          }\n        );\n      }\n      return {\n        walletId,\n        organizationId,\n        accountDerivationIndex: accountDerivationIndex ? parseInt(accountDerivationIndex) : 0,\n        expiresInMs: expiresInMs ? parseInt(expiresInMs) : 0,\n        authUserId: authUserId || void 0,\n        provider\n      };\n    } catch (error) {\n      sessionStorage.removeItem(\"phantom-auth-context\");\n      throw error;\n    }\n  }\n};\n\n// src/providers/embedded/adapters/phantom-app.ts\n\n\n// src/isPhantomLoginAvailable.ts\n\nasync function isPhantomLoginAvailable(timeoutMs = 3e3) {\n  const extensionInstalled = await waitForExtension(timeoutMs);\n  if (!extensionInstalled) {\n    return false;\n  }\n  try {\n    if (!window.phantom?.app?.features || typeof window.phantom.app.features !== \"function\") {\n      return false;\n    }\n    const response = await window.phantom.app.features();\n    if (!Array.isArray(response.features)) {\n      return false;\n    }\n    return response.features.includes(\"phantom_login\");\n  } catch (error) {\n    console.error(\"Error checking Phantom extension features\", error);\n    return false;\n  }\n}\nasync function waitForExtension(timeoutMs) {\n  return new Promise((resolve) => {\n    const startTime = Date.now();\n    const checkInterval = 100;\n    const checkForExtension = () => {\n      try {\n        if ((0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.isPhantomExtensionInstalled)()) {\n          resolve(true);\n          return;\n        }\n      } catch (error) {\n      }\n      const elapsed = Date.now() - startTime;\n      if (elapsed >= timeoutMs) {\n        resolve(false);\n        return;\n      }\n      setTimeout(checkForExtension, checkInterval);\n    };\n    checkForExtension();\n  });\n}\n\n// src/providers/embedded/adapters/phantom-app.ts\nvar BrowserPhantomAppProvider = class {\n  /**\n   * Check if the Phantom extension is installed in the browser\n   */\n  isAvailable() {\n    return (0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.isPhantomExtensionInstalled)();\n  }\n  /**\n   * Authenticate using the Phantom browser extension\n   */\n  async authenticate(options) {\n    if (!this.isAvailable()) {\n      throw new Error(\n        \"Phantom extension is not installed. Please install the Phantom browser extension to use this authentication method.\"\n      );\n    }\n    const loginAvailable = await isPhantomLoginAvailable();\n    if (!loginAvailable) {\n      throw new Error(\n        \"Phantom Login is not available. Please update your Phantom extension to use this authentication method.\"\n      );\n    }\n    try {\n      if (!window.phantom?.app?.login) {\n        throw new Error(\"Phantom extension login method not found\");\n      }\n      const result = await window.phantom.app.login({\n        publicKey: options.publicKey,\n        appId: options.appId,\n        sessionId: options.sessionId\n      });\n      if (!result || !result.walletId || !result.organizationId) {\n        throw new Error(\"Invalid authentication response from Phantom extension\");\n      }\n      return {\n        walletId: result.walletId,\n        organizationId: result.organizationId,\n        provider: \"phantom\",\n        accountDerivationIndex: result.accountDerivationIndex ?? 0,\n        expiresInMs: result.expiresInMs ?? 0,\n        authUserId: result.authUserId\n      };\n    } catch (error) {\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(`Phantom extension authentication failed: ${String(error)}`);\n    }\n  }\n};\n\n// src/providers/embedded/adapters/logger.ts\nvar BrowserLogger = class {\n  info(category, message, data) {\n    debug.info(category, message, data);\n  }\n  warn(category, message, data) {\n    debug.warn(category, message, data);\n  }\n  error(category, message, data) {\n    debug.error(category, message, data);\n  }\n  log(category, message, data) {\n    debug.log(category, message, data);\n  }\n};\n\n// src/providers/embedded/index.ts\n\nvar EmbeddedProvider = class extends _phantom_embedded_provider_core__WEBPACK_IMPORTED_MODULE_9__.EmbeddedProvider {\n  constructor(config) {\n    debug.log(DebugCategory.EMBEDDED_PROVIDER, \"Initializing Browser EmbeddedProvider\", { config });\n    const urlParamsAccessor = new BrowserURLParamsAccessor();\n    const stamper = new _phantom_indexed_db_stamper__WEBPACK_IMPORTED_MODULE_10__.IndexedDbStamper({\n      dbName: `phantom-embedded-sdk-${config.appId}`,\n      storeName: \"crypto-keys\",\n      keyName: \"signing-key\"\n    });\n    const platformName = getPlatformName();\n    const { name: browserName, version } = detectBrowser();\n    const platform = {\n      storage: new BrowserStorage(),\n      authProvider: new BrowserAuthProvider(urlParamsAccessor),\n      phantomAppProvider: new BrowserPhantomAppProvider(),\n      urlParamsAccessor,\n      stamper,\n      name: platformName,\n      // Use detected browser name and version for identification\n      analyticsHeaders: {\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.SDK_TYPE]: \"browser\",\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.PLATFORM]: browserName,\n        // firefox, chrome, safari, etc.\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.PLATFORM_VERSION]: version,\n        // Full user agent for more detailed info\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.APP_ID]: config.appId,\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.WALLET_TYPE]: config.embeddedWalletType,\n        [_phantom_constants__WEBPACK_IMPORTED_MODULE_11__.ANALYTICS_HEADERS.SDK_VERSION]: \"1.0.2\"\n        // Replaced at build time\n      }\n    };\n    debug.log(DebugCategory.EMBEDDED_PROVIDER, \"Detected platform\", { platformName });\n    const logger = new BrowserLogger();\n    super(config, platform, logger);\n    this.addressTypes = config.addressTypes;\n    debug.info(DebugCategory.EMBEDDED_PROVIDER, \"Browser EmbeddedProvider initialized\");\n  }\n  getEnabledAddressTypes() {\n    return this.addressTypes;\n  }\n};\n\n// src/ProviderManager.ts\n\n\n\n// src/utils/auth-callback.ts\nfunction isAuthFailureCallback(searchParams) {\n  if (typeof window === \"undefined\" && !searchParams)\n    return false;\n  const params = searchParams || new URLSearchParams(window.location.search);\n  const responseType = params.get(\"response_type\");\n  const sessionId = params.get(\"session_id\");\n  return responseType === \"failure\" && !!sessionId;\n}\nfunction isAuthCallbackUrl(searchParams) {\n  if (typeof window === \"undefined\" && !searchParams)\n    return false;\n  const params = searchParams || new URLSearchParams(window.location.search);\n  const sessionId = params.get(\"session_id\");\n  return !!(sessionId && (params.has(\"response_type\") || params.has(\"wallet_id\")));\n}\n\n// src/utils/deeplink.ts\nfunction getDeeplinkToPhantom(ref) {\n  if (!window.location.href.startsWith(\"http:\") && !window.location.href.startsWith(\"https:\")) {\n    throw new Error(\"Invalid URL protocol - only HTTP/HTTPS URLs are supported for deeplinks\");\n  }\n  const currentUrl = encodeURIComponent(window.location.href);\n  const refParam = ref ? `?ref=${encodeURIComponent(ref)}` : \"\";\n  return `https://phantom.app/ul/browse/${currentUrl}${refParam}`;\n}\n\n// src/ProviderManager.ts\nvar ProviderManager = class {\n  // Track which providers have forwarding set up\n  constructor(config) {\n    this.providers = /* @__PURE__ */ new Map();\n    this.currentProvider = null;\n    this.currentProviderKey = null;\n    // Event management for forwarding provider events\n    this.eventListeners = /* @__PURE__ */ new Map();\n    this.providerForwardingSetup = /* @__PURE__ */ new WeakSet();\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Initializing ProviderManager\", { config });\n    this.config = config;\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Setting default provider\");\n    this.setDefaultProvider();\n    debug.info(DebugCategory.PROVIDER_MANAGER, \"ProviderManager initialized\", {\n      currentProviderKey: this.currentProviderKey\n    });\n  }\n  getValidatedCurrentUrl() {\n    if (typeof window === \"undefined\")\n      return \"\";\n    const currentUrl = window.location.href;\n    if (!currentUrl.startsWith(\"http:\") && !currentUrl.startsWith(\"https:\")) {\n      throw new Error(\"Invalid URL protocol - only HTTP/HTTPS URLs are supported\");\n    }\n    return currentUrl;\n  }\n  /**\n   * Switch to a different provider type\n   */\n  switchProvider(type, options) {\n    if (options?.embeddedWalletType && ![\"app-wallet\", \"user-wallet\"].includes(options.embeddedWalletType)) {\n      throw new Error(\n        `Invalid embeddedWalletType: ${options.embeddedWalletType}. Must be \"app-wallet\" or \"user-wallet\".`\n      );\n    }\n    const key = this.getProviderKey(type, options?.embeddedWalletType);\n    if (!this.providers.has(key)) {\n      this.createProvider(type, options?.embeddedWalletType);\n    }\n    this.currentProvider = this.providers.get(key);\n    this.currentProviderKey = key;\n    this.ensureProviderEventForwarding();\n    return this.currentProvider;\n  }\n  /**\n   * Get the current active provider\n   */\n  getCurrentProvider() {\n    return this.currentProvider;\n  }\n  /**\n   * Get current provider type and options\n   */\n  getCurrentProviderInfo() {\n    if (!this.currentProviderKey)\n      return null;\n    const parts = this.currentProviderKey.split(\"-\");\n    const [type, embeddedWalletType] = parts;\n    return {\n      type,\n      embeddedWalletType\n    };\n  }\n  /**\n   * Check if a provider is allowed by the config\n   */\n  isProviderAllowed(provider) {\n    return this.config.providers.includes(provider);\n  }\n  /**\n   * Connect using the current provider\n   * Automatically switches provider based on authOptions.provider\n   */\n  async connect(authOptions) {\n    debug.info(DebugCategory.PROVIDER_MANAGER, \"Starting connection\", {\n      currentProviderKey: this.currentProviderKey,\n      authOptions: { provider: authOptions.provider }\n    });\n    if (!this.isProviderAllowed(authOptions.provider)) {\n      const error = `Provider \"${authOptions.provider}\" is not in the allowed providers list: ${JSON.stringify(this.config.providers)}`;\n      debug.error(DebugCategory.PROVIDER_MANAGER, error);\n      throw new Error(error);\n    }\n    const requestedProvider = authOptions.provider;\n    let targetProviderType = null;\n    if (requestedProvider === \"injected\") {\n      targetProviderType = \"injected\";\n    } else if (requestedProvider === \"deeplink\") {\n      try {\n        const deeplinkUrl = getDeeplinkToPhantom();\n        if (typeof window !== \"undefined\") {\n          window.location.href = deeplinkUrl;\n        }\n        return {\n          addresses: [],\n          walletId: void 0,\n          authUserId: void 0\n        };\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : \"Failed to open deeplink\";\n        debug.error(DebugCategory.PROVIDER_MANAGER, \"Deeplink error\", { error: errorMessage });\n        throw new Error(`Failed to open deeplink: ${errorMessage}`);\n      }\n    } else if (_phantom_embedded_provider_core__WEBPACK_IMPORTED_MODULE_9__.EMBEDDED_PROVIDER_AUTH_TYPES.includes(requestedProvider)) {\n      targetProviderType = \"embedded\";\n    }\n    if (targetProviderType) {\n      const currentInfo = this.getCurrentProviderInfo();\n      if (currentInfo?.type !== targetProviderType) {\n        debug.log(DebugCategory.PROVIDER_MANAGER, \"Auto-switching provider based on auth options\", {\n          from: currentInfo?.type,\n          to: targetProviderType,\n          requestedProvider\n        });\n        const switchOptions = {};\n        if (targetProviderType === \"embedded\") {\n          switchOptions.embeddedWalletType = currentInfo?.embeddedWalletType || this.config.embeddedWalletType;\n        }\n        this.switchProvider(targetProviderType, switchOptions);\n      }\n    }\n    if (!this.currentProvider) {\n      debug.error(DebugCategory.PROVIDER_MANAGER, \"No provider selected\");\n      throw new Error(\"No provider selected\");\n    }\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Delegating to provider connect method\");\n    const result = await this.currentProvider.connect(authOptions);\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Connection successful, saving preferences\", {\n      addressCount: result.addresses?.length || 0,\n      provider: authOptions.provider\n    });\n    this.saveProviderPreference();\n    debug.info(DebugCategory.PROVIDER_MANAGER, \"Connect completed\", {\n      addresses: result.addresses,\n      provider: authOptions.provider\n    });\n    return result;\n  }\n  /**\n   * Disconnect from current provider\n   */\n  async disconnect() {\n    if (!this.currentProvider)\n      return;\n    await this.currentProvider.disconnect();\n  }\n  /**\n   * Get addresses from current provider\n   */\n  getAddresses() {\n    if (!this.currentProvider) {\n      return [];\n    }\n    return this.currentProvider.getAddresses();\n  }\n  /**\n   * Check if current provider is connected\n   */\n  isConnected() {\n    return this.currentProvider?.isConnected() ?? false;\n  }\n  /**\n   * Attempt auto-connect with fallback strategy\n   * Tries embedded provider first if it exists and is allowed, then injected provider if allowed\n   * Returns true if any provider successfully connected\n   */\n  async autoConnect() {\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Starting auto-connect with fallback strategy\");\n    if (isAuthFailureCallback()) {\n      debug.warn(DebugCategory.PROVIDER_MANAGER, \"Auth failure detected in URL, skipping autoConnect fallback\");\n      return false;\n    }\n    const embeddedWalletType = this.config.embeddedWalletType || \"user-wallet\";\n    const embeddedKey = this.getProviderKey(\"embedded\", embeddedWalletType);\n    const embeddedAllowed = this.config.providers.some((p) => p !== \"injected\");\n    if (embeddedAllowed && this.providers.has(embeddedKey)) {\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Trying auto-connect with existing embedded provider\");\n      const embeddedProvider = this.providers.get(embeddedKey);\n      try {\n        const previousProvider = this.currentProvider;\n        const previousKey = this.currentProviderKey;\n        this.currentProvider = embeddedProvider;\n        this.currentProviderKey = embeddedKey;\n        this.ensureProviderEventForwarding();\n        await embeddedProvider.autoConnect();\n        if (embeddedProvider.isConnected()) {\n          debug.info(DebugCategory.PROVIDER_MANAGER, \"Embedded auto-connect successful\");\n          this.saveProviderPreference();\n          return true;\n        } else {\n          debug.log(DebugCategory.PROVIDER_MANAGER, \"Embedded provider did not connect, restoring previous provider\");\n          this.currentProvider = previousProvider;\n          this.currentProviderKey = previousKey;\n        }\n      } catch (error) {\n        debug.log(DebugCategory.PROVIDER_MANAGER, \"Embedded auto-connect failed\", {\n          error: error.message\n        });\n        if (isAuthCallbackUrl()) {\n          debug.log(DebugCategory.PROVIDER_MANAGER, \"In auth callback URL, not attempting injected fallback\");\n          return false;\n        }\n      }\n    }\n    const injectedAllowed = this.config.providers.includes(\"injected\");\n    const injectedKey = this.getProviderKey(\"injected\");\n    if (injectedAllowed && this.providers.has(injectedKey)) {\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Trying auto-connect with existing injected provider\");\n      const injectedProvider = this.providers.get(injectedKey);\n      try {\n        this.currentProvider = injectedProvider;\n        this.currentProviderKey = injectedKey;\n        this.ensureProviderEventForwarding();\n        await injectedProvider.autoConnect();\n        if (injectedProvider.isConnected()) {\n          debug.info(DebugCategory.PROVIDER_MANAGER, \"Injected auto-connect successful\");\n          this.saveProviderPreference();\n          return true;\n        }\n      } catch (error) {\n        debug.log(DebugCategory.PROVIDER_MANAGER, \"Injected auto-connect failed\", {\n          error: error.message\n        });\n      }\n    }\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Auto-connect failed for all allowed providers\");\n    return false;\n  }\n  /**\n   * Add event listener - stores callback and ensures current provider forwards events to ProviderManager\n   */\n  on(event, callback) {\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Adding event listener\", { event });\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventListeners.get(event)?.add(callback);\n    this.ensureProviderEventForwarding();\n  }\n  /**\n   * Remove event listener\n   */\n  off(event, callback) {\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Removing event listener\", { event });\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event)?.delete(callback);\n      if (this.eventListeners.get(event)?.size === 0) {\n        this.eventListeners.delete(event);\n      }\n    }\n  }\n  /**\n   * Emit event to all registered callbacks\n   */\n  emit(event, data) {\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Emitting event to stored callbacks\", {\n      event,\n      listenerCount: this.eventListeners.get(event)?.size || 0,\n      data\n    });\n    const listeners = this.eventListeners.get(event);\n    if (listeners && listeners.size > 0) {\n      listeners.forEach((callback) => {\n        try {\n          debug.log(DebugCategory.PROVIDER_MANAGER, \"Calling stored callback for event\", { event });\n          callback(data);\n        } catch (error) {\n          debug.error(DebugCategory.PROVIDER_MANAGER, \"Event callback error\", { event, error });\n        }\n      });\n    } else {\n      debug.warn(DebugCategory.PROVIDER_MANAGER, \"No stored callbacks for event\", { event });\n    }\n  }\n  /**\n   * Ensure current provider forwards its events to this ProviderManager\n   * Only sets up forwarding once per provider instance to avoid accumulation\n   */\n  ensureProviderEventForwarding() {\n    if (!this.currentProvider || !(\"on\" in this.currentProvider)) {\n      debug.warn(DebugCategory.PROVIDER_MANAGER, \"Current provider does not support events\", {\n        providerType: this.getCurrentProviderInfo()?.type\n      });\n      return;\n    }\n    if (this.providerForwardingSetup.has(this.currentProvider)) {\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Event forwarding already set up for current provider\");\n      return;\n    }\n    debug.log(DebugCategory.PROVIDER_MANAGER, \"Setting up event forwarding from current provider\");\n    const eventsToForward = [\n      \"connect_start\",\n      \"connect\",\n      \"connect_error\",\n      \"disconnect\",\n      \"error\",\n      \"spending_limit_reached\"\n    ];\n    for (const event of eventsToForward) {\n      const forwardingCallback = (data) => {\n        debug.log(DebugCategory.PROVIDER_MANAGER, \"Forwarding event from provider\", { event, data });\n        this.emit(event, data);\n      };\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Attaching forwarding callback for event\", { event });\n      this.currentProvider.on(event, forwardingCallback);\n    }\n    this.providerForwardingSetup.add(this.currentProvider);\n  }\n  /**\n   * Set default provider based on initial config\n   * Creates providers based on the allowed providers array\n   */\n  setDefaultProvider() {\n    const defaultEmbeddedType = this.config.embeddedWalletType || \"user-wallet\";\n    const hasInjected = this.config.providers.includes(\"injected\");\n    const hasEmbedded = this.config.providers.some((p) => p !== \"injected\" && p !== \"deeplink\");\n    if (hasInjected) {\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Creating injected provider (allowed by providers array)\");\n      this.createProvider(\"injected\");\n    }\n    if (hasEmbedded) {\n      debug.log(DebugCategory.PROVIDER_MANAGER, \"Creating embedded provider (allowed by providers array)\");\n      this.createProvider(\"embedded\", defaultEmbeddedType);\n    }\n    let defaultType;\n    if (hasEmbedded && this.providers.has(`embedded-${defaultEmbeddedType}`)) {\n      defaultType = \"embedded\";\n    } else if (hasInjected && this.providers.has(\"injected\")) {\n      defaultType = \"injected\";\n    } else {\n      throw new Error(\"No valid providers could be created from the providers array\");\n    }\n    const switchOptions = {};\n    if (defaultType === \"embedded\") {\n      switchOptions.embeddedWalletType = defaultEmbeddedType;\n    }\n    this.switchProvider(defaultType, switchOptions);\n  }\n  /**\n   * Create a provider instance\n   */\n  createProvider(type, embeddedWalletType) {\n    const key = this.getProviderKey(type, embeddedWalletType);\n    if (this.providers.has(key))\n      return;\n    let provider;\n    if (type === \"injected\") {\n      provider = new InjectedProvider({\n        addressTypes: this.config.addressTypes || [_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana]\n      });\n    } else if (type === \"embedded\") {\n      if (!this.config.appId) {\n        throw new Error(\"appId is required for embedded provider\");\n      }\n      const apiBaseUrl = this.config.apiBaseUrl || _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_WALLET_API_URL;\n      const authUrl = this.config.authOptions?.authUrl || _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_AUTH_URL;\n      provider = new EmbeddedProvider({\n        apiBaseUrl,\n        appId: this.config.appId,\n        authOptions: {\n          ...this.config.authOptions || {},\n          authUrl,\n          redirectUrl: this.config.authOptions?.redirectUrl || this.getValidatedCurrentUrl()\n        },\n        embeddedWalletType: embeddedWalletType || _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_EMBEDDED_WALLET_TYPE,\n        addressTypes: this.config.addressTypes || [_phantom_client__WEBPACK_IMPORTED_MODULE_0__.AddressType.solana]\n      });\n    } else {\n      throw new Error(`Unsupported provider type: ${type}`);\n    }\n    this.providers.set(key, provider);\n  }\n  /**\n   * Generate a unique key for provider instances\n   */\n  getProviderKey(type, embeddedWalletType) {\n    if (type === \"injected\") {\n      return \"injected\";\n    } else if (type === \"embedded\") {\n      return `embedded-${embeddedWalletType || \"app-wallet\"}`;\n    }\n    throw new Error(`Unsupported provider type: ${type}`);\n  }\n  /**\n   * Save provider preference to localStorage\n   */\n  saveProviderPreference() {\n    try {\n      const preference = this.getCurrentProviderInfo();\n      if (preference) {\n        localStorage.setItem(\"phantom-provider-preference\", JSON.stringify(preference));\n      }\n    } catch (error) {\n      console.error(\"Failed to save provider preference:\", error);\n    }\n  }\n};\n\n// src/BrowserSDK.ts\n\n\nvar BROWSER_SDK_PROVIDER_TYPES = [\n  ..._phantom_embedded_provider_core__WEBPACK_IMPORTED_MODULE_9__.EMBEDDED_PROVIDER_AUTH_TYPES,\n  \"injected\",\n  \"deeplink\"\n];\nvar BrowserSDK = class {\n  constructor(config) {\n    this.walletRegistry = getWalletRegistry();\n    this.isLoading = true;\n    debug.info(DebugCategory.BROWSER_SDK, \"Initializing BrowserSDK\", {\n      providers: config.providers,\n      embeddedWalletType: config.embeddedWalletType,\n      addressTypes: config.addressTypes\n    });\n    if (!Array.isArray(config.providers) || config.providers.length === 0) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Invalid providers array\", { providers: config.providers });\n      throw new Error(\"providers must be a non-empty array of AuthProviderType\");\n    }\n    const invalidProviders = config.providers.filter((p) => !BROWSER_SDK_PROVIDER_TYPES.includes(p));\n    if (invalidProviders.length > 0) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Invalid provider types\", {\n        invalidProviders,\n        validProviders: BROWSER_SDK_PROVIDER_TYPES\n      });\n      throw new Error(\n        `Invalid provider type(s): ${invalidProviders.join(\", \")}. Valid providers are: ${BROWSER_SDK_PROVIDER_TYPES.join(\", \")}`\n      );\n    }\n    const hasEmbeddedProviders = config.providers.some((p) => p !== \"injected\");\n    if (hasEmbeddedProviders && !config.appId) {\n      debug.error(DebugCategory.BROWSER_SDK, \"appId required for embedded providers\", {\n        providers: config.providers\n      });\n      throw new Error(\"appId is required when using embedded providers (google, apple, phantom, etc.)\");\n    }\n    const embeddedWalletType = config.embeddedWalletType || _phantom_constants__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_EMBEDDED_WALLET_TYPE;\n    if (![\"app-wallet\", \"user-wallet\"].includes(embeddedWalletType)) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Invalid embeddedWalletType\", {\n        embeddedWalletType: config.embeddedWalletType\n      });\n      throw new Error(\n        `Invalid embeddedWalletType: ${config.embeddedWalletType}. Must be \"app-wallet\" or \"user-wallet\".`\n      );\n    }\n    this.config = config;\n    this.providerManager = new ProviderManager(config);\n    void this.discoverWallets();\n  }\n  discoverWallets() {\n    return this.walletRegistry.discover(this.config.addressTypes).finally(() => {\n      this.isLoading = false;\n    });\n  }\n  // ===== CHAIN API =====\n  /**\n   * Access Solana chain operations\n   */\n  get solana() {\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    return currentProvider.solana;\n  }\n  /**\n   * Access Ethereum chain operations\n   */\n  get ethereum() {\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    return currentProvider.ethereum;\n  }\n  // ===== CONNECTION MANAGEMENT =====\n  /**\n   * Connect to the wallet\n   */\n  async connect(options) {\n    debug.info(DebugCategory.BROWSER_SDK, \"Starting connection\", options);\n    try {\n      const result = await this.providerManager.connect(options);\n      debug.info(DebugCategory.BROWSER_SDK, \"Connection successful\", {\n        addressCount: result.addresses.length,\n        status: result.status\n      });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Connection failed\", { error: error.message });\n      throw error;\n    }\n  }\n  /**\n   * Disconnect from the wallet\n   */\n  async disconnect() {\n    debug.info(DebugCategory.BROWSER_SDK, \"Disconnecting\");\n    try {\n      await this.providerManager.disconnect();\n      debug.info(DebugCategory.BROWSER_SDK, \"Disconnection successful\");\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Disconnection failed\", { error: error.message });\n      throw error;\n    }\n  }\n  // ===== STATE QUERIES =====\n  /**\n   * Check if the SDK is connected to a wallet\n   */\n  isConnected() {\n    return this.providerManager.isConnected();\n  }\n  /**\n   * Get all connected wallet addresses\n   */\n  getAddresses() {\n    return this.providerManager.getAddresses();\n  }\n  /**\n   * Get information about the current provider\n   */\n  getCurrentProviderInfo() {\n    return this.providerManager.getCurrentProviderInfo();\n  }\n  /**\n   * Get enabled address types for the current provider\n   * - For embedded provider: returns config.addressTypes\n   * - For Phantom injected: returns config.addressTypes\n   * - For discovered wallets: returns the wallet's addressTypes from registry\n   */\n  getEnabledAddressTypes() {\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      return [];\n    }\n    return currentProvider.getEnabledAddressTypes();\n  }\n  // ===== UTILITY METHODS =====\n  /**\n   * Add event listener for provider events (connect, connect_start, connect_error, disconnect, error)\n   * Works with both embedded and injected providers\n   */\n  on(event, callback) {\n    debug.log(DebugCategory.BROWSER_SDK, \"Adding event listener\", { event });\n    this.providerManager.on(event, callback);\n  }\n  /**\n   * Remove event listener for provider events\n   * Works with both embedded and injected providers\n   */\n  off(event, callback) {\n    debug.log(DebugCategory.BROWSER_SDK, \"Removing event listener\", { event });\n    this.providerManager.off(event, callback);\n  }\n  /**\n   * Attempt auto-connection using existing session\n   * Should be called after setting up event listeners\n   * Tries embedded provider first, then injected provider as fallback\n   */\n  async autoConnect() {\n    debug.log(DebugCategory.BROWSER_SDK, \"Attempting auto-connect with fallback strategy\");\n    const result = await this.providerManager.autoConnect();\n    if (result) {\n      debug.info(DebugCategory.BROWSER_SDK, \"Auto-connect successful\", {\n        providerType: this.getCurrentProviderInfo()?.type\n      });\n    } else {\n      debug.log(DebugCategory.BROWSER_SDK, \"Auto-connect failed for all providers\");\n    }\n  }\n  enableDebug() {\n    debug.enable();\n    debug.info(DebugCategory.BROWSER_SDK, \"Debug logging enabled\");\n  }\n  disableDebug() {\n    debug.disable();\n  }\n  setDebugLevel(level) {\n    debug.setLevel(level);\n    debug.info(DebugCategory.BROWSER_SDK, \"Debug level updated\", { level });\n  }\n  setDebugCallback(callback) {\n    debug.setCallback(callback);\n    debug.info(DebugCategory.BROWSER_SDK, \"Debug callback updated\");\n  }\n  configureDebug(config) {\n    if (config.enabled !== void 0) {\n      if (config.enabled) {\n        this.enableDebug();\n      } else {\n        this.disableDebug();\n      }\n    }\n    if (config.level !== void 0) {\n      this.setDebugLevel(config.level);\n    }\n    if (config.callback !== void 0) {\n      this.setDebugCallback(config.callback);\n    }\n  }\n  // ===== AUTO-CONFIRM METHODS (Injected Provider Only) =====\n  /**\n   * Enable auto-confirm for transactions\n   * Only available for injected providers\n   */\n  async enableAutoConfirm(params) {\n    debug.info(DebugCategory.BROWSER_SDK, \"Enabling auto-confirm\", { params });\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    if (!(\"enableAutoConfirm\" in currentProvider)) {\n      throw new Error(\"Auto-confirm is only available for injected providers\");\n    }\n    try {\n      const result = await currentProvider.enableAutoConfirm(params);\n      debug.info(DebugCategory.BROWSER_SDK, \"Auto-confirm enabled successfully\", { result });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Failed to enable auto-confirm\", { error: error.message });\n      throw error;\n    }\n  }\n  /**\n   * Disable auto-confirm for transactions\n   * Only available for injected providers\n   */\n  async disableAutoConfirm() {\n    debug.info(DebugCategory.BROWSER_SDK, \"Disabling auto-confirm\");\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    if (!(\"disableAutoConfirm\" in currentProvider)) {\n      throw new Error(\"Auto-confirm is only available for injected providers\");\n    }\n    try {\n      await currentProvider.disableAutoConfirm();\n      debug.info(DebugCategory.BROWSER_SDK, \"Auto-confirm disabled successfully\");\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Failed to disable auto-confirm\", { error: error.message });\n      throw error;\n    }\n  }\n  /**\n   * Get current auto-confirm status\n   * Only available for injected providers\n   */\n  async getAutoConfirmStatus() {\n    debug.info(DebugCategory.BROWSER_SDK, \"Getting auto-confirm status\");\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    if (!(\"getAutoConfirmStatus\" in currentProvider)) {\n      throw new Error(\"Auto-confirm is only available for injected providers\");\n    }\n    try {\n      const result = await currentProvider.getAutoConfirmStatus();\n      debug.info(DebugCategory.BROWSER_SDK, \"Got auto-confirm status\", { result });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Failed to get auto-confirm status\", { error: error.message });\n      throw error;\n    }\n  }\n  /**\n   * Get supported chains for auto-confirm\n   * Only available for injected providers\n   */\n  async getSupportedAutoConfirmChains() {\n    debug.info(DebugCategory.BROWSER_SDK, \"Getting supported auto-confirm chains\");\n    const currentProvider = this.providerManager.getCurrentProvider();\n    if (!currentProvider) {\n      throw new Error(\"No provider available. Call connect() first.\");\n    }\n    if (!(\"getSupportedAutoConfirmChains\" in currentProvider)) {\n      throw new Error(\"Auto-confirm is only available for injected providers\");\n    }\n    try {\n      const result = await currentProvider.getSupportedAutoConfirmChains();\n      debug.info(DebugCategory.BROWSER_SDK, \"Got supported auto-confirm chains\", { result });\n      return result;\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Failed to get supported auto-confirm chains\", {\n        error: error.message\n      });\n      throw error;\n    }\n  }\n  getDiscoveredWallets() {\n    debug.log(DebugCategory.BROWSER_SDK, \"Getting discovered wallets\");\n    try {\n      const allWallets = this.walletRegistry.getByAddressTypes(this.config.addressTypes);\n      debug.log(DebugCategory.BROWSER_SDK, \"Retrieved discovered wallets\", {\n        count: allWallets.length,\n        walletIds: allWallets.map((w) => w.id)\n      });\n      return allWallets;\n    } catch (error) {\n      debug.error(DebugCategory.BROWSER_SDK, \"Failed to get discovered wallets\", {\n        error: error.message\n      });\n      return [];\n    }\n  }\n};\n\n// src/waitForPhantomExtension.ts\n\nasync function waitForPhantomExtension(timeoutMs = 3e3) {\n  return new Promise((resolve) => {\n    const startTime = Date.now();\n    const checkInterval = 100;\n    const checkForExtension = () => {\n      try {\n        if ((0,_phantom_browser_injected_sdk__WEBPACK_IMPORTED_MODULE_1__.isPhantomExtensionInstalled)()) {\n          resolve(true);\n          return;\n        }\n      } catch (error) {\n      }\n      const elapsed = Date.now() - startTime;\n      if (elapsed >= timeoutMs) {\n        resolve(false);\n        return;\n      }\n      setTimeout(checkForExtension, checkInterval);\n    };\n    checkForExtension();\n  });\n}\n\n// src/index.ts\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vYnJvd3Nlci1zZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4Qzs7QUFFOUM7QUFDOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRTtBQUNTO0FBQ1M7QUFDWDtBQUNJO0FBQ087QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSwrRUFBK0Usa0NBQWtDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFEQUFxRCwrQkFBK0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLHdDQUF3QywyQkFBMkI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBLE1BQU07QUFDTixvRkFBb0Ysc0JBQXNCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixRQUFRO0FBQzNGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBGQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQytDO0FBQ2U7QUFnQjVEIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9icm93c2VyLXNkay9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdHlwZXMudHNcbmltcG9ydCB7IEFkZHJlc3NUeXBlIH0gZnJvbSBcIkBwaGFudG9tL2NsaWVudFwiO1xuXG4vLyBzcmMvcHJvdmlkZXJzL2luamVjdGVkL2luZGV4LnRzXG5pbXBvcnQgeyBBZGRyZXNzVHlwZSBhcyBBZGRyZXNzVHlwZTIgfSBmcm9tIFwiQHBoYW50b20vY2xpZW50XCI7XG5cbi8vIHNyYy9kZWJ1Zy50c1xudmFyIERlYnVnTGV2ZWwgPSAvKiBAX19QVVJFX18gKi8gKChEZWJ1Z0xldmVsMikgPT4ge1xuICBEZWJ1Z0xldmVsMltEZWJ1Z0xldmVsMltcIkVSUk9SXCJdID0gMF0gPSBcIkVSUk9SXCI7XG4gIERlYnVnTGV2ZWwyW0RlYnVnTGV2ZWwyW1wiV0FSTlwiXSA9IDFdID0gXCJXQVJOXCI7XG4gIERlYnVnTGV2ZWwyW0RlYnVnTGV2ZWwyW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XG4gIERlYnVnTGV2ZWwyW0RlYnVnTGV2ZWwyW1wiREVCVUdcIl0gPSAzXSA9IFwiREVCVUdcIjtcbiAgcmV0dXJuIERlYnVnTGV2ZWwyO1xufSkoRGVidWdMZXZlbCB8fCB7fSk7XG52YXIgRGVidWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGV2ZWwgPSAwIC8qIEVSUk9SICovO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAoIURlYnVnLmluc3RhbmNlKSB7XG4gICAgICBEZWJ1Zy5pbnN0YW5jZSA9IG5ldyBEZWJ1ZygpO1xuICAgIH1cbiAgICByZXR1cm4gRGVidWcuaW5zdGFuY2U7XG4gIH1cbiAgc2V0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgc2V0TGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICB3cml0ZUxvZyhsZXZlbCwgY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCBsZXZlbCA+IHRoaXMubGV2ZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVidWdNZXNzYWdlID0ge1xuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgbGV2ZWwsXG4gICAgICBjYXRlZ29yeSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayhkZWJ1Z01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBlcnJvcihjYXRlZ29yeSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMud3JpdGVMb2coMCAvKiBFUlJPUiAqLywgY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIHdhcm4oY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLndyaXRlTG9nKDEgLyogV0FSTiAqLywgY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIGluZm8oY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLndyaXRlTG9nKDIgLyogSU5GTyAqLywgY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIGRlYnVnKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy53cml0ZUxvZygzIC8qIERFQlVHICovLCBjYXRlZ29yeSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgbG9nKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy53cml0ZUxvZygzIC8qIERFQlVHICovLCBjYXRlZ29yeSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn07XG52YXIgZGVidWcgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xudmFyIERlYnVnQ2F0ZWdvcnkgPSB7XG4gIEJST1dTRVJfU0RLOiBcIkJyb3dzZXJTREtcIixcbiAgUFJPVklERVJfTUFOQUdFUjogXCJQcm92aWRlck1hbmFnZXJcIixcbiAgRU1CRURERURfUFJPVklERVI6IFwiRW1iZWRkZWRQcm92aWRlclwiLFxuICBJTkpFQ1RFRF9QUk9WSURFUjogXCJJbmplY3RlZFByb3ZpZGVyXCIsXG4gIFBIQU5UT01fQ09OTkVDVF9BVVRIOiBcIlBoYW50b21Db25uZWN0QXV0aFwiLFxuICBKV1RfQVVUSDogXCJKV1RBdXRoXCIsXG4gIFNUT1JBR0U6IFwiU3RvcmFnZVwiLFxuICBTRVNTSU9OOiBcIlNlc3Npb25cIlxufTtcblxuLy8gc3JjL3dhbGxldHMvZGlzY292ZXJ5LnRzXG5pbXBvcnQgeyBBZGRyZXNzVHlwZSBhcyBDbGllbnRBZGRyZXNzVHlwZSB9IGZyb20gXCJAcGhhbnRvbS9jbGllbnRcIjtcbmltcG9ydCB7IGlzUGhhbnRvbUV4dGVuc2lvbkluc3RhbGxlZCB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNka1wiO1xuaW1wb3J0IHsgY3JlYXRlUGhhbnRvbSwgY3JlYXRlRXh0ZW5zaW9uUGx1Z2luIH0gZnJvbSBcIkBwaGFudG9tL2Jyb3dzZXItaW5qZWN0ZWQtc2RrXCI7XG5pbXBvcnQgeyBjcmVhdGVTb2xhbmFQbHVnaW4gfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvc29sYW5hXCI7XG5pbXBvcnQgeyBjcmVhdGVFdGhlcmV1bVBsdWdpbiB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNkay9ldGhlcmV1bVwiO1xuaW1wb3J0IHsgY3JlYXRlQXV0b0NvbmZpcm1QbHVnaW4gfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGsvYXV0by1jb25maXJtXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZVdhbGxldElkRnJvbUVJUDY5NjMoaW5mbykge1xuICBpZiAoaW5mby5yZG5zKSB7XG4gICAgcmV0dXJuIGluZm8ucmRucy5zcGxpdChcIi5cIikucmV2ZXJzZSgpLmpvaW4oXCItXCIpO1xuICB9XG4gIHJldHVybiBpbmZvLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csIFwiLVwiKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlV2FsbGV0SWRGcm9tTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCBcIi1cIik7XG59XG5mdW5jdGlvbiBwcm9jZXNzRUlQNjk2M1Byb3ZpZGVycyhwcm92aWRlcnMpIHtcbiAgY29uc3Qgd2FsbGV0cyA9IFtdO1xuICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJQcm9jZXNzaW5nIEVJUC02OTYzIHByb3ZpZGVyc1wiLCB7XG4gICAgcHJvdmlkZXJDb3VudDogcHJvdmlkZXJzLnNpemUsXG4gICAgcHJvdmlkZXJOYW1lczogQXJyYXkuZnJvbShwcm92aWRlcnMudmFsdWVzKCkpLm1hcCgoZCkgPT4gZC5pbmZvLm5hbWUpXG4gIH0pO1xuICBmb3IgKGNvbnN0IFssIGRldGFpbF0gb2YgcHJvdmlkZXJzKSB7XG4gICAgY29uc3QgeyBpbmZvLCBwcm92aWRlciB9ID0gZGV0YWlsO1xuICAgIGNvbnN0IGlzUGhhbnRvbSA9IGluZm8ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicGhhbnRvbVwiKSB8fCBpbmZvLnJkbnMgJiYgKGluZm8ucmRucy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicGhhbnRvbVwiKSB8fCBpbmZvLnJkbnMudG9Mb3dlckNhc2UoKSA9PT0gXCJhcHAucGhhbnRvbVwiKTtcbiAgICBpZiAoaXNQaGFudG9tKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJTa2lwcGluZyBQaGFudG9tIGZyb20gRUlQLTY5NjNcIiwgeyBuYW1lOiBpbmZvLm5hbWUsIHJkbnM6IGluZm8ucmRucyB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRJZCA9IGdlbmVyYXRlV2FsbGV0SWRGcm9tRUlQNjk2MyhpbmZvKTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJEaXNjb3ZlcmVkIEVJUC02OTYzIHdhbGxldFwiLCB7XG4gICAgICB3YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IGluZm8ubmFtZSxcbiAgICAgIHJkbnM6IGluZm8ucmRuc1xuICAgIH0pO1xuICAgIHdhbGxldHMucHVzaCh7XG4gICAgICBpZDogd2FsbGV0SWQsXG4gICAgICBuYW1lOiBpbmZvLm5hbWUsXG4gICAgICBpY29uOiBpbmZvLmljb24sXG4gICAgICBhZGRyZXNzVHlwZXM6IFtDbGllbnRBZGRyZXNzVHlwZS5ldGhlcmV1bV0sXG4gICAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgLy8gRUlQLTY5NjMgcHJvdmlkZXIgaW1wbGVtZW50cyBFSVAtMTE5MyBpbnRlcmZhY2UgKElFdGhlcmV1bUNoYWluKVxuICAgICAgICBldGhlcmV1bTogcHJvdmlkZXJcbiAgICAgIH0sXG4gICAgICByZG5zOiBpbmZvLnJkbnMsXG4gICAgICAvLyBTdG9yZSByZG5zIGZvciBwb3RlbnRpYWwgZnV0dXJlIG1hdGNoaW5nXG4gICAgICBkaXNjb3Zlcnk6IFwiZWlwNjk2M1wiXG4gICAgfSk7XG4gIH1cbiAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiRUlQLTY5NjMgZGlzY292ZXJ5IGNvbXBsZXRlZFwiLCB7XG4gICAgZGlzY292ZXJlZENvdW50OiB3YWxsZXRzLmxlbmd0aCxcbiAgICB3YWxsZXRJZHM6IHdhbGxldHMubWFwKCh3KSA9PiB3LmlkKVxuICB9KTtcbiAgcmV0dXJuIHdhbGxldHM7XG59XG5mdW5jdGlvbiBkaXNjb3ZlckV0aGVyZXVtV2FsbGV0cygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZGlzY292ZXJlZFByb3ZpZGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJlc29sdmUoW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVBbm5vdW5jZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgZGV0YWlsID0gZXZlbnQuZGV0YWlsO1xuICAgICAgaWYgKGRldGFpbD8uaW5mbyAmJiBkZXRhaWw/LnByb3ZpZGVyKSB7XG4gICAgICAgIGRpc2NvdmVyZWRQcm92aWRlcnMuc2V0KGRldGFpbC5pbmZvLnV1aWQsIGRldGFpbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBoYW5kbGVBbm5vdW5jZSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIikpO1xuICAgIGNvbnN0IHByb2Nlc3NQcm92aWRlcnMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB3YWxsZXRzID0gcHJvY2Vzc0VJUDY5NjNQcm92aWRlcnMoZGlzY292ZXJlZFByb3ZpZGVycyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBoYW5kbGVBbm5vdW5jZSk7XG4gICAgICByZXNvbHZlKHdhbGxldHMpO1xuICAgIH07XG4gICAgc2V0VGltZW91dChwcm9jZXNzUHJvdmlkZXJzLCA0MDApO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyU29sYW5hV2FsbGV0cygpIHtcbiAgY29uc3Qgd2FsbGV0cyA9IFtdO1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiV2FsbGV0IFN0YW5kYXJkIGRpc2NvdmVyeSBza2lwcGVkIChub3QgaW4gYnJvd3NlciBlbnZpcm9ubWVudClcIik7XG4gICAgcmV0dXJuIHdhbGxldHM7XG4gIH1cbiAgY29uc3QgcmVnaXN0ZXJlZFdhbGxldHNTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY2FjaGVkV2FsbGV0c0FycmF5O1xuICBmdW5jdGlvbiBhZGRSZWdpc3RlcmVkV2FsbGV0KHdhbGxldCkge1xuICAgIGNhY2hlZFdhbGxldHNBcnJheSA9IHZvaWQgMDtcbiAgICByZWdpc3RlcmVkV2FsbGV0c1NldC5hZGQod2FsbGV0KTtcbiAgICBjb25zdCBmZWF0dXJlS2V5cyA9IHdhbGxldC5mZWF0dXJlcyA/IE9iamVjdC5rZXlzKHdhbGxldC5mZWF0dXJlcykgOiBbXTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXYWxsZXQgcmVnaXN0ZXJlZFwiLCB7XG4gICAgICBuYW1lOiB3YWxsZXQubmFtZSxcbiAgICAgIGNoYWluczogd2FsbGV0LmNoYWlucyxcbiAgICAgIGZlYXR1cmVLZXlzLFxuICAgICAgdG90YWxXYWxsZXRzOiByZWdpc3RlcmVkV2FsbGV0c1NldC5zaXplXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUmVnaXN0ZXJlZFdhbGxldCh3YWxsZXQpIHtcbiAgICBjYWNoZWRXYWxsZXRzQXJyYXkgPSB2b2lkIDA7XG4gICAgcmVnaXN0ZXJlZFdhbGxldHNTZXQuZGVsZXRlKHdhbGxldCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFdhbGxldHMoKSB7XG4gICAgaWYgKCFjYWNoZWRXYWxsZXRzQXJyYXkpIHtcbiAgICAgIGNhY2hlZFdhbGxldHNBcnJheSA9IFsuLi5yZWdpc3RlcmVkV2FsbGV0c1NldF07XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRXYWxsZXRzQXJyYXk7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXIoLi4ud2FsbGV0czIpIHtcbiAgICB3YWxsZXRzMiA9IHdhbGxldHMyLmZpbHRlcigod2FsbGV0KSA9PiAhcmVnaXN0ZXJlZFdhbGxldHNTZXQuaGFzKHdhbGxldCkpO1xuICAgIGlmICghd2FsbGV0czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgd2FsbGV0czIuZm9yRWFjaCgod2FsbGV0KSA9PiBhZGRSZWdpc3RlcmVkV2FsbGV0KHdhbGxldCkpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgd2FsbGV0czIuZm9yRWFjaCgod2FsbGV0KSA9PiByZW1vdmVSZWdpc3RlcmVkV2FsbGV0KHdhbGxldCkpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgcmVnaXN0ZXJBUEkgPSBPYmplY3QuZnJlZXplKHsgcmVnaXN0ZXIgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZ2lzdGVyV2FsbGV0RXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGV2ZW50LmRldGFpbDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKHJlZ2lzdGVyQVBJKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGRlYnVnLndhcm4oRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJFcnJvciBjYWxsaW5nIHdhbGxldCByZWdpc3RyYXRpb24gY2FsbGJhY2tcIiwgeyBlcnJvciB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHRyeSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWxsZXQtc3RhbmRhcmQ6cmVnaXN0ZXItd2FsbGV0XCIsIGhhbmRsZVJlZ2lzdGVyV2FsbGV0RXZlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRlYnVnLndhcm4oRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJDb3VsZCBub3QgYWRkIHJlZ2lzdGVyLXdhbGxldCBldmVudCBsaXN0ZW5lclwiLCB7IGVycm9yIH0pO1xuICB9XG4gIGNsYXNzIEFwcFJlYWR5RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpKSB7XG4gICAgICBzdXBlcihcIndhbGxldC1zdGFuZGFyZDphcHAtcmVhZHlcIiwge1xuICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbXBvc2VkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRldGFpbCA9IGFwaTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQXBwUmVhZHlFdmVudChyZWdpc3RlckFQSSkpO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkRpc3BhdGNoZWQgd2FsbGV0LXN0YW5kYXJkOmFwcC1yZWFkeSBldmVudFwiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQ291bGQgbm90IGRpc3BhdGNoIGFwcC1yZWFkeSBldmVudFwiLCB7IGVycm9yIH0pO1xuICB9XG4gIGNvbnN0IHdhbGxldHNBUEkgPSB7XG4gICAgZ2V0V2FsbGV0czogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBnZXRSZWdpc3RlcmVkV2FsbGV0cyxcbiAgICAgICAgb246IChfZXZlbnQsIF9saXN0ZW5lcikgPT4ge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBpZiAoIW5hdmlnYXRvci53YWxsZXRzKSB7XG4gICAgbmF2aWdhdG9yLndhbGxldHMgPSB3YWxsZXRzQVBJO1xuICB9XG4gIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkluaXRpYWxpemVkIFdhbGxldCBTdGFuZGFyZCByZWdpc3RyeVwiKTtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gIGNvbnN0IGV4aXN0aW5nV2FsbGV0c0FQSSA9IG5hdmlnYXRvci53YWxsZXRzIHx8IHdpbmRvdy53YWxsZXRzO1xuICBpZiAoIWV4aXN0aW5nV2FsbGV0c0FQSSB8fCB0eXBlb2YgZXhpc3RpbmdXYWxsZXRzQVBJLmdldFdhbGxldHMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IGxvZ0RhdGEgPSB7XG4gICAgICBoYXNOYXZpZ2F0b3I6ICEhbmF2aWdhdG9yLFxuICAgICAgaGFzV2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiLFxuICAgICAgbm90ZTogXCJXYWxsZXQgU3RhbmRhcmQgQVBJIG5vdCBwcm9wZXJseSBpbml0aWFsaXplZFwiXG4gICAgfTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXYWxsZXQgU3RhbmRhcmQgQVBJIG5vdCBhdmFpbGFibGVcIiwgbG9nRGF0YSk7XG4gICAgcmV0dXJuIHdhbGxldHM7XG4gIH1cbiAgY29uc3Qgd2FsbGV0c0dldHRlciA9IGV4aXN0aW5nV2FsbGV0c0FQSS5nZXRXYWxsZXRzKCk7XG4gIGNvbnN0IGdldFdhbGxldHNGbiA9ICgpID0+IFByb21pc2UucmVzb2x2ZShbLi4ud2FsbGV0c0dldHRlci5nZXQoKV0pO1xuICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXYWxsZXQgU3RhbmRhcmQgQVBJIGRldGVjdGVkLCBzdGFydGluZyBkaXNjb3ZlcnlcIik7XG4gIHRyeSB7XG4gICAgbGV0IHJlZ2lzdGVyZWRXYWxsZXRzID0gW107XG4gICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDU7XG4gICAgY29uc3QgaW5pdGlhbERlbGF5ID0gMTAwO1xuICAgIGNvbnN0IGVpcDY5NjNUaW1lb3V0ID0gNDAwO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGluaXRpYWxEZWxheSkpO1xuICAgIHdoaWxlIChhdHRlbXB0cyA8IG1heEF0dGVtcHRzKSB7XG4gICAgICByZWdpc3RlcmVkV2FsbGV0cyA9IGF3YWl0IGdldFdhbGxldHNGbigpO1xuICAgICAgY29uc3QgbG9nRGF0YSA9IHtcbiAgICAgICAgYXR0ZW1wdDogYXR0ZW1wdHMgKyAxLFxuICAgICAgICB3YWxsZXRDb3VudDogcmVnaXN0ZXJlZFdhbGxldHMubGVuZ3RoLFxuICAgICAgICB3YWxsZXROYW1lczogcmVnaXN0ZXJlZFdhbGxldHMubWFwKCh3KSA9PiB3Lm5hbWUpLFxuICAgICAgICBjaGFpbnM6IHJlZ2lzdGVyZWRXYWxsZXRzLmZsYXRNYXAoKHcpID0+IHcuY2hhaW5zKVxuICAgICAgfTtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBgV2FsbGV0IFN0YW5kYXJkIGdldFdhbGxldHMgYXR0ZW1wdCAke2F0dGVtcHRzICsgMX1gLCBsb2dEYXRhKTtcbiAgICAgIGlmIChyZWdpc3RlcmVkV2FsbGV0cy5sZW5ndGggPiAwIHx8IGF0dGVtcHRzID09PSBtYXhBdHRlbXB0cyAtIDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbml0aWFsRGVsYXkpKTtcbiAgICAgIGF0dGVtcHRzKys7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsV2FpdFRpbWUgPSBpbml0aWFsRGVsYXkgKyBhdHRlbXB0cyAqIGluaXRpYWxEZWxheTtcbiAgICBpZiAodG90YWxXYWl0VGltZSA8IGVpcDY5NjNUaW1lb3V0KSB7XG4gICAgICBjb25zdCByZW1haW5pbmdXYWl0ID0gZWlwNjk2M1RpbWVvdXQgLSB0b3RhbFdhaXRUaW1lO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmVtYWluaW5nV2FpdCkpO1xuICAgICAgcmVnaXN0ZXJlZFdhbGxldHMgPSBhd2FpdCBnZXRXYWxsZXRzRm4oKTtcbiAgICB9XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiV2FsbGV0IFN0YW5kYXJkIGdldFdhbGxldHMgZmluYWwgcmVzdWx0XCIsIHtcbiAgICAgIHdhbGxldENvdW50OiByZWdpc3RlcmVkV2FsbGV0cy5sZW5ndGgsXG4gICAgICB3YWxsZXROYW1lczogcmVnaXN0ZXJlZFdhbGxldHMubWFwKCh3KSA9PiB3Lm5hbWUpLFxuICAgICAgYXR0ZW1wdHM6IGF0dGVtcHRzICsgMVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgd2FsbGV0IG9mIHJlZ2lzdGVyZWRXYWxsZXRzKSB7XG4gICAgICBjb25zdCBzdXBwb3J0c1NvbGFuYSA9IHdhbGxldC5jaGFpbnMuc29tZSgoY2hhaW4pID0+IHtcbiAgICAgICAgY29uc3QgY2hhaW5Mb3dlciA9IGNoYWluLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBjaGFpbkxvd2VyLnN0YXJ0c1dpdGgoXCJzb2xhbmE6XCIpIHx8IGNoYWluTG93ZXIgPT09IFwic29sYW5hXCI7XG4gICAgICB9KSB8fCB3YWxsZXQuZmVhdHVyZXMgJiYgdHlwZW9mIHdhbGxldC5mZWF0dXJlcyA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh3YWxsZXQuZmVhdHVyZXMpLnNvbWUoKGZlYXR1cmVLZXkpID0+IHtcbiAgICAgICAgY29uc3QgZmVhdHVyZUxvd2VyID0gZmVhdHVyZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZUxvd2VyLnN0YXJ0c1dpdGgoXCJzb2xhbmE6XCIpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXN1cHBvcnRzU29sYW5hKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVLZXlzID0gd2FsbGV0LmZlYXR1cmVzID8gT2JqZWN0LmtleXMod2FsbGV0LmZlYXR1cmVzKSA6IFtdO1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXYWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBTb2xhbmFcIiwge1xuICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldC5uYW1lLFxuICAgICAgICAgIGNoYWluczogd2FsbGV0LmNoYWlucyxcbiAgICAgICAgICBmZWF0dXJlS2V5c1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAod2FsbGV0Lm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInBoYW50b21cIikpIHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiU2tpcHBpbmcgUGhhbnRvbSBmcm9tIFdhbGxldCBTdGFuZGFyZCAoaGFuZGxlZCBzZXBhcmF0ZWx5KVwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3YWxsZXRJZCA9IGdlbmVyYXRlV2FsbGV0SWRGcm9tTmFtZSh3YWxsZXQubmFtZSk7XG4gICAgICBjb25zdCBzYWZlRmVhdHVyZXMgPSB3YWxsZXQuZmVhdHVyZXMgPyBPYmplY3Qua2V5cyh3YWxsZXQuZmVhdHVyZXMpIDogW107XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJEaXNjb3ZlcmVkIFdhbGxldCBTdGFuZGFyZCBTb2xhbmEgd2FsbGV0XCIsIHtcbiAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHdhbGxldC5uYW1lLFxuICAgICAgICBjaGFpbnM6IHdhbGxldC5jaGFpbnMsXG4gICAgICAgIGZlYXR1cmVLZXlzOiBzYWZlRmVhdHVyZXMsXG4gICAgICAgIGljb246IHdhbGxldC5pY29uLFxuICAgICAgICB2ZXJzaW9uOiB3YWxsZXQudmVyc2lvbixcbiAgICAgICAgYWNjb3VudENvdW50OiB3YWxsZXQuYWNjb3VudHM/Lmxlbmd0aCB8fCAwXG4gICAgICB9KTtcbiAgICAgIHdhbGxldHMucHVzaCh7XG4gICAgICAgIGlkOiB3YWxsZXRJZCxcbiAgICAgICAgbmFtZTogd2FsbGV0Lm5hbWUsXG4gICAgICAgIGljb246IHdhbGxldC5pY29uLFxuICAgICAgICBhZGRyZXNzVHlwZXM6IFtDbGllbnRBZGRyZXNzVHlwZS5zb2xhbmFdLFxuICAgICAgICBwcm92aWRlcnM6IHtcbiAgICAgICAgICAvLyBDYXN0IHRvIElTb2xhbmFDaGFpbiAtIFdhbGxldCBTdGFuZGFyZCB3YWxsZXRzIGhhdmUgY29tcGF0aWJsZSBtZXRob2RzXG4gICAgICAgICAgLy8gVGhlIEluamVjdGVkV2FsbGV0U29sYW5hQ2hhaW4gd3JhcHBlciB3aWxsIGhhbmRsZSB0aGUgYWN0dWFsIG1ldGhvZCBjYWxsc1xuICAgICAgICAgIHNvbGFuYTogd2FsbGV0XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2NvdmVyeTogXCJzdGFuZGFyZFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIldhbGxldCBTdGFuZGFyZCBBUEkgZXJyb3JcIiwge1xuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmaW5hbExvZ0RhdGEgPSB7XG4gICAgZGlzY292ZXJlZENvdW50OiB3YWxsZXRzLmxlbmd0aCxcbiAgICB3YWxsZXRJZHM6IHdhbGxldHMubWFwKCh3KSA9PiB3LmlkKSxcbiAgICB3YWxsZXROYW1lczogd2FsbGV0cy5tYXAoKHcpID0+IHcubmFtZSlcbiAgfTtcbiAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiV2FsbGV0IFN0YW5kYXJkIFNvbGFuYSBkaXNjb3ZlcnkgY29tcGxldGVkXCIsIGZpbmFsTG9nRGF0YSk7XG4gIHJldHVybiB3YWxsZXRzO1xufVxuZnVuY3Rpb24gZGlzY292ZXJQaGFudG9tV2FsbGV0KGFkZHJlc3NUeXBlcykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNQaGFudG9tRXh0ZW5zaW9uSW5zdGFsbGVkKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwbHVnaW5zID0gW2NyZWF0ZUV4dGVuc2lvblBsdWdpbigpXTtcbiAgaWYgKGFkZHJlc3NUeXBlcy5pbmNsdWRlcyhDbGllbnRBZGRyZXNzVHlwZS5zb2xhbmEpKSB7XG4gICAgcGx1Z2lucy5wdXNoKGNyZWF0ZVNvbGFuYVBsdWdpbigpKTtcbiAgfVxuICBpZiAoYWRkcmVzc1R5cGVzLmluY2x1ZGVzKENsaWVudEFkZHJlc3NUeXBlLmV0aGVyZXVtKSkge1xuICAgIHBsdWdpbnMucHVzaChjcmVhdGVFdGhlcmV1bVBsdWdpbigpKTtcbiAgfVxuICBwbHVnaW5zLnB1c2goY3JlYXRlQXV0b0NvbmZpcm1QbHVnaW4oKSk7XG4gIGNvbnN0IHBoYW50b21JbnN0YW5jZSA9IGNyZWF0ZVBoYW50b20oeyBwbHVnaW5zIH0pO1xuICByZXR1cm4ge1xuICAgIGlkOiBcInBoYW50b21cIixcbiAgICBuYW1lOiBcIlBoYW50b21cIixcbiAgICBpY29uOiB2b2lkIDAsXG4gICAgLy8gSWNvbiB3aWxsIGJlIHJlbmRlcmVkIGZyb20gaWNvbnMgcGFja2FnZSBpbiBVSSBjb21wb25lbnRzXG4gICAgYWRkcmVzc1R5cGVzLFxuICAgIHByb3ZpZGVyczoge1xuICAgICAgc29sYW5hOiBhZGRyZXNzVHlwZXMuaW5jbHVkZXMoQ2xpZW50QWRkcmVzc1R5cGUuc29sYW5hKSA/IHBoYW50b21JbnN0YW5jZS5zb2xhbmEgOiB2b2lkIDAsXG4gICAgICBldGhlcmV1bTogYWRkcmVzc1R5cGVzLmluY2x1ZGVzKENsaWVudEFkZHJlc3NUeXBlLmV0aGVyZXVtKSA/IHBoYW50b21JbnN0YW5jZS5ldGhlcmV1bSA6IHZvaWQgMFxuICAgIH0sXG4gICAgaXNQaGFudG9tOiB0cnVlLFxuICAgIHBoYW50b21JbnN0YW5jZSxcbiAgICBkaXNjb3Zlcnk6IFwicGhhbnRvbVwiXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkaXNjb3ZlcldhbGxldHMoYWRkcmVzc1R5cGVzKSB7XG4gIGNvbnN0IHJlcXVlc3RlZEFkZHJlc3NUeXBlcyA9IGFkZHJlc3NUeXBlcyB8fCBbXTtcbiAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiU3RhcnRpbmcgYWxsIHdhbGxldCBkaXNjb3ZlcnkgbWV0aG9kc1wiLCB7XG4gICAgYWRkcmVzc1R5cGVzOiByZXF1ZXN0ZWRBZGRyZXNzVHlwZXNcbiAgfSk7XG4gIGNvbnN0IFtzb2xhbmFXYWxsZXRzLCBldGhlcmV1bVdhbGxldHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2Rpc2NvdmVyU29sYW5hV2FsbGV0cygpLCBkaXNjb3ZlckV0aGVyZXVtV2FsbGV0cygpXSk7XG4gIGNvbnN0IHBoYW50b21XYWxsZXQgPSBkaXNjb3ZlclBoYW50b21XYWxsZXQocmVxdWVzdGVkQWRkcmVzc1R5cGVzKTtcbiAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQWxsIHdhbGxldCBkaXNjb3ZlcnkgbWV0aG9kcyBjb21wbGV0ZWRcIiwge1xuICAgIHBoYW50b21Gb3VuZDogISFwaGFudG9tV2FsbGV0LFxuICAgIHNvbGFuYVdhbGxldHNDb3VudDogc29sYW5hV2FsbGV0cy5sZW5ndGgsXG4gICAgZXRoZXJldW1XYWxsZXRzQ291bnQ6IGV0aGVyZXVtV2FsbGV0cy5sZW5ndGgsXG4gICAgc29sYW5hV2FsbGV0SWRzOiBzb2xhbmFXYWxsZXRzLm1hcCgodykgPT4gdy5pZCksXG4gICAgZXRoZXJldW1XYWxsZXRJZHM6IGV0aGVyZXVtV2FsbGV0cy5tYXAoKHcpID0+IHcuaWQpXG4gIH0pO1xuICBjb25zdCB3YWxsZXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAocGhhbnRvbVdhbGxldCkge1xuICAgIHdhbGxldE1hcC5zZXQoXCJwaGFudG9tXCIsIHBoYW50b21XYWxsZXQpO1xuICB9XG4gIGZvciAoY29uc3Qgd2FsbGV0IG9mIFsuLi5zb2xhbmFXYWxsZXRzLCAuLi5ldGhlcmV1bVdhbGxldHNdKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB3YWxsZXRNYXAuZ2V0KHdhbGxldC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBjb25zdCBtZXJnZWRBZGRyZXNzVHlwZXMgPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5leGlzdGluZy5hZGRyZXNzVHlwZXMsIC4uLndhbGxldC5hZGRyZXNzVHlwZXNdKSk7XG4gICAgICBjb25zdCBtZXJnZWRQcm92aWRlcnMgPSB7XG4gICAgICAgIC4uLmV4aXN0aW5nLnByb3ZpZGVycyxcbiAgICAgICAgLi4ud2FsbGV0LnByb3ZpZGVyc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1lcmdlZFdhbGxldCA9IHtcbiAgICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICAgIGFkZHJlc3NUeXBlczogbWVyZ2VkQWRkcmVzc1R5cGVzLFxuICAgICAgICAvLyBQcmVmZXIgaWNvbiBmcm9tIHRoZSBtb3N0IHJlY2VudCBkaXNjb3ZlcnlcbiAgICAgICAgaWNvbjogd2FsbGV0Lmljb24gfHwgZXhpc3RpbmcuaWNvbixcbiAgICAgICAgcHJvdmlkZXJzOiBtZXJnZWRQcm92aWRlcnNcbiAgICAgIH07XG4gICAgICB3YWxsZXRNYXAuc2V0KHdhbGxldC5pZCwgbWVyZ2VkV2FsbGV0KTtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIk1lcmdlZCB3YWxsZXQgYnkgSURcIiwge1xuICAgICAgICB3YWxsZXROYW1lOiB3YWxsZXQubmFtZSxcbiAgICAgICAgd2FsbGV0SWQ6IHdhbGxldC5pZCxcbiAgICAgICAgZXhpc3RpbmdBZGRyZXNzVHlwZXM6IGV4aXN0aW5nLmFkZHJlc3NUeXBlcyxcbiAgICAgICAgbmV3QWRkcmVzc1R5cGVzOiB3YWxsZXQuYWRkcmVzc1R5cGVzLFxuICAgICAgICBtZXJnZWRBZGRyZXNzVHlwZXMsXG4gICAgICAgIGV4aXN0aW5nUHJvdmlkZXJzOiBPYmplY3Qua2V5cyhleGlzdGluZy5wcm92aWRlcnMgfHwge30pLFxuICAgICAgICBuZXdQcm92aWRlcnM6IE9iamVjdC5rZXlzKHdhbGxldC5wcm92aWRlcnMgfHwge30pLFxuICAgICAgICBtZXJnZWRQcm92aWRlcnM6IE9iamVjdC5rZXlzKG1lcmdlZFByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiTWVyZ2VkIHdhbGxldCBmcm9tIG11bHRpcGxlIGRpc2NvdmVyeSBtZXRob2RzXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHdhbGxldC5pZCxcbiAgICAgICAgd2FsbGV0TmFtZTogd2FsbGV0Lm5hbWUsXG4gICAgICAgIGV4aXN0aW5nQWRkcmVzc1R5cGVzOiBleGlzdGluZy5hZGRyZXNzVHlwZXMsXG4gICAgICAgIG5ld0FkZHJlc3NUeXBlczogd2FsbGV0LmFkZHJlc3NUeXBlcyxcbiAgICAgICAgbWVyZ2VkQWRkcmVzc1R5cGVzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FsbGV0TWFwLnNldCh3YWxsZXQuaWQsIHdhbGxldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHdhbGxldE1hcC52YWx1ZXMoKSk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvaW5qZWN0ZWQvY2hhaW5zL0luamVjdGVkV2FsbGV0U29sYW5hQ2hhaW4udHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudGVtaXR0ZXIzXCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG52YXIgSW5qZWN0ZWRXYWxsZXRTb2xhbmFDaGFpbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIsIHdhbGxldElkLCB3YWxsZXROYW1lKSB7XG4gICAgLy8gRXhwb3NlIGV2ZW50RW1pdHRlciBmb3IgdGVzdGluZyAtIGFsbG93cyB0ZXN0cyB0byB0cmlnZ2VyIGV2ZW50cyBkaXJlY3RseVxuICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMud2FsbGV0SWQgPSB3YWxsZXRJZDtcbiAgICB0aGlzLndhbGxldE5hbWUgPSB3YWxsZXROYW1lO1xuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChvcHRpb25zKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBjb25uZWN0XCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgb25seUlmVHJ1c3RlZDogb3B0aW9ucz8ub25seUlmVHJ1c3RlZFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmNvbm5lY3Qob3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSByZXN1bHQ7XG4gICAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIGNvbm5lY3RlZFwiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICAgIHB1YmxpY0tleTogcmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBwdWJsaWNLZXk6IHJlc3VsdCB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICE9PSBudWxsICYmIFwicHVibGljS2V5XCIgaW4gcmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHJlc3VsdC5wdWJsaWNLZXk7XG4gICAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIGNvbm5lY3RlZFwiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICAgIHB1YmxpY0tleTogcmVzdWx0LnB1YmxpY0tleVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZmlyc3RBY2NvdW50ID0gcmVzdWx0WzBdO1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0QWNjb3VudCA9PT0gXCJvYmplY3RcIiAmJiBmaXJzdEFjY291bnQgIT09IG51bGwgJiYgXCJhZGRyZXNzXCIgaW4gZmlyc3RBY2NvdW50KSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBmaXJzdEFjY291bnQuYWRkcmVzcztcbiAgICAgICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBjb25uZWN0ZWRcIiwge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGZpcnN0QWNjb3VudC5hZGRyZXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5OiBmaXJzdEFjY291bnQuYWRkcmVzcyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNvbm5lY3QgcmVzdWx0IGZvcm1hdFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIGNvbm5lY3QgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIGRpc2Nvbm5lY3RcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBkaXNjb25uZWN0ZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIGRpc2Nvbm5lY3QgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpIDogbWVzc2FnZTtcbiAgICBjb25zdCBtZXNzYWdlUHJldmlldyA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZS5zdWJzdHJpbmcoMCwgNTApIDogYCR7bWVzc2FnZUJ5dGVzLmxlbmd0aH0gYnl0ZXNgO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBTb2xhbmEgc2lnbk1lc3NhZ2VcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICBtZXNzYWdlUHJldmlldyxcbiAgICAgIG1lc3NhZ2VMZW5ndGg6IG1lc3NhZ2VCeXRlcy5sZW5ndGhcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25NZXNzYWdlIHN1Y2Nlc3NcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBzaWduYXR1cmVMZW5ndGg6IHJlc3VsdC5zaWduYXR1cmUubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hdHVyZTogcmVzdWx0LnNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyByZXN1bHQuc2lnbmF0dXJlIDogbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20ocmVzdWx0LnNpZ25hdHVyZSwgXCJiYXNlNjRcIikpLFxuICAgICAgICBwdWJsaWNLZXk6IHJlc3VsdC5wdWJsaWNLZXkgfHwgdGhpcy5fcHVibGljS2V5IHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBzaWduTWVzc2FnZSBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25UcmFuc2FjdGlvblwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBzaWduVHJhbnNhY3Rpb24gc3VjY2Vzc1wiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25UcmFuc2FjdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIHN1Y2Nlc3NcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBzaWduYXR1cmU6IHJlc3VsdC5zaWduYXR1cmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25BbGxUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiB0cmFuc2FjdGlvbnMubGVuZ3RoXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBTb2xhbmEgc2lnbkFsbFRyYW5zYWN0aW9ucyBzdWNjZXNzXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgc2lnbmVkQ291bnQ6IHJlc3VsdC5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25BbGxUcmFuc2FjdGlvbnMgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IFNvbGFuYSBzaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9uc1wiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgIHRyYW5zYWN0aW9uQ291bnQ6IHRyYW5zYWN0aW9ucy5sZW5ndGhcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5zaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBTb2xhbmEgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnMgc3VjY2Vzc1wiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIHNpZ25hdHVyZUNvdW50OiByZXN1bHQuc2lnbmF0dXJlcy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgU29sYW5hIHNpZ25BbmRTZW5kQWxsVHJhbnNhY3Rpb25zIGZhaWxlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHN3aXRjaE5ldHdvcmsoX25ldHdvcmspIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgZ2V0UHVibGljS2V5KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcHVibGljS2V5KTtcbiAgfVxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnByb3ZpZGVyLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIub24oXCJjb25uZWN0XCIsIChwdWJsaWNLZXkpID0+IHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY29ubmVjdFwiLCBwdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm92aWRlci5vbihcImFjY291bnRDaGFuZ2VkXCIsIChwdWJsaWNLZXkpID0+IHtcbiAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBwdWJsaWNLZXkgIT0gbnVsbCAmJiBwdWJsaWNLZXkubGVuZ3RoID4gMDtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImFjY291bnRDaGFuZ2VkXCIsIHB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlcnMvaW5qZWN0ZWQvY2hhaW5zL1dhbGxldFN0YW5kYXJkU29sYW5hQWRhcHRlci50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVTb2xhbmFUcmFuc2FjdGlvbiB9IGZyb20gXCJAcGhhbnRvbS9wYXJzZXJzXCI7XG5pbXBvcnQgeyBCdWZmZXIgYXMgQnVmZmVyMiB9IGZyb20gXCJidWZmZXJcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG52YXIgV2FsbGV0U3RhbmRhcmRTb2xhbmFBZGFwdGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3YWxsZXQsIHdhbGxldElkLCB3YWxsZXROYW1lKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyMigpO1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy53YWxsZXRJZCA9IHdhbGxldElkO1xuICAgIHRoaXMud2FsbGV0TmFtZSA9IHdhbGxldE5hbWU7XG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5ICE9PSBudWxsO1xuICB9XG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleTtcbiAgfVxuICBhc3luYyBjb25uZWN0KF9vcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3RGZWF0dXJlID0gdGhpcy53YWxsZXQuZmVhdHVyZXNbXCJzdGFuZGFyZDpjb25uZWN0XCJdO1xuICAgICAgaWYgKCFjb25uZWN0RmVhdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgU3RhbmRhcmQgY29ubmVjdCBmZWF0dXJlIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25uZWN0UmVzdWx0ID0gYXdhaXQgY29ubmVjdEZlYXR1cmUuY29ubmVjdCgpO1xuICAgICAgbGV0IGFjY291bnRzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29ubmVjdFJlc3VsdCkgJiYgY29ubmVjdFJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjY291bnRzID0gY29ubmVjdFJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy53YWxsZXQuYWNjb3VudHMgJiYgdGhpcy53YWxsZXQuYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhY2NvdW50cyA9IEFycmF5LmZyb20odGhpcy53YWxsZXQuYWNjb3VudHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFhY2NvdW50cyB8fCBhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWNjb3VudHMgYXZhaWxhYmxlIGFmdGVyIGNvbm5lY3RpbmcgdG8gd2FsbGV0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyc3RBY2NvdW50ID0gYWNjb3VudHNbMF07XG4gICAgICBpZiAoIWZpcnN0QWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhY2NvdW50IGlzIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgfVxuICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0QWNjb3VudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhZGRyZXNzID0gZmlyc3RBY2NvdW50O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBY2NvdW50ID09PSBcIm9iamVjdFwiICYmIGZpcnN0QWNjb3VudCAhPT0gbnVsbCkge1xuICAgICAgICBhZGRyZXNzID0gZmlyc3RBY2NvdW50LmFkZHJlc3MgfHwgZmlyc3RBY2NvdW50LnB1YmxpY0tleT8udG9TdHJpbmcoKSB8fCAoZmlyc3RBY2NvdW50LnB1YmxpY0tleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBCdWZmZXIyLmZyb20oZmlyc3RBY2NvdW50LnB1YmxpY0tleSkudG9TdHJpbmcoXCJoZXhcIikgOiB2b2lkIDApO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGV4dHJhY3QgYWRkcmVzcyBmcm9tIGFjY291bnQuIEFjY291bnQgc3RydWN0dXJlOiAke0pTT04uc3RyaW5naWZ5KGZpcnN0QWNjb3VudCwgbnVsbCwgMil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVibGljS2V5ID0gYWRkcmVzcztcbiAgICAgIHJldHVybiB7IHB1YmxpY0tleTogYWRkcmVzcyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBTb2xhbmEgY29ubmVjdCBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkaXNjb25uZWN0RmVhdHVyZSA9IHRoaXMud2FsbGV0LmZlYXR1cmVzW1wic3RhbmRhcmQ6ZGlzY29ubmVjdFwiXTtcbiAgICAgIGlmIChkaXNjb25uZWN0RmVhdHVyZSkge1xuICAgICAgICBhd2FpdCBkaXNjb25uZWN0RmVhdHVyZS5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBTb2xhbmEgZGlzY29ubmVjdCBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25NZXNzYWdlRmVhdHVyZSA9IHRoaXMud2FsbGV0LmZlYXR1cmVzW1wic29sYW5hOnNpZ25NZXNzYWdlXCJdO1xuICAgICAgaWYgKCFzaWduTWVzc2FnZUZlYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IFN0YW5kYXJkIHNpZ25NZXNzYWdlIGZlYXR1cmUgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VCeXRlcyA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpIDogbWVzc2FnZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25NZXNzYWdlRmVhdHVyZS5zaWduTWVzc2FnZSh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VCeXRlcyxcbiAgICAgICAgYWNjb3VudDogdGhpcy53YWxsZXQuYWNjb3VudHNbMF1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5IHJlc3VsdCBmcm9tIHNpZ25NZXNzYWdlLCBnb3Q6ICR7dHlwZW9mIHJlc3VsdH1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VSZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICBpZiAoIXNpZ25lZE1lc3NhZ2VSZXN1bHQgfHwgIXNpZ25lZE1lc3NhZ2VSZXN1bHQuc2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduTWVzc2FnZSByZXN1bHQgc3RydWN0dXJlOiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLnBhcnNlVWludDhBcnJheShzaWduZWRNZXNzYWdlUmVzdWx0LnNpZ25hdHVyZSk7XG4gICAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25hdHVyZSBpcyBlbXB0eWApO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGljS2V5ID0gc2lnbmVkTWVzc2FnZVJlc3VsdC5hY2NvdW50Py5hZGRyZXNzIHx8IHRoaXMud2FsbGV0LmFjY291bnRzWzBdPy5hZGRyZXNzIHx8IHRoaXMuX3B1YmxpY0tleSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHsgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJXYWxsZXQgU3RhbmRhcmQgU29sYW5hIHNpZ25NZXNzYWdlIGZhaWxlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduVHJhbnNhY3Rpb25GZWF0dXJlID0gdGhpcy53YWxsZXQuZmVhdHVyZXNbXCJzb2xhbmE6c2lnblRyYW5zYWN0aW9uXCJdO1xuICAgICAgaWYgKCFzaWduVHJhbnNhY3Rpb25GZWF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBTdGFuZGFyZCBzaWduVHJhbnNhY3Rpb24gZmVhdHVyZSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLndhbGxldC5hY2NvdW50cyB8fCB0aGlzLndhbGxldC5hY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWNjb3VudHMgYXZhaWxhYmxlLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhY2NvdW50ID0gdGhpcy53YWxsZXQuYWNjb3VudHNbMF07XG4gICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSB0aGlzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzaWduVHJhbnNhY3Rpb25GZWF0dXJlLnNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgIGFjY291bnRcbiAgICAgIH0pO1xuICAgICAgbGV0IHRyYW5zYWN0aW9uRGF0YTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpICYmIHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaXJzdEl0ZW0gPSByZXN1bHRzWzBdO1xuICAgICAgICBpZiAoZmlyc3RJdGVtICYmIHR5cGVvZiBmaXJzdEl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbkRhdGEgPSBmaXJzdEl0ZW0uc2lnbmVkVHJhbnNhY3Rpb24gfHwgZmlyc3RJdGVtLnRyYW5zYWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdHMgJiYgdHlwZW9mIHJlc3VsdHMgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0T2JqID0gcmVzdWx0cztcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhID0gcmVzdWx0T2JqLnRyYW5zYWN0aW9uIHx8IHJlc3VsdE9iai5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb25EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRyYW5zYWN0aW9uIGRhdGEgZm91bmQgaW4gV2FsbGV0IFN0YW5kYXJkIHJlc3VsdFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25lZEJ5dGVzID0gdGhpcy5wYXJzZVVpbnQ4QXJyYXkodHJhbnNhY3Rpb25EYXRhKTtcbiAgICAgIGlmIChzaWduZWRCeXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgc2lnbmVkIHRyYW5zYWN0aW9uIHJldHVybmVkIGZyb20gV2FsbGV0IFN0YW5kYXJkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBkZXNlcmlhbGl6ZVNvbGFuYVRyYW5zYWN0aW9uKHNpZ25lZEJ5dGVzKTtcbiAgICAgIHJldHVybiBzaWduZWRUeDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJXYWxsZXQgU3RhbmRhcmQgU29sYW5hIHNpZ25UcmFuc2FjdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25GZWF0dXJlID0gdGhpcy53YWxsZXQuZmVhdHVyZXNbXCJzb2xhbmE6c2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiXTtcbiAgICAgIGlmICghc2lnbkFuZFNlbmRUcmFuc2FjdGlvbkZlYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IFN0YW5kYXJkIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gZmVhdHVyZSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLndhbGxldC5hY2NvdW50cyB8fCB0aGlzLndhbGxldC5hY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWNjb3VudHMgYXZhaWxhYmxlLiBQbGVhc2UgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhY2NvdW50ID0gdGhpcy53YWxsZXQuYWNjb3VudHNbMF07XG4gICAgICBjb25zdCBjaGFpbiA9IGFjY291bnQuY2hhaW5zPy5bMF0gfHwgXCJzb2xhbmE6bWFpbm5ldFwiO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gdGhpcy5zZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbkZlYXR1cmUuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgIGFjY291bnQsXG4gICAgICAgIGNoYWluXG4gICAgICB9KTtcbiAgICAgIGxldCBzaWduYXR1cmVPdXRwdXQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSAmJiByZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2lnbmF0dXJlT3V0cHV0ID0gcmVzdWx0c1swXTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0cyAmJiB0eXBlb2YgcmVzdWx0cyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICBzaWduYXR1cmVPdXRwdXQgPSByZXN1bHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduQW5kU2VuZFRyYW5zYWN0aW9uIHJlc3VsdCBmb3JtYXRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXNpZ25hdHVyZU91dHB1dC5zaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmF0dXJlIGZvdW5kIGluIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gcmVzdWx0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlQnl0ZXMgPSB0aGlzLnBhcnNlVWludDhBcnJheShzaWduYXR1cmVPdXRwdXQuc2lnbmF0dXJlKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJzNTguZW5jb2RlKHNpZ25hdHVyZUJ5dGVzKTtcbiAgICAgIHJldHVybiB7IHNpZ25hdHVyZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBTb2xhbmEgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNhY3Rpb24gb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbnMucHVzaChzaWduZWRUeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBTb2xhbmEgc2lnbkFsbFRyYW5zYWN0aW9ucyBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzaWduQW5kU2VuZEFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgc2lnbmF0dXJlcy5wdXNoKHJlc3VsdC5zaWduYXR1cmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2lnbmF0dXJlcyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBTb2xhbmEgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnMgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc3dpdGNoTmV0d29yayhfbmV0d29yaykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXkgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB1cCBldmVudCBsaXN0ZW5lcnMgZm9yIFdhbGxldCBTdGFuZGFyZCBldmVudHNcbiAgICogTWFwcyBXYWxsZXQgU3RhbmRhcmQgXCJjaGFuZ2VcIiBldmVudHMgdG8gXCJhY2NvdW50Q2hhbmdlZFwiIGV2ZW50c1xuICAgKlxuICAgKiBOb3RlOiBXYWxsZXQgU3RhbmRhcmQgb25seSBoYXMgYSBcImNoYW5nZVwiIGV2ZW50LiBUaGVyZSBhcmUgbm8gXCJjb25uZWN0XCIgb3IgXCJkaXNjb25uZWN0XCIgZXZlbnRzLlxuICAgKiBDb25uZWN0aW9uL2Rpc2Nvbm5lY3Rpb24gaXMgaW5kaWNhdGVkIGJ5IHRoZSBwcmVzZW5jZSBvciBhYnNlbmNlIG9mIGFjY291bnRzIGluIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGV2ZW50c0ZlYXR1cmUgPSB0aGlzLndhbGxldC5mZWF0dXJlc1tcInN0YW5kYXJkOmV2ZW50c1wiXTtcbiAgICBpZiAoIWV2ZW50c0ZlYXR1cmUpIHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBldmVudHMgZmVhdHVyZSBub3QgYXZhaWxhYmxlXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNldHRpbmcgdXAgV2FsbGV0IFN0YW5kYXJkIGV2ZW50IGxpc3RlbmVyc1wiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZVxuICAgIH0pO1xuICAgIGV2ZW50c0ZlYXR1cmUub24oXCJjaGFuZ2VcIiwgKHByb3BlcnRpZXMpID0+IHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBTdGFuZGFyZCBjaGFuZ2UgZXZlbnQgcmVjZWl2ZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBoYXNBY2NvdW50czogISFwcm9wZXJ0aWVzLmFjY291bnRzLFxuICAgICAgICBhY2NvdW50Q291bnQ6IHByb3BlcnRpZXMuYWNjb3VudHM/Lmxlbmd0aCB8fCAwXG4gICAgICB9KTtcbiAgICAgIGlmIChwcm9wZXJ0aWVzLmFjY291bnRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0QWNjb3VudCA9IHByb3BlcnRpZXMuYWNjb3VudHNbMF07XG4gICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuZXh0cmFjdEFjY291bnRBZGRyZXNzKGZpcnN0QWNjb3VudCk7XG4gICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IGFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiYWNjb3VudENoYW5nZWRcIiwgYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY29ubmVjdFwiLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkVtaXR0ZWQgYWNjb3VudENoYW5nZWQgYW5kIGNvbm5lY3QgZXZlbnRzXCIsIHtcbiAgICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgICAgICAgYWRkcmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiYWNjb3VudENoYW5nZWRcIiwgbnVsbCk7XG4gICAgICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFbWl0dGVkIGFjY291bnRDaGFuZ2VkIGV2ZW50IChudWxsIC0gaW52YWxpZCBhY2NvdW50KVwiLCB7XG4gICAgICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJhY2NvdW50Q2hhbmdlZFwiLCBudWxsKTtcbiAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFbWl0dGVkIGFjY291bnRDaGFuZ2VkIGFuZCBkaXNjb25uZWN0IGV2ZW50c1wiLCB7XG4gICAgICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZXh0cmFjdEFjY291bnRBZGRyZXNzKGFjY291bnQpIHtcbiAgICByZXR1cm4gYWNjb3VudC5hZGRyZXNzO1xuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiQWRkZWQgZXZlbnQgbGlzdGVuZXJcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9XG4gIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJSZW1vdmVkIGV2ZW50IGxpc3RlbmVyXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIGEgdHJhbnNhY3Rpb24gdG8gVWludDhBcnJheSBmb3IgV2FsbGV0IFN0YW5kYXJkIEFQSVxuICAgKi9cbiAgc2VyaWFsaXplVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIFVpbnQ4QXJyYXkgZnJvbSB2YXJpb3VzIGZvcm1hdHNcbiAgICogSGFuZGxlczogVWludDhBcnJheSwgQXJyYXksIG9iamVjdCB3aXRoIG51bWVyaWMga2V5cyAoSlNPTi1zZXJpYWxpemVkIFVpbnQ4QXJyYXkpXG4gICAqL1xuICBwYXJzZVVpbnQ4QXJyYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoTnVtYmVyKS5maWx0ZXIoKGspID0+ICFpc05hTihrKSAmJiBrID49IDApLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWF4S2V5ID0gTWF0aC5tYXgoLi4ua2V5cyk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobWF4S2V5ICsgMSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICBhcnJheVtrZXldID0gTnVtYmVyKHZhbHVlW2tleV0pIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlcnMvaW5qZWN0ZWQvY2hhaW5zL0luamVjdGVkV2FsbGV0RXRoZXJldW1DaGFpbi50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjMgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xudmFyIEluamVjdGVkV2FsbGV0RXRoZXJldW1DaGFpbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIsIHdhbGxldElkLCB3YWxsZXROYW1lKSB7XG4gICAgLy8gRXhwb3NlIGV2ZW50RW1pdHRlciBmb3IgdGVzdGluZyAtIGFsbG93cyB0ZXN0cyB0byB0cmlnZ2VyIGV2ZW50cyBkaXJlY3RseVxuICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcjMoKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFpbklkID0gXCIweDFcIjtcbiAgICB0aGlzLl9hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLndhbGxldElkID0gd2FsbGV0SWQ7XG4gICAgdGhpcy53YWxsZXROYW1lID0gd2FsbGV0TmFtZTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgZ2V0IGNoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluSWQ7XG4gIH1cbiAgZ2V0IGFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50cztcbiAgfVxuICBhc3luYyByZXF1ZXN0KGFyZ3MpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gcmVxdWVzdFwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgIG1ldGhvZDogYXJncy5tZXRob2RcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWlyZXNBdXRoID0gW1xuICAgICAgICBcInBlcnNvbmFsX3NpZ25cIixcbiAgICAgICAgXCJldGhfc2lnblwiLFxuICAgICAgICBcImV0aF9zaWduVHlwZWREYXRhXCIsXG4gICAgICAgIFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixcbiAgICAgICAgXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgIFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiXG4gICAgICBdLmluY2x1ZGVzKGFyZ3MubWV0aG9kKTtcbiAgICAgIGlmIChyZXF1aXJlc0F1dGggJiYgKCF0aGlzLl9jb25uZWN0ZWQgfHwgdGhpcy5fYWNjb3VudHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJNZXRob2QgcmVxdWlyZXMgYXV0aG9yaXphdGlvbiwgZW5zdXJpbmcgY29ubmVjdGlvblwiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICAgIG1ldGhvZDogYXJncy5tZXRob2RcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KGFyZ3MpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSByZXF1ZXN0IHN1Y2Nlc3NcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gNDEwMCkge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJHb3QgNDEwMCBVbmF1dGhvcml6ZWQsIGF0dGVtcHRpbmcgdG8gcmUtYXV0aG9yaXplXCIsIHtcbiAgICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiIH0pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdChhcmdzKTtcbiAgICAgICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHJlcXVlc3Qgc3VjY2VzcyAoYWZ0ZXIgcmUtYXV0aClcIiwge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAocmV0cnlFcnJvcikge1xuICAgICAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRmFpbGVkIGFmdGVyIHJlLWF1dGhvcml6YXRpb25cIiwge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kLFxuICAgICAgICAgICAgZXJyb3I6IHJldHJ5RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJldHJ5RXJyb3IubWVzc2FnZSA6IFN0cmluZyhyZXRyeUVycm9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IHJldHJ5RXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHJlcXVlc3QgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZCxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgZXJyb3JDb2RlOiBlcnJvcj8uY29kZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gY29ubmVjdFwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfcmVxdWVzdEFjY291bnRzXCIgfSk7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBhY2NvdW50cy5sZW5ndGggPiAwO1xuICAgICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gY29ubmVjdGVkICh2aWEgZXRoX3JlcXVlc3RBY2NvdW50cylcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBhY2NvdW50Q291bnQ6IGFjY291bnRzLmxlbmd0aCxcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBjb25uZWN0IGZhaWxlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIGRpc2Nvbm5lY3RcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjY291bnRzID0gW107XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIGRpc2Nvbm5lY3RlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBkaXNjb25uZWN0IGZhaWxlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZSwgYWRkcmVzcykge1xuICAgIGNvbnN0IG1lc3NhZ2VQcmV2aWV3ID0gbWVzc2FnZS5sZW5ndGggPiA1MCA/IG1lc3NhZ2Uuc3Vic3RyaW5nKDAsIDUwKSArIFwiLi4uXCIgOiBtZXNzYWdlO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBzaWduUGVyc29uYWxNZXNzYWdlXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgbWVzc2FnZVByZXZpZXcsXG4gICAgICBtZXNzYWdlTGVuZ3RoOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGFkZHJlc3NcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXJDb25uZWN0ZWQgPSB0aGlzLnByb3ZpZGVyLmlzQ29ubmVjdGVkPy4oKSB8fCB0aGlzLnByb3ZpZGVyLmNvbm5lY3RlZCB8fCBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuX2FjY291bnRzLmxlbmd0aCA9PT0gMCB8fCAhcHJvdmlkZXJDb25uZWN0ZWQpIHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiTm90IGNvbm5lY3RlZCwgYXR0ZW1wdGluZyB0byBjb25uZWN0IGJlZm9yZSBzaWduaW5nXCIsIHtcbiAgICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgICAgaW50ZXJuYWxDb25uZWN0ZWQ6IHRoaXMuX2Nvbm5lY3RlZCxcbiAgICAgICAgICBhY2NvdW50c0xlbmd0aDogdGhpcy5fYWNjb3VudHMubGVuZ3RoLFxuICAgICAgICAgIHByb3ZpZGVyQ29ubmVjdGVkXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEFjY291bnRzID0gdGhpcy5fYWNjb3VudHMubWFwKChhY2MpID0+IGFjYy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmICghbm9ybWFsaXplZEFjY291bnRzLmluY2x1ZGVzKG5vcm1hbGl6ZWRBZGRyZXNzKSkge1xuICAgICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiQWRkcmVzcyBub3QgaW4gY29ubmVjdGVkIGFjY291bnRzLCByZWZyZXNoaW5nIGNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgICByZXF1ZXN0ZWRBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRzOiB0aGlzLl9hY2NvdW50c1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudEFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ3VycmVudEFjY291bnRzID0gY3VycmVudEFjY291bnRzLm1hcCgoYWNjKSA9PiBhY2MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghbm9ybWFsaXplZEN1cnJlbnRBY2NvdW50cy5pbmNsdWRlcyhub3JtYWxpemVkQWRkcmVzcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBpcyBub3QgY29ubmVjdGVkLiBDb25uZWN0ZWQgYWNjb3VudHM6ICR7Y3VycmVudEFjY291bnRzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY2NvdW50cyA9IGN1cnJlbnRBY2NvdW50cztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm92aWRlci5zaWduUGVyc29uYWxNZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlLCBhZGRyZXNzKTtcbiAgICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBzaWduUGVyc29uYWxNZXNzYWdlIHN1Y2Nlc3NcIiwge1xuICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgICBzaWduYXR1cmVMZW5ndGg6IHJlc3VsdDIubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJwZXJzb25hbF9zaWduXCIsXG4gICAgICAgIHBhcmFtczogW21lc3NhZ2UsIGFkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc2lnblBlcnNvbmFsTWVzc2FnZSBzdWNjZXNzXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgc2lnbmF0dXJlTGVuZ3RoOiByZXN1bHQubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNpZ25QZXJzb25hbE1lc3NhZ2UgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgZXJyb3JDb2RlOiBlcnJvcj8uY29kZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnblR5cGVkRGF0YSh0eXBlZERhdGEsIGFkZHJlc3MpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc2lnblR5cGVkRGF0YVwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgIHByaW1hcnlUeXBlOiB0eXBlZERhdGE/LnByaW1hcnlUeXBlLFxuICAgICAgYWRkcmVzc1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJvdmlkZXIuc2lnblR5cGVkRGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnNpZ25UeXBlZERhdGEodHlwZWREYXRhLCBhZGRyZXNzKTtcbiAgICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBzaWduVHlwZWREYXRhIHN1Y2Nlc3NcIiwge1xuICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgICBzaWduYXR1cmVMZW5ndGg6IHJlc3VsdDIubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLFxuICAgICAgICBwYXJhbXM6IFthZGRyZXNzLCB0eXBlZERhdGFdXG4gICAgICB9KTtcbiAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc2lnblR5cGVkRGF0YSBzdWNjZXNzXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgc2lnbmF0dXJlTGVuZ3RoOiByZXN1bHQubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNpZ25UeXBlZERhdGEgZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNpZ25UcmFuc2FjdGlvblwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgIGZyb206IHRyYW5zYWN0aW9uLmZyb20sXG4gICAgICB0bzogdHJhbnNhY3Rpb24udG9cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3ZpZGVyLnNpZ25UcmFuc2FjdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc2lnblRyYW5zYWN0aW9uIHN1Y2Nlc3NcIiwge1xuICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgICBzaWduYXR1cmVMZW5ndGg6IHJlc3VsdDIubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJldGhfc2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHBhcmFtczogW3RyYW5zYWN0aW9uXVxuICAgICAgfSk7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNpZ25UcmFuc2FjdGlvbiBzdWNjZXNzXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgc2lnbmF0dXJlTGVuZ3RoOiByZXN1bHQubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNpZ25UcmFuc2FjdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc2VuZFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgZnJvbTogdHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgIHRvOiB0cmFuc2FjdGlvbi50byxcbiAgICAgIHZhbHVlOiB0cmFuc2FjdGlvbi52YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBzZW5kVHJhbnNhY3Rpb24gc3VjY2Vzc1wiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICAgIHR4SGFzaDogcmVzdWx0MlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICBwYXJhbXM6IFt0cmFuc2FjdGlvbl1cbiAgICAgIH0pO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkV4dGVybmFsIHdhbGxldCBFdGhlcmV1bSBzZW5kVHJhbnNhY3Rpb24gc3VjY2Vzc1wiLCB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB3YWxsZXROYW1lOiB0aGlzLndhbGxldE5hbWUsXG4gICAgICAgIHR4SGFzaDogcmVzdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHNlbmRUcmFuc2FjdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBzd2l0Y2hDaGFpbihjaGFpbklkKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHN3aXRjaENoYWluXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgY2hhaW5JZFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZXhDaGFpbklkID0gdHlwZW9mIGNoYWluSWQgPT09IFwic3RyaW5nXCIgPyBjaGFpbklkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcIjB4XCIpID8gY2hhaW5JZCA6IGAweCR7cGFyc2VJbnQoY2hhaW5JZCwgMTApLnRvU3RyaW5nKDE2KX1gIDogYDB4JHtjaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3ZpZGVyLnN3aXRjaENoYWluID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm92aWRlci5zd2l0Y2hDaGFpbihoZXhDaGFpbklkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogXCJ3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpblwiLCBwYXJhbXM6IFt7IGNoYWluSWQ6IGhleENoYWluSWQgfV0gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFpbklkID0gaGV4Q2hhaW5JZDtcbiAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5fY2hhaW5JZCk7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXh0ZXJuYWwgd2FsbGV0IEV0aGVyZXVtIHN3aXRjaENoYWluIHN1Y2Nlc3NcIiwge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogdGhpcy53YWxsZXROYW1lLFxuICAgICAgICBjaGFpbklkOiBoZXhDaGFpbklkXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFeHRlcm5hbCB3YWxsZXQgRXRoZXJldW0gc3dpdGNoQ2hhaW4gZmFpbGVkXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIHdhbGxldE5hbWU6IHRoaXMud2FsbGV0TmFtZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucHJvdmlkZXIuZ2V0Q2hhaW5JZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBjaGFpbklkMiA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICAgICAgdGhpcy5fY2hhaW5JZCA9IGAweCR7Y2hhaW5JZDIudG9TdHJpbmcoMTYpfWA7XG4gICAgICByZXR1cm4gY2hhaW5JZDI7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiB9KTtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgdGhpcy5fY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucHJvdmlkZXIuZ2V0QWNjb3VudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgYWNjb3VudHMyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRBY2NvdW50cygpO1xuICAgICAgdGhpcy5fYWNjb3VudHMgPSBhY2NvdW50czI7XG4gICAgICByZXR1cm4gYWNjb3VudHMyO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfYWNjb3VudHNcIiB9KTtcbiAgICB0aGlzLl9hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnByb3ZpZGVyLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIub24oXCJjb25uZWN0XCIsIChpbmZvKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoYWluSWQgPSBpbmZvLmNoYWluSWQ7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjb25uZWN0XCIsIGluZm8pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FjY291bnRzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJkaXNjb25uZWN0XCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBbXSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKGFjY291bnRzKSA9PiB7XG4gICAgICAgIHRoaXMuX2FjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGFjY291bnRzLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgYWNjb3VudHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3ZpZGVyLm9uKFwiY2hhaW5DaGFuZ2VkXCIsIChjaGFpbklkKSA9PiB7XG4gICAgICAgIHRoaXMuX2NoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY2hhaW5DaGFuZ2VkXCIsIGNoYWluSWQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvd2FsbGV0cy9yZWdpc3RyeS50c1xuZnVuY3Rpb24gaXNQaGFudG9tV2FsbGV0KHdhbGxldCkge1xuICByZXR1cm4gd2FsbGV0ICE9PSB2b2lkIDAgJiYgd2FsbGV0LmlkID09PSBcInBoYW50b21cIiAmJiBcImlzUGhhbnRvbVwiIGluIHdhbGxldCAmJiB3YWxsZXQuaXNQaGFudG9tID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNXYWxsZXRTdGFuZGFyZFdhbGxldChwcm92aWRlcikge1xuICByZXR1cm4gcHJvdmlkZXIgIT09IG51bGwgJiYgdHlwZW9mIHByb3ZpZGVyID09PSBcIm9iamVjdFwiICYmIFwiZmVhdHVyZXNcIiBpbiBwcm92aWRlciAmJiB0eXBlb2YgcHJvdmlkZXIuZmVhdHVyZXMgPT09IFwib2JqZWN0XCI7XG59XG52YXIgSW5qZWN0ZWRXYWxsZXRSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy53YWxsZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRpc2NvdmVyeVByb21pc2UgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyKGluZm8pIHtcbiAgICBjb25zdCB3cmFwcGVkUHJvdmlkZXJzID0ge307XG4gICAgaWYgKGluZm8ucHJvdmlkZXJzPy5zb2xhbmEpIHtcbiAgICAgIGlmIChpc1dhbGxldFN0YW5kYXJkV2FsbGV0KGluZm8ucHJvdmlkZXJzLnNvbGFuYSkpIHtcbiAgICAgICAgd3JhcHBlZFByb3ZpZGVycy5zb2xhbmEgPSBuZXcgV2FsbGV0U3RhbmRhcmRTb2xhbmFBZGFwdGVyKGluZm8ucHJvdmlkZXJzLnNvbGFuYSwgaW5mby5pZCwgaW5mby5uYW1lKTtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiV3JhcHBlZCBXYWxsZXQgU3RhbmRhcmQgU29sYW5hIHdhbGxldCB3aXRoIGFkYXB0ZXJcIiwge1xuICAgICAgICAgIHdhbGxldElkOiBpbmZvLmlkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IGluZm8ubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZWRQcm92aWRlcnMuc29sYW5hID0gbmV3IEluamVjdGVkV2FsbGV0U29sYW5hQ2hhaW4oaW5mby5wcm92aWRlcnMuc29sYW5hLCBpbmZvLmlkLCBpbmZvLm5hbWUpO1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXcmFwcGVkIFNvbGFuYSBwcm92aWRlciB3aXRoIEluamVjdGVkV2FsbGV0U29sYW5hQ2hhaW5cIiwge1xuICAgICAgICAgIHdhbGxldElkOiBpbmZvLmlkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IGluZm8ubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZm8ucHJvdmlkZXJzPy5ldGhlcmV1bSkge1xuICAgICAgd3JhcHBlZFByb3ZpZGVycy5ldGhlcmV1bSA9IG5ldyBJbmplY3RlZFdhbGxldEV0aGVyZXVtQ2hhaW4oaW5mby5wcm92aWRlcnMuZXRoZXJldW0sIGluZm8uaWQsIGluZm8ubmFtZSk7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXcmFwcGVkIEV0aGVyZXVtIHByb3ZpZGVyIHdpdGggSW5qZWN0ZWRXYWxsZXRFdGhlcmV1bUNoYWluXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IGluZm8uaWQsXG4gICAgICAgIHdhbGxldE5hbWU6IGluZm8ubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRJbmZvID0ge1xuICAgICAgLi4uaW5mbyxcbiAgICAgIHByb3ZpZGVyczogT2JqZWN0LmtleXMod3JhcHBlZFByb3ZpZGVycykubGVuZ3RoID4gMCA/IHdyYXBwZWRQcm92aWRlcnMgOiBpbmZvLnByb3ZpZGVyc1xuICAgIH07XG4gICAgdGhpcy53YWxsZXRzLnNldChpbmZvLmlkLCB3cmFwcGVkSW5mbyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIFBoYW50b20gd2FsbGV0IHdpdGggaXRzIGluc3RhbmNlXG4gICAqIFRoaXMgY3JlYXRlcyB3cmFwcGVkIHByb3ZpZGVycyBhbmQgc3RvcmVzIHRoZSBQaGFudG9tIGluc3RhbmNlIGZvciBhdXRvLWNvbmZpcm0gYWNjZXNzXG4gICAqIFVzZXMgdW5pZmllZCBJbmplY3RlZFdhbGxldCBjaGFpbnMgZm9yIGJvdGggUGhhbnRvbSBhbmQgZXh0ZXJuYWwgd2FsbGV0c1xuICAgKi9cbiAgcmVnaXN0ZXJQaGFudG9tKHBoYW50b21JbnN0YW5jZSwgYWRkcmVzc1R5cGVzKSB7XG4gICAgY29uc3Qgd3JhcHBlZFByb3ZpZGVycyA9IHt9O1xuICAgIGlmIChhZGRyZXNzVHlwZXMuaW5jbHVkZXMoQWRkcmVzc1R5cGUuc29sYW5hKSAmJiBwaGFudG9tSW5zdGFuY2Uuc29sYW5hKSB7XG4gICAgICB3cmFwcGVkUHJvdmlkZXJzLnNvbGFuYSA9IG5ldyBJbmplY3RlZFdhbGxldFNvbGFuYUNoYWluKHBoYW50b21JbnN0YW5jZS5zb2xhbmEsIFwicGhhbnRvbVwiLCBcIlBoYW50b21cIik7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJDcmVhdGVkIEluamVjdGVkV2FsbGV0U29sYW5hQ2hhaW4gd3JhcHBlciBmb3IgUGhhbnRvbVwiLCB7XG4gICAgICAgIHdhbGxldElkOiBcInBoYW50b21cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzVHlwZXMuaW5jbHVkZXMoQWRkcmVzc1R5cGUuZXRoZXJldW0pICYmIHBoYW50b21JbnN0YW5jZS5ldGhlcmV1bSkge1xuICAgICAgd3JhcHBlZFByb3ZpZGVycy5ldGhlcmV1bSA9IG5ldyBJbmplY3RlZFdhbGxldEV0aGVyZXVtQ2hhaW4ocGhhbnRvbUluc3RhbmNlLmV0aGVyZXVtLCBcInBoYW50b21cIiwgXCJQaGFudG9tXCIpO1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQ3JlYXRlZCBJbmplY3RlZFdhbGxldEV0aGVyZXVtQ2hhaW4gd3JhcHBlciBmb3IgUGhhbnRvbVwiLCB7XG4gICAgICAgIHdhbGxldElkOiBcInBoYW50b21cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBoYW50b21XYWxsZXQgPSB7XG4gICAgICBpZDogXCJwaGFudG9tXCIsXG4gICAgICBuYW1lOiBcIlBoYW50b21cIixcbiAgICAgIGljb246IFwiXCIsXG4gICAgICAvLyBJY29uIHdpbGwgYmUgcmVuZGVyZWQgZnJvbSBpY29ucyBwYWNrYWdlIGluIFVJIGNvbXBvbmVudHNcbiAgICAgIGFkZHJlc3NUeXBlcyxcbiAgICAgIHByb3ZpZGVyczogd3JhcHBlZFByb3ZpZGVycyxcbiAgICAgIGlzUGhhbnRvbTogdHJ1ZSxcbiAgICAgIHBoYW50b21JbnN0YW5jZSxcbiAgICAgIGRpc2NvdmVyeTogXCJwaGFudG9tXCJcbiAgICB9O1xuICAgIHRoaXMud2FsbGV0cy5zZXQoXCJwaGFudG9tXCIsIHBoYW50b21XYWxsZXQpO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIlJlZ2lzdGVyZWQgUGhhbnRvbSB3YWxsZXQgd2l0aCBjaGFpbiB3cmFwcGVyc1wiLCB7XG4gICAgICBhZGRyZXNzVHlwZXMsXG4gICAgICBoYXNTb2xhbmE6ICEhd3JhcHBlZFByb3ZpZGVycy5zb2xhbmEsXG4gICAgICBoYXNFdGhlcmV1bTogISF3cmFwcGVkUHJvdmlkZXJzLmV0aGVyZXVtXG4gICAgfSk7XG4gIH1cbiAgdW5yZWdpc3RlcihpZCkge1xuICAgIHRoaXMud2FsbGV0cy5kZWxldGUoaWQpO1xuICB9XG4gIGhhcyhpZCkge1xuICAgIHJldHVybiB0aGlzLndhbGxldHMuaGFzKGlkKTtcbiAgfVxuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMud2FsbGV0cy5nZXQoaWQpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLndhbGxldHMudmFsdWVzKCkpO1xuICB9XG4gIGdldEJ5QWRkcmVzc1R5cGVzKGFkZHJlc3NUeXBlcykge1xuICAgIGlmIChhZGRyZXNzVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbGwoKTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dlZCA9IG5ldyBTZXQoYWRkcmVzc1R5cGVzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maWx0ZXIoKHdhbGxldCkgPT4gd2FsbGV0LmFkZHJlc3NUeXBlcy5zb21lKCh0KSA9PiBhbGxvd2VkLmhhcyh0KSkpO1xuICB9XG4gIGRpc2NvdmVyKGFkZHJlc3NUeXBlcykge1xuICAgIGlmICh0aGlzLmRpc2NvdmVyeVByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2NvdmVyeVByb21pc2U7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIlN0YXJ0aW5nIHdhbGxldCBkaXNjb3ZlcnlcIiwgeyBhZGRyZXNzVHlwZXMgfSk7XG4gICAgdGhpcy5kaXNjb3ZlcnlQcm9taXNlID0gZGlzY292ZXJXYWxsZXRzKGFkZHJlc3NUeXBlcykudGhlbigoZGlzY292ZXJlZFdhbGxldHMpID0+IHtcbiAgICAgIGNvbnN0IHJlbGV2YW50V2FsbGV0cyA9IGFkZHJlc3NUeXBlcyA/IGRpc2NvdmVyZWRXYWxsZXRzLmZpbHRlcigod2FsbGV0KSA9PiB3YWxsZXQuYWRkcmVzc1R5cGVzLnNvbWUoKHR5cGUpID0+IGFkZHJlc3NUeXBlcy5pbmNsdWRlcyh0eXBlKSkpIDogZGlzY292ZXJlZFdhbGxldHM7XG4gICAgICBmb3IgKGNvbnN0IHdhbGxldCBvZiByZWxldmFudFdhbGxldHMpIHtcbiAgICAgICAgaWYgKHdhbGxldC5pZCA9PT0gXCJwaGFudG9tXCIgJiYgaXNQaGFudG9tV2FsbGV0KHdhbGxldCkpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyUGhhbnRvbSh3YWxsZXQucGhhbnRvbUluc3RhbmNlLCB3YWxsZXQuYWRkcmVzc1R5cGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHdhbGxldCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiUmVnaXN0ZXJlZCBkaXNjb3ZlcmVkIHdhbGxldFwiLCB7XG4gICAgICAgICAgaWQ6IHdhbGxldC5pZCxcbiAgICAgICAgICBuYW1lOiB3YWxsZXQubmFtZSxcbiAgICAgICAgICBhZGRyZXNzVHlwZXM6IHdhbGxldC5hZGRyZXNzVHlwZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiV2FsbGV0IGRpc2NvdmVyeSBjb21wbGV0ZWRcIiwge1xuICAgICAgICB0b3RhbERpc2NvdmVyZWQ6IGRpc2NvdmVyZWRXYWxsZXRzLmxlbmd0aCxcbiAgICAgICAgcmVsZXZhbnRXYWxsZXRzOiByZWxldmFudFdhbGxldHMubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGRlYnVnLndhcm4oRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJXYWxsZXQgZGlzY292ZXJ5IGZhaWxlZFwiLCB7IGVycm9yIH0pO1xuICAgICAgdGhpcy5kaXNjb3ZlcnlQcm9taXNlID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRpc2NvdmVyeVByb21pc2U7XG4gIH1cbn07XG52YXIgd2FsbGV0UmVnaXN0cnkgPSBudWxsO1xuZnVuY3Rpb24gZ2V0V2FsbGV0UmVnaXN0cnkoKSB7XG4gIGlmICghd2FsbGV0UmVnaXN0cnkpIHtcbiAgICB3YWxsZXRSZWdpc3RyeSA9IG5ldyBJbmplY3RlZFdhbGxldFJlZ2lzdHJ5KCk7XG4gIH1cbiAgcmV0dXJuIHdhbGxldFJlZ2lzdHJ5O1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2luamVjdGVkL2luZGV4LnRzXG52YXIgV0FTX0NPTk5FQ1RFRF9LRVkgPSBcInBoYW50b20taW5qZWN0ZWQtd2FzLWNvbm5lY3RlZFwiO1xudmFyIFdBU19DT05ORUNURURfVkFMVUUgPSBcInRydWVcIjtcbnZhciBMQVNUX1dBTExFVF9JRF9LRVkgPSBcInBoYW50b20taW5qZWN0ZWQtbGFzdC13YWxsZXQtaWRcIjtcbnZhciBJbmplY3RlZFByb3ZpZGVyID0gY2xhc3Mge1xuICAvLyBTdG9yZSBjbGVhbnVwcyBwZXIgd2FsbGV0SWRcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5zZWxlY3RlZFdhbGxldElkID0gbnVsbDtcbiAgICB0aGlzLndhbGxldFN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLy8gRXZlbnQgbWFuYWdlbWVudFxuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZXZlbnRzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzU2V0dXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8vIFRyYWNrIHdhbGxldElkIHRoYXQgaGF2ZSBsaXN0ZW5lcnMgc2V0IHVwXG4gICAgdGhpcy5ldmVudExpc3RlbmVyQ2xlYW51cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkluaXRpYWxpemluZyBJbmplY3RlZFByb3ZpZGVyXCIsIHsgY29uZmlnIH0pO1xuICAgIHRoaXMuYWRkcmVzc1R5cGVzID0gY29uZmlnLmFkZHJlc3NUeXBlcztcbiAgICB0aGlzLndhbGxldFJlZ2lzdHJ5ID0gZ2V0V2FsbGV0UmVnaXN0cnkoKTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJBZGRyZXNzIHR5cGVzIGNvbmZpZ3VyZWRcIiwgeyBhZGRyZXNzVHlwZXM6IHRoaXMuYWRkcmVzc1R5cGVzIH0pO1xuICAgIHRoaXMud2FsbGV0UmVnaXN0cnkuZGlzY292ZXIodGhpcy5hZGRyZXNzVHlwZXMpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBkaXNjb3ZlcnkgZmFpbGVkIGR1cmluZyBpbml0aWFsaXphdGlvblwiLCB7IGVycm9yIH0pO1xuICAgIH0pO1xuICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJJbmplY3RlZFByb3ZpZGVyIGluaXRpYWxpemVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBXYWl0IGZvciB3YWxsZXQgZGlzY292ZXJ5IHRvIGNvbXBsZXRlIGlmIHRoZSB3YWxsZXQgaXMgbm90IHlldCBpbiB0aGUgcmVnaXN0cnlcbiAgICogVGhpcyBpcyBuZWVkZWQgZm9yIGF1dG8tY29ubmVjdCB3aGVuIHRoZSBsYXN0IHdhbGxldCB3YXMgYW4gZXh0ZXJuYWwgd2FsbGV0XG4gICAqL1xuICBhc3luYyB3YWl0Rm9yV2FsbGV0RGlzY292ZXJ5KHdhbGxldElkKSB7XG4gICAgaWYgKHRoaXMud2FsbGV0UmVnaXN0cnkuaGFzKHdhbGxldElkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJXYWxsZXQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5LCB3YWl0aW5nIGZvciBkaXNjb3ZlcnlcIiwge1xuICAgICAgd2FsbGV0SWRcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy53YWxsZXRSZWdpc3RyeS5kaXNjb3Zlcih0aGlzLmFkZHJlc3NUeXBlcyk7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJXYWxsZXQgZGlzY292ZXJ5IGNvbXBsZXRlZFwiLCB7IHdhbGxldElkIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiV2FsbGV0IGRpc2NvdmVyeSBmYWlsZWRcIiwge1xuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGdldCBhIGNoYWluIHByb3ZpZGVyIHdpdGggY29uc2lzdGVudCBlcnJvciBoYW5kbGluZ1xuICAgKi9cbiAgZ2V0Q2hhaW5Qcm92aWRlcihhZGRyZXNzVHlwZSwgcHJvdmlkZXJLZXksIGNoYWluTmFtZSkge1xuICAgIGlmICghdGhpcy5hZGRyZXNzVHlwZXMuaW5jbHVkZXMoYWRkcmVzc1R5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hhaW5OYW1lfSBub3QgZW5hYmxlZCBmb3IgdGhpcyBwcm92aWRlcmApO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRJZCA9IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCB8fCBcInBoYW50b21cIjtcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHdhbGxldElkKTtcbiAgICBpZiAoIXdhbGxldEluZm8pIHtcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gdGhpcy53YWxsZXRSZWdpc3RyeTtcbiAgICAgIGlmIChyZWdpc3RyeS5kaXNjb3ZlcnlQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgV2FsbGV0IFwiJHt3YWxsZXRJZH1cIiBub3QgZm91bmQuIFdhbGxldCBkaXNjb3ZlcnkgaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuIFBsZWFzZSB3YWl0IGZvciBzZGsuZGlzY292ZXJXYWxsZXRzKCkgdG8gY29tcGxldGUgYmVmb3JlIGFjY2Vzc2luZyBjaGFpbiBwcm9wZXJ0aWVzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFdhbGxldCBcIiR7d2FsbGV0SWR9XCIgbm90IGZvdW5kLiBQbGVhc2UgZW5zdXJlIHdhbGxldCBkaXNjb3ZlcnkgaGFzIGNvbXBsZXRlZC4gTWFrZSBzdXJlIHlvdSBjYWxsIHNkay5kaXNjb3ZlcldhbGxldHMoKSBhbmQgYXdhaXQgaXQgYmVmb3JlIGFjY2Vzc2luZyBjaGFpbiBwcm9wZXJ0aWVzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gd2FsbGV0SW5mby5wcm92aWRlcnM/Lltwcm92aWRlcktleV07XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgU2VsZWN0ZWQgd2FsbGV0IFwiJHt3YWxsZXRJbmZvLm5hbWV9XCIgZG9lcyBub3Qgc3VwcG9ydCAke2NoYWluTmFtZX0uIFRoaXMgd2FsbGV0IG9ubHkgc3VwcG9ydHM6ICR7d2FsbGV0SW5mby5hZGRyZXNzVHlwZXMuam9pbihcIiwgXCIpfS4gTWFrZSBzdXJlIHlvdXIgU0RLIGNvbmZpZyBpbmNsdWRlcyAke2NoYWluTmFtZX0gaW4gYWRkcmVzc1R5cGVzLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBnZXQgc29sYW5hKCkge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluUHJvdmlkZXIoQWRkcmVzc1R5cGUyLnNvbGFuYSwgXCJzb2xhbmFcIiwgXCJTb2xhbmFcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VzcyB0byBFdGhlcmV1bSBjaGFpbiBvcGVyYXRpb25zXG4gICAqL1xuICBnZXQgZXRoZXJldW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW5Qcm92aWRlcihBZGRyZXNzVHlwZTIuZXRoZXJldW0sIFwiZXRoZXJldW1cIiwgXCJFdGhlcmV1bVwiKTtcbiAgfVxuICB2YWxpZGF0ZUFuZFNlbGVjdFdhbGxldChyZXF1ZXN0ZWRXYWxsZXRJZCkge1xuICAgIGlmICghdGhpcy53YWxsZXRSZWdpc3RyeS5oYXMocmVxdWVzdGVkV2FsbGV0SWQpKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlVua25vd24gaW5qZWN0ZWQgd2FsbGV0IGlkIHJlcXVlc3RlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiByZXF1ZXN0ZWRXYWxsZXRJZFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaW5qZWN0ZWQgd2FsbGV0IGlkOiAke3JlcXVlc3RlZFdhbGxldElkfWApO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHJlcXVlc3RlZFdhbGxldElkKTtcbiAgICBpZiAoIXdhbGxldEluZm8gfHwgIXdhbGxldEluZm8ucHJvdmlkZXJzKSB7XG4gICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiV2FsbGV0IG5vdCBhdmFpbGFibGUgZm9yIGNvbm5lY3Rpb25cIiwge1xuICAgICAgICB3YWxsZXRJZDogcmVxdWVzdGVkV2FsbGV0SWRcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQgbm90IGF2YWlsYWJsZSBmb3IgY29ubmVjdGlvbjogJHtyZXF1ZXN0ZWRXYWxsZXRJZH1gKTtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZFdhbGxldElkID0gcmVxdWVzdGVkV2FsbGV0SWQ7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiU2VsZWN0ZWQgaW5qZWN0ZWQgd2FsbGV0IGZvciBjb25uZWN0aW9uXCIsIHtcbiAgICAgIHdhbGxldElkOiByZXF1ZXN0ZWRXYWxsZXRJZFxuICAgIH0pO1xuICAgIHJldHVybiB3YWxsZXRJbmZvO1xuICB9XG4gIGFzeW5jIGNvbm5lY3RUb1dhbGxldCh3YWxsZXRJbmZvLCBvcHRpb25zKSB7XG4gICAgaWYgKCF3YWxsZXRJbmZvLnByb3ZpZGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFdhbGxldCBhZGFwdGVyIG5vdCBhdmFpbGFibGUgZm9yIHdhbGxldDogJHt0aGlzLnNlbGVjdGVkV2FsbGV0SWR9YCk7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIldhbGxldCBhZGFwdGVyIG5vdCBhdmFpbGFibGVcIiwgeyB3YWxsZXRJZDogdGhpcy5zZWxlY3RlZFdhbGxldElkIH0pO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IG9wdGlvbnM/LnNraXBFdmVudExpc3RlbmVycyA/IFwiYXV0by1jb25uZWN0XCIgOiBcIm1hbnVhbC1jb25uZWN0XCJcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkNvbm5lY3RpbmcgdmlhIHdhbGxldFwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy5zZWxlY3RlZFdhbGxldElkLFxuICAgICAgd2FsbGV0TmFtZTogd2FsbGV0SW5mby5uYW1lLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucz8uc2tpcEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMod2FsbGV0SW5mbyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3RlZEFkZHJlc3NlcyA9IFtdO1xuICAgIGlmICh0aGlzLmFkZHJlc3NUeXBlcy5pbmNsdWRlcyhBZGRyZXNzVHlwZTIuc29sYW5hKSAmJiB3YWxsZXRJbmZvLnByb3ZpZGVycz8uc29sYW5hKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJBdHRlbXB0aW5nIFNvbGFuYSBjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogd2FsbGV0SW5mby5uYW1lLFxuICAgICAgICBvbmx5SWZUcnVzdGVkOiBvcHRpb25zPy5vbmx5SWZUcnVzdGVkXG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdhbGxldEluZm8ucHJvdmlkZXJzLnNvbGFuYS5jb25uZWN0KFxuICAgICAgICAgIG9wdGlvbnM/Lm9ubHlJZlRydXN0ZWQgPyB7IG9ubHlJZlRydXN0ZWQ6IHRydWUgfSA6IHZvaWQgMFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gcmVzdWx0LnB1YmxpY0tleTtcbiAgICAgICAgY29ubmVjdGVkQWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3NUeXBlOiBBZGRyZXNzVHlwZTIuc29sYW5hLFxuICAgICAgICAgIGFkZHJlc3NcbiAgICAgICAgfSk7XG4gICAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJTb2xhbmEgY29ubmVjdGVkIHN1Y2Nlc3NmdWxseVwiLCB7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICB3YWxsZXRJZDogdGhpcy5zZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldEluZm8ubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRmFpbGVkIHRvIGNvbm5lY3QgU29sYW5hLCBzdG9wcGluZ1wiLCB7XG4gICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICB3YWxsZXRJZDogdGhpcy5zZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldEluZm8ubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjb25uZWN0XCIsXG4gICAgICAgICAgc291cmNlOiBvcHRpb25zPy5za2lwRXZlbnRMaXN0ZW5lcnMgPyBcImF1dG8tY29ubmVjdFwiIDogXCJtYW51YWwtY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmFkZHJlc3NUeXBlcy5pbmNsdWRlcyhBZGRyZXNzVHlwZTIuZXRoZXJldW0pICYmIHdhbGxldEluZm8ucHJvdmlkZXJzPy5ldGhlcmV1bSkge1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiQXR0ZW1wdGluZyBFdGhlcmV1bSBjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgd2FsbGV0TmFtZTogd2FsbGV0SW5mby5uYW1lLFxuICAgICAgICBzaWxlbnQ6IG9wdGlvbnM/LnNpbGVudFxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgYWNjb3VudHM7XG4gICAgICAgIGlmIChvcHRpb25zPy5zaWxlbnQpIHtcbiAgICAgICAgICBhY2NvdW50cyA9IGF3YWl0IHdhbGxldEluZm8ucHJvdmlkZXJzLmV0aGVyZXVtLnJlcXVlc3QoeyBtZXRob2Q6IFwiZXRoX2FjY291bnRzXCIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjb3VudHMgPSBhd2FpdCB3YWxsZXRJbmZvLnByb3ZpZGVycy5ldGhlcmV1bS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25uZWN0ZWRBZGRyZXNzZXMucHVzaChcbiAgICAgICAgICAgIC4uLmFjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gKHtcbiAgICAgICAgICAgICAgYWRkcmVzc1R5cGU6IEFkZHJlc3NUeXBlMi5ldGhlcmV1bSxcbiAgICAgICAgICAgICAgYWRkcmVzc1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXRoZXJldW0gY29ubmVjdGVkIHN1Y2Nlc3NmdWxseVwiLCB7XG4gICAgICAgICAgICBhZGRyZXNzZXM6IGFjY291bnRzLFxuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldEluZm8ubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkZhaWxlZCB0byBjb25uZWN0IEV0aGVyZXVtLCBzdG9wcGluZ1wiLCB7XG4gICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICB3YWxsZXRJZDogdGhpcy5zZWxlY3RlZFdhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldEluZm8ubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjb25uZWN0XCIsXG4gICAgICAgICAgc291cmNlOiBvcHRpb25zPy5za2lwRXZlbnRMaXN0ZW5lcnMgPyBcImF1dG8tY29ubmVjdFwiIDogXCJtYW51YWwtY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0ZWRBZGRyZXNzZXM7XG4gIH1cbiAgYXN5bmMgZmluYWxpemVDb25uZWN0aW9uKGNvbm5lY3RlZEFkZHJlc3NlcywgYXV0aFByb3ZpZGVyLCB3YWxsZXRJZCkge1xuICAgIGlmIChjb25uZWN0ZWRBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIGFueSBzdXBwb3J0ZWQgd2FsbGV0IHByb3ZpZGVyXCIpO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBzb3VyY2U6IFwibWFudWFsLWNvbm5lY3RcIlxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgdGhpcy5zZXRXYWxsZXRTdGF0ZSh0aGlzLnNlbGVjdGVkV2FsbGV0SWQsIHtcbiAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICBhZGRyZXNzZXM6IGNvbm5lY3RlZEFkZHJlc3Nlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkZpbmFsaXplZCBjb25uZWN0aW9uIHdpdGggYWRkcmVzc2VzXCIsIHtcbiAgICAgIGFkZHJlc3NDb3VudDogY29ubmVjdGVkQWRkcmVzc2VzLmxlbmd0aCxcbiAgICAgIGFkZHJlc3NlczogY29ubmVjdGVkQWRkcmVzc2VzLm1hcCgoYWRkcikgPT4gKHtcbiAgICAgICAgdHlwZTogYWRkci5hZGRyZXNzVHlwZSxcbiAgICAgICAgYWRkcmVzczogYWRkci5hZGRyZXNzLnN1YnN0cmluZygwLCAxMCkgKyBcIi4uLlwiXG4gICAgICB9KSlcbiAgICB9KTtcbiAgICBjb25zdCBhdXRoVXNlcklkID0gYXdhaXQgdGhpcy5nZXRBdXRoVXNlcklkKFwibWFudWFsLWNvbm5lY3RcIik7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFdBU19DT05ORUNURURfS0VZLCBXQVNfQ09OTkVDVEVEX1ZBTFVFKTtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNldCB3YXMtY29ubmVjdGVkIGZsYWcgLSBhdXRvLXJlY29ubmVjdCBlbmFibGVkXCIpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMQVNUX1dBTExFVF9JRF9LRVksIHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlN0b3JlZCBsYXN0IGluamVjdGVkIHdhbGxldCBpZFwiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkZhaWxlZCB0byBwZXJzaXN0IGluamVjdGVkIHByb3ZpZGVyIHN0YXRlXCIsIHsgZXJyb3IgfSk7XG4gICAgfVxuICAgIGNvbnN0IHdhbGxldEluZm8gPSB3YWxsZXRJZCA/IHRoaXMud2FsbGV0UmVnaXN0cnkuZ2V0QnlJZCh3YWxsZXRJZCkgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0SW5mbyA/IHtcbiAgICAgIGlkOiB3YWxsZXRJbmZvLmlkLFxuICAgICAgbmFtZTogd2FsbGV0SW5mby5uYW1lLFxuICAgICAgaWNvbjogd2FsbGV0SW5mby5pY29uLFxuICAgICAgYWRkcmVzc1R5cGVzOiB3YWxsZXRJbmZvLmFkZHJlc3NUeXBlcyxcbiAgICAgIHJkbnM6IHdhbGxldEluZm8ucmRucyxcbiAgICAgIGRpc2NvdmVyeTogd2FsbGV0SW5mby5kaXNjb3ZlcnlcbiAgICB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGFkZHJlc3NlczogY29ubmVjdGVkQWRkcmVzc2VzLFxuICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgYXV0aFVzZXJJZCxcbiAgICAgIGF1dGhQcm92aWRlcixcbiAgICAgIHdhbGxldElkLFxuICAgICAgd2FsbGV0XG4gICAgfTtcbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgIGFkZHJlc3NlczogY29ubmVjdGVkQWRkcmVzc2VzLFxuICAgICAgc291cmNlOiBcIm1hbnVhbC1jb25uZWN0XCIsXG4gICAgICBhdXRoVXNlcklkXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25uZWN0KGF1dGhPcHRpb25zKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlN0YXJ0aW5nIGluamVjdGVkIHByb3ZpZGVyIGNvbm5lY3RcIiwge1xuICAgICAgYWRkcmVzc1R5cGVzOiB0aGlzLmFkZHJlc3NUeXBlcyxcbiAgICAgIHByb3ZpZGVyOiBhdXRoT3B0aW9ucy5wcm92aWRlclxuICAgIH0pO1xuICAgIGlmIChhdXRoT3B0aW9ucy5wcm92aWRlciAhPT0gXCJpbmplY3RlZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvdmlkZXIgZm9yIGluamVjdGVkIGNvbm5lY3Rpb246ICR7YXV0aE9wdGlvbnMucHJvdmlkZXJ9LiBNdXN0IGJlIFwiaW5qZWN0ZWRcImApO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0X3N0YXJ0XCIsIHtcbiAgICAgIHNvdXJjZTogXCJtYW51YWwtY29ubmVjdFwiLFxuICAgICAgcHJvdmlkZXJUeXBlOiBcImluamVjdGVkXCJcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdGVkV2FsbGV0SWQgPSBhdXRoT3B0aW9ucy53YWxsZXRJZCB8fCBcInBoYW50b21cIjtcbiAgICAgIGNvbnN0IHdhbGxldEluZm8gPSB0aGlzLnZhbGlkYXRlQW5kU2VsZWN0V2FsbGV0KHJlcXVlc3RlZFdhbGxldElkKTtcbiAgICAgIGNvbnN0IGNvbm5lY3RlZEFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuY29ubmVjdFRvV2FsbGV0KHdhbGxldEluZm8pO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmluYWxpemVDb25uZWN0aW9uKGNvbm5lY3RlZEFkZHJlc3NlcywgXCJpbmplY3RlZFwiLCB0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgdm9pZCAwKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNvbm5lY3RcIixcbiAgICAgICAgc291cmNlOiBcIm1hbnVhbC1jb25uZWN0XCJcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlN0YXJ0aW5nIGluamVjdGVkIHByb3ZpZGVyIGRpc2Nvbm5lY3RcIik7XG4gICAgY29uc3Qgd2FsbGV0SW5mbyA9IHRoaXMud2FsbGV0UmVnaXN0cnkuZ2V0QnlJZCh0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgXCJwaGFudG9tXCIpO1xuICAgIGlmICh3YWxsZXRJbmZvPy5wcm92aWRlcnMpIHtcbiAgICAgIGlmICh0aGlzLmFkZHJlc3NUeXBlcy5pbmNsdWRlcyhBZGRyZXNzVHlwZTIuc29sYW5hKSAmJiB3YWxsZXRJbmZvLnByb3ZpZGVycy5zb2xhbmEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB3YWxsZXRJbmZvLnByb3ZpZGVycy5zb2xhbmEuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNvbGFuYSBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRmFpbGVkIHRvIGRpc2Nvbm5lY3QgU29sYW5hXCIsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWRkcmVzc1R5cGVzLmluY2x1ZGVzKEFkZHJlc3NUeXBlMi5ldGhlcmV1bSkgJiYgd2FsbGV0SW5mby5wcm92aWRlcnMuZXRoZXJldW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB3YWxsZXRJbmZvLnByb3ZpZGVycy5ldGhlcmV1bS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXRoZXJldW0gZGlzY29ubmVjdGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkZhaWxlZCB0byBkaXNjb25uZWN0IEV0aGVyZXVtXCIsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YWxsZXRJZCA9IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCB8fCBcInBoYW50b21cIjtcbiAgICBjb25zdCBjbGVhbnVwcyA9IHRoaXMuZXZlbnRMaXN0ZW5lckNsZWFudXBzLmdldCh3YWxsZXRJZCk7XG4gICAgaWYgKGNsZWFudXBzKSB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChjbGVhbnVwKSA9PiBjbGVhbnVwKCkpO1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVyQ2xlYW51cHMuZGVsZXRlKHdhbGxldElkKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVyc1NldHVwLmRlbGV0ZSh3YWxsZXRJZCk7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgdGhpcy5zZXRXYWxsZXRTdGF0ZSh0aGlzLnNlbGVjdGVkV2FsbGV0SWQsIHtcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgYWRkcmVzc2VzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShXQVNfQ09OTkVDVEVEX0tFWSk7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJDbGVhcmVkIHdhcyBjb25uZWN0ZWQgZmxhZyB0byBwcmV2ZW50IGF1dG8tcmVjb25uZWN0XCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRmFpbGVkIHRvIGNsZWFyIHdhcy1jb25uZWN0ZWQgZmxhZ1wiLCB7IGVycm9yIH0pO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIHtcbiAgICAgIHNvdXJjZTogXCJtYW51YWwtZGlzY29ubmVjdFwiXG4gICAgfSk7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkluamVjdGVkIHByb3ZpZGVyIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgYXV0by1jb25uZWN0aW9uIGlmIHVzZXIgd2FzIHByZXZpb3VzbHkgY29ubmVjdGVkXG4gICAqIE9ubHkgcmVjb25uZWN0cyBpZiB0aGUgdXNlciBjb25uZWN0ZWQgYmVmb3JlIGFuZCBkaWRuJ3QgZXhwbGljaXRseSBkaXNjb25uZWN0XG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2V0dGluZyB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGFzeW5jIGF1dG9Db25uZWN0KCkge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkF0dGVtcHRpbmcgYXV0by1jb25uZWN0XCIpO1xuICAgIGxldCBsYXN0V2FsbGV0SWQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB3YXNDb25uZWN0ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShXQVNfQ09OTkVDVEVEX0tFWSk7XG4gICAgICBpZiAod2FzQ29ubmVjdGVkICE9PSBXQVNfQ09OTkVDVEVEX1ZBTFVFKSB7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNraXBwaW5nIGF1dG8tY29ubmVjdDogdXNlciB3YXMgbm90IHByZXZpb3VzbHkgY29ubmVjdGVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0V2FsbGV0SWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShMQVNUX1dBTExFVF9JRF9LRVkpO1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiVXNlciB3YXMgcHJldmlvdXNseSBjb25uZWN0ZWQsIGF0dGVtcHRpbmcgYXV0by1jb25uZWN0XCIsIHtcbiAgICAgICAgbGFzdFdhbGxldElkOiBsYXN0V2FsbGV0SWQgfHwgXCJwaGFudG9tXCJcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy53YXJuKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRmFpbGVkIHRvIGNoZWNrIHdhcy1jb25uZWN0ZWQgZmxhZ1wiLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjb25uZWN0X3N0YXJ0XCIsIHtcbiAgICAgIHNvdXJjZTogXCJhdXRvLWNvbm5lY3RcIixcbiAgICAgIHByb3ZpZGVyVHlwZTogXCJpbmplY3RlZFwiXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdhbGxldElkID0gbGFzdFdhbGxldElkIHx8IFwicGhhbnRvbVwiO1xuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yV2FsbGV0RGlzY292ZXJ5KHdhbGxldElkKTtcbiAgICAgIGNvbnN0IHdhbGxldEluZm8gPSB0aGlzLnZhbGlkYXRlQW5kU2VsZWN0V2FsbGV0KHdhbGxldElkKTtcbiAgICAgIGxldCBjb25uZWN0ZWRBZGRyZXNzZXMgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbm5lY3RlZEFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuY29ubmVjdFRvV2FsbGV0KHdhbGxldEluZm8sIHtcbiAgICAgICAgICBvbmx5SWZUcnVzdGVkOiB0cnVlLFxuICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICBza2lwRXZlbnRMaXN0ZW5lcnM6IHRydWVcbiAgICAgICAgICAvLyBTZXQgdXAgbGlzdGVuZXJzIG9ubHkgaWYgY29ubmVjdGlvbiBzdWNjZWVkc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJBdXRvLWNvbm5lY3QgZmFpbGVkIChleHBlY3RlZCBpZiBub3QgdHJ1c3RlZClcIiwge1xuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uZWN0ZWRBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkF1dG8tY29ubmVjdCBmYWlsZWQ6IG5vIHRydXN0ZWQgY29ubmVjdGlvbnMgYXZhaWxhYmxlXCIpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0X2Vycm9yXCIsIHtcbiAgICAgICAgICBlcnJvcjogXCJObyB0cnVzdGVkIGNvbm5lY3Rpb25zIGF2YWlsYWJsZVwiLFxuICAgICAgICAgIHNvdXJjZTogXCJhdXRvLWNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHdhbGxldEluZm8pO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICB0aGlzLnNldFdhbGxldFN0YXRlKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCwge1xuICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICBhZGRyZXNzZXM6IGNvbm5lY3RlZEFkZHJlc3Nlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1dGhVc2VySWQgPSBhd2FpdCB0aGlzLmdldEF1dGhVc2VySWQoXCJhdXRvLWNvbm5lY3RcIik7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgYWRkcmVzc2VzOiBjb25uZWN0ZWRBZGRyZXNzZXMsXG4gICAgICAgIHNvdXJjZTogXCJhdXRvLWNvbm5lY3RcIixcbiAgICAgICAgYXV0aFVzZXJJZFxuICAgICAgfSk7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiQXV0by1jb25uZWN0IHN1Y2Nlc3NmdWxcIiwge1xuICAgICAgICBhZGRyZXNzQ291bnQ6IGNvbm5lY3RlZEFkZHJlc3Nlcy5sZW5ndGgsXG4gICAgICAgIGFkZHJlc3NlczogY29ubmVjdGVkQWRkcmVzc2VzLm1hcCgoYWRkcikgPT4gKHtcbiAgICAgICAgICB0eXBlOiBhZGRyLmFkZHJlc3NUeXBlLFxuICAgICAgICAgIGFkZHJlc3M6IGFkZHIuYWRkcmVzcy5zdWJzdHJpbmcoMCwgOCkgKyBcIi4uLlwiXG4gICAgICAgIH0pKSxcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgYXV0aFVzZXJJZFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkF1dG8tY29ubmVjdCBmYWlsZWQgd2l0aCBlcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9lcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiQXV0by1jb25uZWN0IGZhaWxlZFwiLFxuICAgICAgICBzb3VyY2U6IFwiYXV0by1jb25uZWN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCkge1xuICAgIGlmICghdGhpcy53YWxsZXRTdGF0ZXMuaGFzKHdhbGxldElkKSkge1xuICAgICAgdGhpcy53YWxsZXRTdGF0ZXMuc2V0KHdhbGxldElkLCB7IGNvbm5lY3RlZDogZmFsc2UsIGFkZHJlc3NlczogW10gfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGxldFN0YXRlcy5nZXQod2FsbGV0SWQpO1xuICB9XG4gIHNldFdhbGxldFN0YXRlKHdhbGxldElkLCBzdGF0ZSkge1xuICAgIHRoaXMud2FsbGV0U3RhdGVzLnNldCh3YWxsZXRJZCwgc3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgd2FsbGV0IHN0YXRlIHdpdGggbmV3IGFkZHJlc3NlcyBmb3IgYSBzcGVjaWZpYyBhZGRyZXNzIHR5cGVcbiAgICogUmVwbGFjZXMgYWxsIGV4aXN0aW5nIGFkZHJlc3NlcyBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBuZXcgYWRkcmVzc2VzXG4gICAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSB3YWxsZXQgSUQgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBuZXdBZGRyZXNzZXMgLSBBcnJheSBvZiBuZXcgYWRkcmVzc2VzIChzdHJpbmdzKSBmb3IgdGhlIGFkZHJlc3MgdHlwZVxuICAgKiBAcGFyYW0gYWRkcmVzc1R5cGUgLSBUaGUgdHlwZSBvZiBhZGRyZXNzZXMgYmVpbmcgdXBkYXRlZFxuICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBhZGRyZXNzZXMgYXJyYXlcbiAgICovXG4gIHVwZGF0ZVdhbGxldEFkZHJlc3Nlcyh3YWxsZXRJZCwgbmV3QWRkcmVzc2VzLCBhZGRyZXNzVHlwZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCk7XG4gICAgY29uc3Qgb3RoZXJBZGRyZXNzZXMgPSBzdGF0ZS5hZGRyZXNzZXMuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmFkZHJlc3NUeXBlICE9PSBhZGRyZXNzVHlwZSk7XG4gICAgY29uc3QgYWRkcmVzc2VzT2ZUeXBlID0gbmV3QWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gKHsgYWRkcmVzc1R5cGUsIGFkZHJlc3MgfSkpO1xuICAgIGNvbnN0IHVwZGF0ZWRBZGRyZXNzZXMgPSBbLi4ub3RoZXJBZGRyZXNzZXMsIC4uLmFkZHJlc3Nlc09mVHlwZV07XG4gICAgdGhpcy5zZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCwge1xuICAgICAgY29ubmVjdGVkOiB1cGRhdGVkQWRkcmVzc2VzLmxlbmd0aCA+IDAsXG4gICAgICBhZGRyZXNzZXM6IHVwZGF0ZWRBZGRyZXNzZXNcbiAgICB9KTtcbiAgICByZXR1cm4gdXBkYXRlZEFkZHJlc3NlcztcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGNvbnN0cnVjdCBhY2NvdW50IGNoYW5nZSBzb3VyY2Ugc3RyaW5nXG4gICAqL1xuICBnZXRBY2NvdW50Q2hhbmdlU291cmNlKHNvdXJjZSkge1xuICAgIHJldHVybiBgJHtzb3VyY2V9LWFjY291bnQtY2hhbmdlYDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgaGFuZGxlciBmb3IgU29sYW5hIGNvbm5lY3QgZXZlbnRzXG4gICAqL1xuICBjcmVhdGVTb2xhbmFDb25uZWN0SGFuZGxlcih3YWxsZXRJZCwgc291cmNlKSB7XG4gICAgcmV0dXJuIGFzeW5jIChwdWJsaWNLZXkpID0+IHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNvbGFuYSBjb25uZWN0IGV2ZW50IHJlY2VpdmVkXCIsIHsgcHVibGljS2V5LCB3YWxsZXRJZCB9KTtcbiAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IHRoaXMudXBkYXRlV2FsbGV0QWRkcmVzc2VzKHdhbGxldElkLCBbcHVibGljS2V5XSwgQWRkcmVzc1R5cGUyLnNvbGFuYSk7XG4gICAgICBjb25zdCBhdXRoVXNlcklkID0gYXdhaXQgdGhpcy5nZXRBdXRoVXNlcklkKFwiU29sYW5hIGNvbm5lY3QgZXZlbnRcIik7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgYWRkcmVzc2VzOiBuZXdBZGRyZXNzZXMsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgYXV0aFVzZXJJZFxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgaGFuZGxlciBmb3IgU29sYW5hIGRpc2Nvbm5lY3QgZXZlbnRzXG4gICAqL1xuICBjcmVhdGVTb2xhbmFEaXNjb25uZWN0SGFuZGxlcih3YWxsZXRJZCwgc291cmNlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNvbGFuYSBkaXNjb25uZWN0IGV2ZW50IHJlY2VpdmVkXCIsIHsgd2FsbGV0SWQgfSk7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0V2FsbGV0U3RhdGUod2FsbGV0SWQpO1xuICAgICAgY29uc3QgZmlsdGVyZWRBZGRyZXNzZXMgPSBzdGF0ZS5hZGRyZXNzZXMuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmFkZHJlc3NUeXBlICE9PSBBZGRyZXNzVHlwZTIuc29sYW5hKTtcbiAgICAgIHRoaXMuc2V0V2FsbGV0U3RhdGUod2FsbGV0SWQsIHtcbiAgICAgICAgY29ubmVjdGVkOiBmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPiAwLFxuICAgICAgICBhZGRyZXNzZXM6IGZpbHRlcmVkQWRkcmVzc2VzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwge1xuICAgICAgICBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGhhbmRsZXIgZm9yIFNvbGFuYSBhY2NvdW50IGNoYW5nZSBldmVudHNcbiAgICogQ2FuIHJlY2VpdmUgc3RyaW5nIHwgbnVsbCBwZXIgV2FsbGV0IFN0YW5kYXJkXG4gICAqL1xuICBjcmVhdGVTb2xhbmFBY2NvdW50Q2hhbmdlSGFuZGxlcih3YWxsZXRJZCwgc291cmNlKSB7XG4gICAgcmV0dXJuIGFzeW5jIChwdWJsaWNLZXkpID0+IHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIlNvbGFuYSBhY2NvdW50IGNoYW5nZWQgZXZlbnQgcmVjZWl2ZWRcIiwgeyBwdWJsaWNLZXksIHdhbGxldElkIH0pO1xuICAgICAgaWYgKHB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzZXMgPSB0aGlzLnVwZGF0ZVdhbGxldEFkZHJlc3Nlcyh3YWxsZXRJZCwgW3B1YmxpY0tleV0sIEFkZHJlc3NUeXBlMi5zb2xhbmEpO1xuICAgICAgICBjb25zdCBhdXRoVXNlcklkID0gYXdhaXQgdGhpcy5nZXRBdXRoVXNlcklkKFwiU29sYW5hIGFjY291bnQgY2hhbmdlZCBldmVudFwiKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7XG4gICAgICAgICAgYWRkcmVzc2VzOiBuZXdBZGRyZXNzZXMsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmdldEFjY291bnRDaGFuZ2VTb3VyY2Uoc291cmNlKSxcbiAgICAgICAgICBhdXRoVXNlcklkXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFdhbGxldFN0YXRlKHdhbGxldElkKTtcbiAgICAgICAgY29uc3Qgb3RoZXJBZGRyZXNzZXMgPSBzdGF0ZS5hZGRyZXNzZXMuZmlsdGVyKChhZGRyKSA9PiBhZGRyLmFkZHJlc3NUeXBlICE9PSBBZGRyZXNzVHlwZTIuc29sYW5hKTtcbiAgICAgICAgdGhpcy5zZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCwge1xuICAgICAgICAgIGNvbm5lY3RlZDogb3RoZXJBZGRyZXNzZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICBhZGRyZXNzZXM6IG90aGVyQWRkcmVzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0QWNjb3VudENoYW5nZVNvdXJjZShzb3VyY2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGhhbmRsZXIgZm9yIEV0aGVyZXVtIGNvbm5lY3QgZXZlbnRzXG4gICAqIEVJUC0xMTkzIGNvbm5lY3QgZXZlbnQgcmVjZWl2ZXMgeyBjaGFpbklkOiBzdHJpbmcgfSwgYnV0IHdlIG5lZWQgdG8gZ2V0IGFjY291bnRzIHNlcGFyYXRlbHlcbiAgICovXG4gIGNyZWF0ZUV0aGVyZXVtQ29ubmVjdEhhbmRsZXIod2FsbGV0SWQsIHNvdXJjZSkge1xuICAgIHJldHVybiBhc3luYyAoY29ubmVjdEluZm8pID0+IHtcbiAgICAgIGxldCBhY2NvdW50cyA9IFtdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29ubmVjdEluZm8pKSB7XG4gICAgICAgIGFjY291bnRzID0gY29ubmVjdEluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdhbGxldEluZm8gPSB0aGlzLndhbGxldFJlZ2lzdHJ5LmdldEJ5SWQod2FsbGV0SWQpO1xuICAgICAgICAgIGlmICh3YWxsZXRJbmZvPy5wcm92aWRlcnM/LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICBhY2NvdW50cyA9IGF3YWl0IHdhbGxldEluZm8ucHJvdmlkZXJzLmV0aGVyZXVtLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGRlYnVnLndhcm4oRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJGYWlsZWQgdG8gZ2V0IGFjY291bnRzIG9uIGNvbm5lY3RcIiwgeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXRoZXJldW0gY29ubmVjdCBldmVudCByZWNlaXZlZFwiLCB7IGFjY291bnRzLCB3YWxsZXRJZCB9KTtcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IHRoaXMudXBkYXRlV2FsbGV0QWRkcmVzc2VzKHdhbGxldElkLCBhY2NvdW50cywgQWRkcmVzc1R5cGUyLmV0aGVyZXVtKTtcbiAgICAgICAgY29uc3QgYXV0aFVzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0QXV0aFVzZXJJZChcIkV0aGVyZXVtIGNvbm5lY3QgZXZlbnRcIik7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICAgIGFkZHJlc3NlczogbmV3QWRkcmVzc2VzLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBhdXRoVXNlcklkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGhhbmRsZXIgZm9yIEV0aGVyZXVtIGRpc2Nvbm5lY3QgZXZlbnRzXG4gICAqL1xuICBjcmVhdGVFdGhlcmV1bURpc2Nvbm5lY3RIYW5kbGVyKHdhbGxldElkLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXRoZXJldW0gZGlzY29ubmVjdCBldmVudCByZWNlaXZlZFwiLCB7IHdhbGxldElkIH0pO1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFdhbGxldFN0YXRlKHdhbGxldElkKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkQWRkcmVzc2VzID0gc3RhdGUuYWRkcmVzc2VzLmZpbHRlcigoYWRkcikgPT4gYWRkci5hZGRyZXNzVHlwZSAhPT0gQWRkcmVzc1R5cGUyLmV0aGVyZXVtKTtcbiAgICAgIHRoaXMuc2V0V2FsbGV0U3RhdGUod2FsbGV0SWQsIHtcbiAgICAgICAgY29ubmVjdGVkOiBmaWx0ZXJlZEFkZHJlc3Nlcy5sZW5ndGggPiAwLFxuICAgICAgICBhZGRyZXNzZXM6IGZpbHRlcmVkQWRkcmVzc2VzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIiwge1xuICAgICAgICBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGhhbmRsZXIgZm9yIEV0aGVyZXVtIGFjY291bnQgY2hhbmdlIGV2ZW50c1xuICAgKi9cbiAgY3JlYXRlRXRoZXJldW1BY2NvdW50Q2hhbmdlSGFuZGxlcih3YWxsZXRJZCwgc291cmNlKSB7XG4gICAgcmV0dXJuIGFzeW5jIChhY2NvdW50cykgPT4ge1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXRoZXJldW0gYWNjb3VudHMgY2hhbmdlZCBldmVudCByZWNlaXZlZFwiLCB7IGFjY291bnRzLCB3YWxsZXRJZCB9KTtcbiAgICAgIGlmIChhY2NvdW50cyAmJiBhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IHRoaXMudXBkYXRlV2FsbGV0QWRkcmVzc2VzKHdhbGxldElkLCBhY2NvdW50cywgQWRkcmVzc1R5cGUyLmV0aGVyZXVtKTtcbiAgICAgICAgY29uc3QgYXV0aFVzZXJJZCA9IGF3YWl0IHRoaXMuZ2V0QXV0aFVzZXJJZChcIkV0aGVyZXVtIGFjY291bnRzIGNoYW5nZWQgZXZlbnRcIik7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICAgIGFkZHJlc3NlczogbmV3QWRkcmVzc2VzLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXRBY2NvdW50Q2hhbmdlU291cmNlKHNvdXJjZSksXG4gICAgICAgICAgYXV0aFVzZXJJZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCk7XG4gICAgICAgIGNvbnN0IG90aGVyQWRkcmVzc2VzID0gc3RhdGUuYWRkcmVzc2VzLmZpbHRlcigoYWRkcikgPT4gYWRkci5hZGRyZXNzVHlwZSAhPT0gQWRkcmVzc1R5cGUyLmV0aGVyZXVtKTtcbiAgICAgICAgdGhpcy5zZXRXYWxsZXRTdGF0ZSh3YWxsZXRJZCwge1xuICAgICAgICAgIGNvbm5lY3RlZDogb3RoZXJBZGRyZXNzZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICBhZGRyZXNzZXM6IG90aGVyQWRkcmVzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0QWNjb3VudENoYW5nZVNvdXJjZShzb3VyY2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0QWRkcmVzc2VzKCkge1xuICAgIGNvbnN0IHdhbGxldElkID0gdGhpcy5zZWxlY3RlZFdhbGxldElkIHx8IFwicGhhbnRvbVwiO1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldFN0YXRlKHdhbGxldElkKS5hZGRyZXNzZXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBlbmFibGVkIGFkZHJlc3MgdHlwZXMgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGVkIHdhbGxldFxuICAgKiAtIEZvciBQaGFudG9tOiByZXR1cm5zIGNvbmZpZy5hZGRyZXNzVHlwZXNcbiAgICogLSBGb3IgZXh0ZXJuYWwgd2FsbGV0czogcmV0dXJucyB0aGUgd2FsbGV0J3MgYWRkcmVzc1R5cGVzIGZyb20gcmVnaXN0cnlcbiAgICovXG4gIGdldEVuYWJsZWRBZGRyZXNzVHlwZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgdGhpcy5zZWxlY3RlZFdhbGxldElkID09PSBcInBoYW50b21cIikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc1R5cGVzO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgaWYgKHdhbGxldEluZm8pIHtcbiAgICAgIHJldHVybiB3YWxsZXRJbmZvLmFkZHJlc3NUeXBlcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc1R5cGVzO1xuICB9XG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIGNvbnN0IHdhbGxldElkID0gdGhpcy5zZWxlY3RlZFdhbGxldElkIHx8IFwicGhhbnRvbVwiO1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldFN0YXRlKHdhbGxldElkKS5jb25uZWN0ZWQ7XG4gIH1cbiAgLy8gQXV0b0NvbmZpcm0gbWV0aG9kcyAtIG9ubHkgYXZhaWxhYmxlIGZvciBQaGFudG9tIHdhbGxldFxuICBhc3luYyBlbmFibGVBdXRvQ29uZmlybShwYXJhbXMpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCB8fCBcInBoYW50b21cIik7XG4gICAgaWYgKCFpc1BoYW50b21XYWxsZXQod2FsbGV0SW5mbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dG8tY29uZmlybSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgUGhhbnRvbSB3YWxsZXRcIik7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkVuYWJsaW5nIGF1dG9Db25maXJtXCIsIHsgcGFyYW1zIH0pO1xuICAgIHJldHVybiBhd2FpdCB3YWxsZXRJbmZvLnBoYW50b21JbnN0YW5jZS5hdXRvQ29uZmlybS5hdXRvQ29uZmlybUVuYWJsZShwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRpc2FibGVBdXRvQ29uZmlybSgpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCB8fCBcInBoYW50b21cIik7XG4gICAgaWYgKCFpc1BoYW50b21XYWxsZXQod2FsbGV0SW5mbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dG8tY29uZmlybSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgUGhhbnRvbSB3YWxsZXRcIik7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkRpc2FibGluZyBhdXRvQ29uZmlybVwiKTtcbiAgICBhd2FpdCB3YWxsZXRJbmZvLnBoYW50b21JbnN0YW5jZS5hdXRvQ29uZmlybS5hdXRvQ29uZmlybURpc2FibGUoKTtcbiAgfVxuICBhc3luYyBnZXRBdXRvQ29uZmlybVN0YXR1cygpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHRoaXMuc2VsZWN0ZWRXYWxsZXRJZCB8fCBcInBoYW50b21cIik7XG4gICAgaWYgKCFpc1BoYW50b21XYWxsZXQod2FsbGV0SW5mbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dG8tY29uZmlybSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgUGhhbnRvbSB3YWxsZXRcIik7XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkdldHRpbmcgYXV0b0NvbmZpcm0gc3RhdHVzXCIpO1xuICAgIHJldHVybiBhd2FpdCB3YWxsZXRJbmZvLnBoYW50b21JbnN0YW5jZS5hdXRvQ29uZmlybS5hdXRvQ29uZmlybVN0YXR1cygpO1xuICB9XG4gIGFzeW5jIGdldFN1cHBvcnRlZEF1dG9Db25maXJtQ2hhaW5zKCkge1xuICAgIGNvbnN0IHdhbGxldEluZm8gPSB0aGlzLndhbGxldFJlZ2lzdHJ5LmdldEJ5SWQodGhpcy5zZWxlY3RlZFdhbGxldElkIHx8IFwicGhhbnRvbVwiKTtcbiAgICBpZiAoIWlzUGhhbnRvbVdhbGxldCh3YWxsZXRJbmZvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0by1jb25maXJtIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBQaGFudG9tIHdhbGxldFwiKTtcbiAgICB9XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiR2V0dGluZyBzdXBwb3J0ZWQgYXV0b0NvbmZpcm0gY2hhaW5zXCIpO1xuICAgIHJldHVybiBhd2FpdCB3YWxsZXRJbmZvLnBoYW50b21JbnN0YW5jZS5hdXRvQ29uZmlybS5hdXRvQ29uZmlybVN1cHBvcnRlZENoYWlucygpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGdldCBhdXRoVXNlcklkIGZyb20gd2luZG93LnBoYW50b20uYXBwLmdldFVzZXIoKVxuICAgKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgb3IgZmFpbHMsIG9yIGlmIHdhbGxldCBpcyBub3QgUGhhbnRvbVxuICAgKi9cbiAgYXN5bmMgZ2V0QXV0aFVzZXJJZChjb250ZXh0KSB7XG4gICAgY29uc3Qgd2FsbGV0SW5mbyA9IHRoaXMud2FsbGV0UmVnaXN0cnkuZ2V0QnlJZCh0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgXCJwaGFudG9tXCIpO1xuICAgIGlmICghaXNQaGFudG9tV2FsbGV0KHdhbGxldEluZm8pKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5waGFudG9tPy5hcHA/LmdldFVzZXIpIHtcbiAgICAgICAgY29uc3QgdXNlckluZm8gPSBhd2FpdCB3aW5kb3cucGhhbnRvbS5hcHAuZ2V0VXNlcigpO1xuICAgICAgICBjb25zdCBhdXRoVXNlcklkID0gdXNlckluZm8/LmF1dGhVc2VySWQ7XG4gICAgICAgIGlmIChhdXRoVXNlcklkKSB7XG4gICAgICAgICAgZGVidWcubG9nKFxuICAgICAgICAgICAgRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUixcbiAgICAgICAgICAgIGBSZXRyaWV2ZWQgYXV0aFVzZXJJZCBmcm9tIHdpbmRvdy5waGFudG9tLmFwcC5nZXRVc2VyKCkgZHVyaW5nICR7Y29udGV4dH1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhdXRoVXNlcklkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aFVzZXJJZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcubG9nKFxuICAgICAgICBEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLFxuICAgICAgICBgRmFpbGVkIHRvIGdldCB1c2VyIGluZm8gZHVyaW5nICR7Y29udGV4dH0gKG1ldGhvZCBtYXkgbm90IGJlIHN1cHBvcnRlZClgLFxuICAgICAgICB7IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLy8gRXZlbnQgbWFuYWdlbWVudCBtZXRob2RzIC0gaW1wbGVtZW50aW5nIHVuaWZpZWQgZXZlbnQgaW50ZXJmYWNlXG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LklOSkVDVEVEX1BST1ZJREVSLCBcIkFkZGluZyBldmVudCBsaXN0ZW5lclwiLCB7IGV2ZW50IH0pO1xuICAgIGlmICghdGhpcy5ldmVudHNJbml0aWFsaXplZCkge1xuICAgICAgY29uc3Qgd2FsbGV0SWQgPSB0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgXCJwaGFudG9tXCI7XG4gICAgICBjb25zdCB3YWxsZXRJbmZvID0gdGhpcy53YWxsZXRSZWdpc3RyeS5nZXRCeUlkKHdhbGxldElkKTtcbiAgICAgIGlmICh3YWxsZXRJbmZvKSB7XG4gICAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyh3YWxsZXRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQpPy5hZGQoY2FsbGJhY2spO1xuICB9XG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJSZW1vdmluZyBldmVudCBsaXN0ZW5lclwiLCB7IGV2ZW50IH0pO1xuICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KT8uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk/LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRW1pdHRpbmcgZXZlbnRcIiwge1xuICAgICAgZXZlbnQsXG4gICAgICBsaXN0ZW5lckNvdW50OiB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk/LnNpemUgfHwgMCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiRXZlbnQgY2FsbGJhY2sgZXJyb3JcIiwgeyBldmVudCwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IHVwIFNvbGFuYSBldmVudCBsaXN0ZW5lcnMgZm9yIGFueSBwcm92aWRlciAoUGhhbnRvbSBvciBleHRlcm5hbClcbiAgICovXG4gIHNldHVwU29sYW5hRXZlbnRMaXN0ZW5lcnMocHJvdmlkZXIsIHdhbGxldElkLCBzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyLm9uICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm47XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuSU5KRUNURURfUFJPVklERVIsIFwiU2V0dGluZyB1cCBTb2xhbmEgZXZlbnQgbGlzdGVuZXJzXCIsIHsgd2FsbGV0SWQsIHNvdXJjZSB9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGNvbm5lY3Q6IHRoaXMuY3JlYXRlU29sYW5hQ29ubmVjdEhhbmRsZXIod2FsbGV0SWQsIHNvdXJjZSksXG4gICAgICBkaXNjb25uZWN0OiB0aGlzLmNyZWF0ZVNvbGFuYURpc2Nvbm5lY3RIYW5kbGVyKHdhbGxldElkLCBzb3VyY2UpLFxuICAgICAgYWNjb3VudENoYW5nZWQ6IHRoaXMuY3JlYXRlU29sYW5hQWNjb3VudENoYW5nZUhhbmRsZXIod2FsbGV0SWQsIHNvdXJjZSlcbiAgICB9O1xuICAgIHByb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCBoYW5kbGVycy5jb25uZWN0KTtcbiAgICBwcm92aWRlci5vbihcImRpc2Nvbm5lY3RcIiwgaGFuZGxlcnMuZGlzY29ubmVjdCk7XG4gICAgcHJvdmlkZXIub24oXCJhY2NvdW50Q2hhbmdlZFwiLCBoYW5kbGVycy5hY2NvdW50Q2hhbmdlZCk7XG4gICAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyLm9mZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGVhbnVwcy5wdXNoKFxuICAgICAgICAoKSA9PiBwcm92aWRlci5vZmYoXCJjb25uZWN0XCIsIGhhbmRsZXJzLmNvbm5lY3QpLFxuICAgICAgICAoKSA9PiBwcm92aWRlci5vZmYoXCJkaXNjb25uZWN0XCIsIGhhbmRsZXJzLmRpc2Nvbm5lY3QpLFxuICAgICAgICAoKSA9PiBwcm92aWRlci5vZmYoXCJhY2NvdW50Q2hhbmdlZFwiLCBoYW5kbGVycy5hY2NvdW50Q2hhbmdlZClcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2xlYW51cHMgPSB0aGlzLmV2ZW50TGlzdGVuZXJDbGVhbnVwcy5nZXQod2FsbGV0SWQpIHx8IFtdO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lckNsZWFudXBzLnNldCh3YWxsZXRJZCwgWy4uLmV4aXN0aW5nQ2xlYW51cHMsIC4uLmNsZWFudXBzXSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB1cCBFdGhlcmV1bSBldmVudCBsaXN0ZW5lcnMgZm9yIGFueSBwcm92aWRlciAoUGhhbnRvbSBvciBleHRlcm5hbClcbiAgICovXG4gIHNldHVwRXRoZXJldW1FdmVudExpc3RlbmVycyhwcm92aWRlciwgd2FsbGV0SWQsIHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2YgcHJvdmlkZXIub24gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybjtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJTZXR0aW5nIHVwIEV0aGVyZXVtIGV2ZW50IGxpc3RlbmVyc1wiLCB7IHdhbGxldElkLCBzb3VyY2UgfSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBjb25uZWN0OiB0aGlzLmNyZWF0ZUV0aGVyZXVtQ29ubmVjdEhhbmRsZXIod2FsbGV0SWQsIHNvdXJjZSksXG4gICAgICBkaXNjb25uZWN0OiB0aGlzLmNyZWF0ZUV0aGVyZXVtRGlzY29ubmVjdEhhbmRsZXIod2FsbGV0SWQsIHNvdXJjZSksXG4gICAgICBhY2NvdW50c0NoYW5nZWQ6IHRoaXMuY3JlYXRlRXRoZXJldW1BY2NvdW50Q2hhbmdlSGFuZGxlcih3YWxsZXRJZCwgc291cmNlKVxuICAgIH07XG4gICAgcHJvdmlkZXIub24oXCJjb25uZWN0XCIsIGhhbmRsZXJzLmNvbm5lY3QpO1xuICAgIHByb3ZpZGVyLm9uKFwiZGlzY29ubmVjdFwiLCBoYW5kbGVycy5kaXNjb25uZWN0KTtcbiAgICBwcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCBoYW5kbGVycy5hY2NvdW50c0NoYW5nZWQpO1xuICAgIGNvbnN0IGNsZWFudXBzID0gW107XG4gICAgaWYgKHR5cGVvZiBwcm92aWRlci5vZmYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xlYW51cHMucHVzaChcbiAgICAgICAgKCkgPT4gcHJvdmlkZXIub2ZmKFwiY29ubmVjdFwiLCBoYW5kbGVycy5jb25uZWN0KSxcbiAgICAgICAgKCkgPT4gcHJvdmlkZXIub2ZmKFwiZGlzY29ubmVjdFwiLCBoYW5kbGVycy5kaXNjb25uZWN0KSxcbiAgICAgICAgKCkgPT4gcHJvdmlkZXIub2ZmKFwiYWNjb3VudHNDaGFuZ2VkXCIsIGhhbmRsZXJzLmFjY291bnRzQ2hhbmdlZClcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2xlYW51cHMgPSB0aGlzLmV2ZW50TGlzdGVuZXJDbGVhbnVwcy5nZXQod2FsbGV0SWQpIHx8IFtdO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lckNsZWFudXBzLnNldCh3YWxsZXRJZCwgWy4uLmV4aXN0aW5nQ2xlYW51cHMsIC4uLmNsZWFudXBzXSk7XG4gIH1cbiAgLyoqXG4gICAqIFVuaWZpZWQgZXZlbnQgbGlzdGVuZXIgc2V0dXAgZm9yIGFsbCB3YWxsZXQgdHlwZXMgKFBoYW50b20gYW5kIGV4dGVybmFsKVxuICAgKi9cbiAgc2V0dXBFdmVudExpc3RlbmVycyh3YWxsZXRJbmZvKSB7XG4gICAgY29uc3Qgd2FsbGV0SWQgPSB0aGlzLnNlbGVjdGVkV2FsbGV0SWQgfHwgXCJwaGFudG9tXCI7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnNTZXR1cC5oYXMod2FsbGV0SWQpKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJFdmVudCBsaXN0ZW5lcnMgYWxyZWFkeSBzZXQgdXAgZm9yIHdhbGxldFwiLCB7IHdhbGxldElkIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5JTkpFQ1RFRF9QUk9WSURFUiwgXCJTZXR0aW5nIHVwIGV2ZW50IGxpc3RlbmVyc1wiLCB7IHdhbGxldElkIH0pO1xuICAgIGlmICh0aGlzLmFkZHJlc3NUeXBlcy5pbmNsdWRlcyhBZGRyZXNzVHlwZTIuc29sYW5hKSAmJiB3YWxsZXRJbmZvLnByb3ZpZGVycz8uc29sYW5hKSB7XG4gICAgICB0aGlzLnNldHVwU29sYW5hRXZlbnRMaXN0ZW5lcnMod2FsbGV0SW5mby5wcm92aWRlcnMuc29sYW5hLCB3YWxsZXRJZCwgXCJ3YWxsZXRcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmFkZHJlc3NUeXBlcy5pbmNsdWRlcyhBZGRyZXNzVHlwZTIuZXRoZXJldW0pICYmIHdhbGxldEluZm8ucHJvdmlkZXJzPy5ldGhlcmV1bSkge1xuICAgICAgdGhpcy5zZXR1cEV0aGVyZXVtRXZlbnRMaXN0ZW5lcnMod2FsbGV0SW5mby5wcm92aWRlcnMuZXRoZXJldW0sIHdhbGxldElkLCBcIndhbGxldFwiKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVyc1NldHVwLmFkZCh3YWxsZXRJZCk7XG4gICAgdGhpcy5ldmVudHNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlcnMvZW1iZWRkZWQvaW5kZXgudHNcbmltcG9ydCB7IEVtYmVkZGVkUHJvdmlkZXIgYXMgQ29yZUVtYmVkZGVkUHJvdmlkZXIgfSBmcm9tIFwiQHBoYW50b20vZW1iZWRkZWQtcHJvdmlkZXItY29yZVwiO1xuaW1wb3J0IHsgSW5kZXhlZERiU3RhbXBlciB9IGZyb20gXCJAcGhhbnRvbS9pbmRleGVkLWRiLXN0YW1wZXJcIjtcblxuLy8gc3JjL3Byb3ZpZGVycy9lbWJlZGRlZC9hZGFwdGVycy9zdG9yYWdlLnRzXG52YXIgQnJvd3NlclN0b3JhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGJOYW1lID0gXCJwaGFudG9tLWJyb3dzZXItc2RrXCI7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBcInNlc3Npb25zXCI7XG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgfVxuICBhc3luYyBnZXREQigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLnZlcnNpb24pO1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRoaXMuc3RvcmVOYW1lKSkge1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiR2V0dGluZyBzZXNzaW9uIGZyb20gSW5kZXhlZERCXCIpO1xuICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREQigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sIFwicmVhZG9ubHlcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoXCJjdXJyZW50U2Vzc2lvblwiKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gcmVxdWVzdC5yZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuU1RPUkFHRSwgXCJSZXRyaWV2ZWQgc2Vzc2lvbiBmcm9tIEluZGV4ZWREQlwiLCB7XG4gICAgICAgICAgaGFzU2Vzc2lvbjogISFzZXNzaW9uLFxuICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbj8uc2Vzc2lvbklkXG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKHNlc3Npb24pO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5TVE9SQUdFLCBcIkZhaWxlZCB0byBnZXQgc2Vzc2lvbiBmcm9tIEluZGV4ZWREQlwiLCB7IGVycm9yOiByZXF1ZXN0LmVycm9yIH0pO1xuICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNhdmVTZXNzaW9uKHNlc3Npb24pIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5TVE9SQUdFLCBcIlNhdmluZyBzZXNzaW9uIHRvIEluZGV4ZWREQlwiLCB7XG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb24uc2Vzc2lvbklkLFxuICAgICAgd2FsbGV0SWQ6IHNlc3Npb24ud2FsbGV0SWQsXG4gICAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzXG4gICAgfSk7XG4gICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoc2Vzc2lvbiwgXCJjdXJyZW50U2Vzc2lvblwiKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5TVE9SQUdFLCBcIlN1Y2Nlc3NmdWxseSBzYXZlZCBzZXNzaW9uIHRvIEluZGV4ZWREQlwiKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5TVE9SQUdFLCBcIkZhaWxlZCB0byBzYXZlIHNlc3Npb24gdG8gSW5kZXhlZERCXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2xlYXJTZXNzaW9uKCkge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiQ2xlYXJpbmcgc2Vzc2lvbiBmcm9tIEluZGV4ZWREQlwiKTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShcImN1cnJlbnRTZXNzaW9uXCIpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiU3VjY2Vzc2Z1bGx5IGNsZWFyZWQgc2Vzc2lvbiBmcm9tIEluZGV4ZWREQlwiKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5TVE9SQUdFLCBcIkZhaWxlZCB0byBjbGVhciBzZXNzaW9uIGZyb20gSW5kZXhlZERCXCIsIHsgZXJyb3I6IHJlcXVlc3QuZXJyb3IgfSk7XG4gICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0U2hvdWxkQ2xlYXJQcmV2aW91c1Nlc3Npb24oKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuU1RPUkFHRSwgXCJHZXR0aW5nIHNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uIGZsYWcgZnJvbSBJbmRleGVkREJcIik7XG4gICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERCKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChcInNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uXCIpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNob3VsZENsZWFyID0gcmVxdWVzdC5yZXN1bHQgPz8gZmFsc2U7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiUmV0cmlldmVkIHNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uIGZsYWcgZnJvbSBJbmRleGVkREJcIiwge1xuICAgICAgICAgIHNob3VsZENsZWFyXG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKHNob3VsZENsZWFyKTtcbiAgICAgIH07XG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuU1RPUkFHRSwgXCJGYWlsZWQgdG8gZ2V0IHNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uIGZsYWcgZnJvbSBJbmRleGVkREJcIiwge1xuICAgICAgICAgIGVycm9yOiByZXF1ZXN0LmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNldFNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uKHNob3VsZCkge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiU2V0dGluZyBzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbiBmbGFnIGluIEluZGV4ZWREQlwiLCB7IHNob3VsZCB9KTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0REIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChzaG91bGQsIFwic2hvdWxkQ2xlYXJQcmV2aW91c1Nlc3Npb25cIik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuU1RPUkFHRSwgXCJTdWNjZXNzZnVsbHkgc2V0IHNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uIGZsYWcgaW4gSW5kZXhlZERCXCIpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LlNUT1JBR0UsIFwiRmFpbGVkIHRvIHNldCBzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbiBmbGFnIGluIEluZGV4ZWREQlwiLCB7XG4gICAgICAgICAgZXJyb3I6IHJlcXVlc3QuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlcnMvZW1iZWRkZWQvYWRhcHRlcnMvdXJsLXBhcmFtcy50c1xudmFyIEJyb3dzZXJVUkxQYXJhbXNBY2Nlc3NvciA9IGNsYXNzIHtcbiAgZ2V0UGFyYW0oa2V5KSB7XG4gICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICByZXR1cm4gdXJsUGFyYW1zLmdldChrZXkpO1xuICB9XG59O1xudmFyIGJyb3dzZXJVcmxQYXJhbXNBY2Nlc3NvciA9IG5ldyBCcm93c2VyVVJMUGFyYW1zQWNjZXNzb3IoKTtcblxuLy8gc3JjL3Byb3ZpZGVycy9lbWJlZGRlZC9hZGFwdGVycy9hdXRoLnRzXG5pbXBvcnQgeyBERUZBVUxUX0FVVEhfVVJMIH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xuXG4vLyBzcmMvdXRpbHMvYnJvd3Nlci1kZXRlY3Rpb24udHNcbmZ1bmN0aW9uIHBhcnNlQnJvd3NlckZyb21Vc2VyQWdlbnQodXNlckFnZW50LCBoYXNCcmF2ZUFQSSkge1xuICBsZXQgbmFtZSA9IFwidW5rbm93blwiO1xuICBsZXQgdmVyc2lvbiA9IFwidW5rbm93blwiO1xuICBpZiAoIXVzZXJBZ2VudCB8fCB0eXBlb2YgdXNlckFnZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHsgbmFtZSwgdmVyc2lvbiwgdXNlckFnZW50OiBcInVua25vd25cIiB9O1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIkVkZy9cIikpIHtcbiAgICAgIG5hbWUgPSBcImVkZ2VcIjtcbiAgICAgIGNvbnN0IG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdcXC8oWzAtOV0rKD86XFwuWzAtOV0rKSopLyk7XG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHZlcnNpb24gPSBtYXRjaFsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5jbHVkZXMoXCJPUFIvXCIpIHx8IHVzZXJBZ2VudC5pbmNsdWRlcyhcIk9wZXJhL1wiKSkge1xuICAgICAgbmFtZSA9IFwib3BlcmFcIjtcbiAgICAgIGNvbnN0IG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC8oPzpPUFJ8T3BlcmEpXFwvKFswLTldKyg/OlxcLlswLTldKykqKS8pO1xuICAgICAgaWYgKG1hdGNoKVxuICAgICAgICB2ZXJzaW9uID0gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpWzBdO1xuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluY2x1ZGVzKFwiU2Ftc3VuZ0Jyb3dzZXIvXCIpKSB7XG4gICAgICBuYW1lID0gXCJzYW1zdW5nXCI7XG4gICAgICBjb25zdCBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOV0rKD86XFwuWzAtOV0rKSopLyk7XG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHZlcnNpb24gPSBtYXRjaFsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5jbHVkZXMoXCJEdWNrRHVja0dvL1wiKSkge1xuICAgICAgbmFtZSA9IFwiZHVja2R1Y2tnb1wiO1xuICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0R1Y2tEdWNrR29cXC8oWzAtOV0rKD86XFwuWzAtOV0rKSopLyk7XG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHZlcnNpb24gPSBtYXRjaFsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5jbHVkZXMoXCJDaHJvbWUvXCIpICYmIGhhc0JyYXZlQVBJKSB7XG4gICAgICBuYW1lID0gXCJicmF2ZVwiO1xuICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhbMC05XSsoPzpcXC5bMC05XSspKikvKTtcbiAgICAgIGlmIChtYXRjaClcbiAgICAgICAgdmVyc2lvbiA9IG1hdGNoWzFdLnNwbGl0KFwiLlwiKVswXTtcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIk1vYmlsZS9cIikgfHwgdXNlckFnZW50LmluY2x1ZGVzKFwiQW5kcm9pZFwiKSkge1xuICAgICAgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIkNocm9tZS9cIikpIHtcbiAgICAgICAgbmFtZSA9IFwiY2hyb21lLW1vYmlsZVwiO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFswLTldKyg/OlxcLlswLTldKykqKS8pO1xuICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgdmVyc2lvbiA9IG1hdGNoWzFdLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgbmFtZSA9IFwiZmlyZWZveC1tb2JpbGVcIjtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKD86XFwuWzAtOV0rKSopLyk7XG4gICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICB2ZXJzaW9uID0gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5jbHVkZXMoXCJTYWZhcmkvXCIpICYmIHVzZXJBZ2VudC5pbmNsdWRlcyhcIk1vYmlsZS9cIikpIHtcbiAgICAgICAgbmFtZSA9IFwic2FmYXJpLW1vYmlsZVwiO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSsoPzpcXC5bMC05XSspKikvKTtcbiAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgIHZlcnNpb24gPSBtYXRjaFsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gXCJtb2JpbGVcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIkNocm9tZS9cIikpIHtcbiAgICAgIG5hbWUgPSBcImNocm9tZVwiO1xuICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhbMC05XSsoPzpcXC5bMC05XSspKikvKTtcbiAgICAgIGlmIChtYXRjaClcbiAgICAgICAgdmVyc2lvbiA9IG1hdGNoWzFdLnNwbGl0KFwiLlwiKVswXTtcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKSB7XG4gICAgICBuYW1lID0gXCJmaXJlZm94XCI7XG4gICAgICBjb25zdCBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSsoPzpcXC5bMC05XSspKikvKTtcbiAgICAgIGlmIChtYXRjaClcbiAgICAgICAgdmVyc2lvbiA9IG1hdGNoWzFdLnNwbGl0KFwiLlwiKVswXTtcbiAgICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcyhcIlNhZmFyaS9cIikgJiYgIXVzZXJBZ2VudC5pbmNsdWRlcyhcIkNocm9tZS9cIikpIHtcbiAgICAgIG5hbWUgPSBcInNhZmFyaVwiO1xuICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oWzAtOV0rKD86XFwuWzAtOV0rKSopLyk7XG4gICAgICBpZiAobWF0Y2gpXG4gICAgICAgIHZlcnNpb24gPSBtYXRjaFsxXS5zcGxpdChcIi5cIilbMF07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInVua25vd25cIikge1xuICAgICAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgICAgIHsgcmVnZXg6IC9DaHJvbWVcXC8oWzAtOV0rKS8sIG5hbWU6IFwiY2hyb21lXCIgfSxcbiAgICAgICAgeyByZWdleDogL0ZpcmVmb3hcXC8oWzAtOV0rKS8sIG5hbWU6IFwiZmlyZWZveFwiIH0sXG4gICAgICAgIHsgcmVnZXg6IC9TYWZhcmlcXC8oWzAtOV0rKS8sIG5hbWU6IFwic2FmYXJpXCIgfSxcbiAgICAgICAgeyByZWdleDogL0VkZ2VcXC8oWzAtOV0rKS8sIG5hbWU6IFwiZWRnZVwiIH0sXG4gICAgICAgIHsgcmVnZXg6IC9PcGVyYVxcLyhbMC05XSspLywgbmFtZTogXCJvcGVyYVwiIH1cbiAgICAgIF07XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2gocGF0dGVybi5yZWdleCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIG5hbWUgPSBwYXR0ZXJuLm5hbWU7XG4gICAgICAgICAgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gIHJldHVybiB7IG5hbWUsIHZlcnNpb24sIHVzZXJBZ2VudCB9O1xufVxuZnVuY3Rpb24gZGV0ZWN0QnJvd3NlcigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdy5uYXZpZ2F0b3I/LnVzZXJBZ2VudCkge1xuICAgIHJldHVybiB7IG5hbWU6IFwidW5rbm93blwiLCB2ZXJzaW9uOiBcInVua25vd25cIiwgdXNlckFnZW50OiBcInVua25vd25cIiB9O1xuICB9XG4gIGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCBoYXNCcmF2ZUFQSSA9ICEhbmF2aWdhdG9yLmJyYXZlO1xuICByZXR1cm4gcGFyc2VCcm93c2VyRnJvbVVzZXJBZ2VudCh1c2VyQWdlbnQsIGhhc0JyYXZlQVBJKTtcbn1cbmZ1bmN0aW9uIGdldFBsYXRmb3JtTmFtZSgpIHtcbiAgY29uc3QgeyBuYW1lLCB2ZXJzaW9uIH0gPSBkZXRlY3RCcm93c2VyKCk7XG4gIHJldHVybiB2ZXJzaW9uICE9PSBcInVua25vd25cIiA/IGAke25hbWV9LXYke3ZlcnNpb259YCA6IG5hbWU7XG59XG5mdW5jdGlvbiBnZXRCcm93c2VyRGlzcGxheU5hbWUoKSB7XG4gIGNvbnN0IHsgbmFtZSwgdmVyc2lvbiB9ID0gZGV0ZWN0QnJvd3NlcigpO1xuICBjb25zdCBjYXBpdGFsaXplZE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgcmV0dXJuIHZlcnNpb24gIT09IFwidW5rbm93blwiID8gYCR7Y2FwaXRhbGl6ZWROYW1lfSAke3ZlcnNpb259YCA6IGNhcGl0YWxpemVkTmFtZTtcbn1cbmZ1bmN0aW9uIGlzTW9iaWxlRGV2aWNlKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93Lm5hdmlnYXRvcj8udXNlckFnZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1vYmlsZVBhdHRlcm5zID0gW1xuICAgIC9hbmRyb2lkLyxcbiAgICAvaXBob25lfGlwYWR8aXBvZC8sXG4gICAgL2JsYWNrYmVycnkvLFxuICAgIC93aW5kb3dzIHBob25lLyxcbiAgICAvbW9iaWxlLyxcbiAgICAvdGFibGV0LyxcbiAgICAvc2lsay8sXG4gICAgL2tpbmRsZS8sXG4gICAgL29wZXJhIG1pbmkvLFxuICAgIC9vcGVyYSBtb2JpL1xuICBdO1xuICBjb25zdCBpc01vYmlsZVVBID0gbW9iaWxlUGF0dGVybnMuc29tZSgocGF0dGVybikgPT4gcGF0dGVybi50ZXN0KHVzZXJBZ2VudCkpO1xuICBsZXQgaXNTbWFsbFNjcmVlbiA9IGZhbHNlO1xuICB0cnkge1xuICAgIGlzU21hbGxTY3JlZW4gPSB3aW5kb3cuc2NyZWVuLndpZHRoIDw9IDc2OCB8fCB3aW5kb3cuc2NyZWVuLmhlaWdodCA8PSA3Njg7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXNTbWFsbFNjcmVlbiA9IGZhbHNlO1xuICB9XG4gIGxldCBpc1RvdWNoRGV2aWNlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgaXNUb3VjaERldmljZSA9IFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXNUb3VjaERldmljZSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBpc01vYmlsZVVBIHx8IGlzU21hbGxTY3JlZW4gJiYgaXNUb3VjaERldmljZTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9lbWJlZGRlZC9hZGFwdGVycy9hdXRoLnRzXG52YXIgQnJvd3NlckF1dGhQcm92aWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodXJsUGFyYW1zQWNjZXNzb3IpIHtcbiAgICB0aGlzLnVybFBhcmFtc0FjY2Vzc29yID0gdXJsUGFyYW1zQWNjZXNzb3I7XG4gIH1cbiAgZ2V0VmFsaWRhdGVkQ3VycmVudFVybCgpIHtcbiAgICBjb25zdCBjdXJyZW50VXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgaWYgKCFjdXJyZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSAmJiAhY3VycmVudFVybC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVSTCBwcm90b2NvbCAtIG9ubHkgSFRUUC9IVFRQUyBVUkxzIGFyZSBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VXJsO1xuICB9XG4gIGF1dGhlbnRpY2F0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoXCJqd3RUb2tlblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSldUIGF1dGhlbnRpY2F0aW9uIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBjb3JlIEpXVEF1dGggY2xhc3NcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwaGFudG9tT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuUEhBTlRPTV9DT05ORUNUX0FVVEgsIFwiU3RhcnRpbmcgUGhhbnRvbSBDb25uZWN0IGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgICAgcHVibGljS2V5OiBwaGFudG9tT3B0aW9ucy5wdWJsaWNLZXksXG4gICAgICAgIGFwcElkOiBwaGFudG9tT3B0aW9ucy5hcHBJZCxcbiAgICAgICAgcHJvdmlkZXI6IHBoYW50b21PcHRpb25zLnByb3ZpZGVyLFxuICAgICAgICBhdXRoVXJsOiBwaGFudG9tT3B0aW9ucy5hdXRoVXJsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBwaGFudG9tT3B0aW9ucy5hdXRoVXJsIHx8IERFRkFVTFRfQVVUSF9VUkw7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QSEFOVE9NX0NPTk5FQ1RfQVVUSCwgXCJVc2luZyBhdXRoIFVSTFwiLCB7IGJhc2VVcmwgfSk7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgcHVibGljX2tleTogcGhhbnRvbU9wdGlvbnMucHVibGljS2V5LFxuICAgICAgICBhcHBfaWQ6IHBoYW50b21PcHRpb25zLmFwcElkLFxuICAgICAgICByZWRpcmVjdF91cmk6IHBoYW50b21PcHRpb25zLnJlZGlyZWN0VXJsIHx8ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5nZXRWYWxpZGF0ZWRDdXJyZW50VXJsKCkgOiBcIlwiKSxcbiAgICAgICAgc2Vzc2lvbl9pZDogcGhhbnRvbU9wdGlvbnMuc2Vzc2lvbklkLFxuICAgICAgICAvLyBPQXV0aCBzZXNzaW9uIG1hbmFnZW1lbnQgLSBkZWZhdWx0cyB0byBhbGxvdyByZWZyZXNoIHVubGVzcyBleHBsaWNpdGx5IGNsZWFyaW5nIGFmdGVyIGxvZ291dFxuICAgICAgICBjbGVhcl9wcmV2aW91c19zZXNzaW9uOiAocGhhbnRvbU9wdGlvbnMuY2xlYXJQcmV2aW91c1Nlc3Npb24gPz8gZmFsc2UpLnRvU3RyaW5nKCksXG4gICAgICAgIGFsbG93X3JlZnJlc2g6IChwaGFudG9tT3B0aW9ucy5hbGxvd1JlZnJlc2ggPz8gdHJ1ZSkudG9TdHJpbmcoKSxcbiAgICAgICAgc2RrX3ZlcnNpb246IFwiMS4wLjJcIixcbiAgICAgICAgc2RrX3R5cGU6IFwiYnJvd3NlclwiLFxuICAgICAgICBwbGF0Zm9ybTogZGV0ZWN0QnJvd3NlcigpLm5hbWVcbiAgICAgIH0pO1xuICAgICAgaWYgKHBoYW50b21PcHRpb25zLnByb3ZpZGVyKSB7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIlByb3ZpZGVyIHNwZWNpZmllZCwgd2lsbCBza2lwIHNlbGVjdGlvblwiLCB7XG4gICAgICAgICAgcHJvdmlkZXI6IHBoYW50b21PcHRpb25zLnByb3ZpZGVyXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwicHJvdmlkZXJcIiwgcGhhbnRvbU9wdGlvbnMucHJvdmlkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUEhBTlRPTV9DT05ORUNUX0FVVEgsIFwiTm8gcHJvdmlkZXIgc3BlY2lmaWVkLCBkZWZhdWx0aW5nIHRvIEdvb2dsZVwiKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcInByb3ZpZGVyXCIsIFwiZ29vZ2xlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXV0aENvbnRleHQgPSB7XG4gICAgICAgIHB1YmxpY0tleTogcGhhbnRvbU9wdGlvbnMucHVibGljS2V5LFxuICAgICAgICBhcHBJZDogcGhhbnRvbU9wdGlvbnMuYXBwSWQsXG4gICAgICAgIHByb3ZpZGVyOiBwaGFudG9tT3B0aW9ucy5wcm92aWRlcixcbiAgICAgICAgc2Vzc2lvbklkOiBwaGFudG9tT3B0aW9ucy5zZXNzaW9uSWRcbiAgICAgIH07XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicGhhbnRvbS1hdXRoLWNvbnRleHRcIiwgSlNPTi5zdHJpbmdpZnkoYXV0aENvbnRleHQpKTtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIlN0b3JlZCBhdXRoIGNvbnRleHQgaW4gc2Vzc2lvbiBzdG9yYWdlXCIsIHsgYXV0aENvbnRleHQgfSk7XG4gICAgICBjb25zdCBhdXRoVXJsID0gYCR7YmFzZVVybH0/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIlJlZGlyZWN0aW5nIHRvIFBoYW50b20gQ29ubmVjdFwiLCB7IGF1dGhVcmwgfSk7XG4gICAgICBpZiAoIWF1dGhVcmwuc3RhcnRzV2l0aChcImh0dHBzOlwiKSAmJiAhYXV0aFVybC5zdGFydHNXaXRoKFwiaHR0cDovL2xvY2FsaG9zdFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF1dGggVVJMIC0gb25seSBIVFRQUyBVUkxzIGFyZSBhbGxvd2VkIGZvciBhdXRoZW50aWNhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYXV0aFVybDtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuICByZXN1bWVBdXRoRnJvbVJlZGlyZWN0KHByb3ZpZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdhbGxldElkID0gdGhpcy51cmxQYXJhbXNBY2Nlc3Nvci5nZXRQYXJhbShcIndhbGxldF9pZFwiKTtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJzZXNzaW9uX2lkXCIpO1xuICAgICAgY29uc3QgYWNjb3VudERlcml2YXRpb25JbmRleCA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJzZWxlY3RlZF9hY2NvdW50X2luZGV4XCIpO1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLnVybFBhcmFtc0FjY2Vzc29yLmdldFBhcmFtKFwiZXJyb3JcIik7XG4gICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gdGhpcy51cmxQYXJhbXNBY2Nlc3Nvci5nZXRQYXJhbShcImVycm9yX2Rlc2NyaXB0aW9uXCIpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyb3JEZXNjcmlwdGlvbiB8fCBlcnJvcjtcbiAgICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhc2UgXCJhY2Nlc3NfZGVuaWVkXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGNhbmNlbGxlZDogJHtlcnJvck1zZ31gKTtcbiAgICAgICAgICBjYXNlIFwiaW52YWxpZF9yZXF1ZXN0XCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXV0aGVudGljYXRpb24gcmVxdWVzdDogJHtlcnJvck1zZ31gKTtcbiAgICAgICAgICBjYXNlIFwic2VydmVyX2Vycm9yXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIHNlcnZlciBlcnJvcjogJHtlcnJvck1zZ31gKTtcbiAgICAgICAgICBjYXNlIFwidGVtcG9yYXJpbHlfdW5hdmFpbGFibGVcIjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0aGVudGljYXRpb24gc2VydmljZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZTogJHtlcnJvck1zZ31gKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZXJyb3JNc2d9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghd2FsbGV0SWQgfHwgIXNlc3Npb25JZCkge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QSEFOVE9NX0NPTk5FQ1RfQVVUSCwgXCJNaXNzaW5nIGF1dGggcGFyYW1ldGVycyBpbiBVUkxcIiwge1xuICAgICAgICAgIGhhc1dhbGxldElkOiAhIXdhbGxldElkLFxuICAgICAgICAgIGhhc1Nlc3Npb25JZDogISFzZXNzaW9uSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dFN0ciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJwaGFudG9tLWF1dGgtY29udGV4dFwiKTtcbiAgICAgIGxldCBjb250ZXh0ID0ge307XG4gICAgICBpZiAoY29udGV4dFN0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnRleHQgPSBKU09OLnBhcnNlKGNvbnRleHRTdHIpO1xuICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIkZhaWxlZCB0byBwYXJzZSBzdG9yZWQgYXV0aCBjb250ZXh0XCIsIHsgZXJyb3I6IHBhcnNlRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0LnNlc3Npb25JZCAmJiBzZXNzaW9uSWQgIT09IGNvbnRleHQuc2Vzc2lvbklkKSB7XG4gICAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuUEhBTlRPTV9DT05ORUNUX0FVVEgsIFwiU2Vzc2lvbiBJRCBtaXNtYXRjaFwiLCB7XG4gICAgICAgICAgdXJsU2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICAgICAgc3RvcmVkU2Vzc2lvbklkOiBjb250ZXh0LnNlc3Npb25JZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBJRCBtaXNtYXRjaCAtIHBvc3NpYmxlIHNlc3Npb24gY29ycnVwdGlvbiBvciByZXBsYXkgYXR0YWNrXCIpO1xuICAgICAgfVxuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcInBoYW50b20tYXV0aC1jb250ZXh0XCIpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIlN1Y2Nlc3NmdWxseSByZXN1bWVkIGF1dGggZnJvbSByZWRpcmVjdFwiLCB7XG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgIGFjY291bnREZXJpdmF0aW9uSW5kZXg6IGFjY291bnREZXJpdmF0aW9uSW5kZXggPyBwYXJzZUludChhY2NvdW50RGVyaXZhdGlvbkluZGV4KSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcmdhbml6YXRpb25JZCA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJvcmdhbml6YXRpb25faWRcIik7XG4gICAgICBjb25zdCBleHBpcmVzSW5NcyA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJleHBpcmVzX2luX21zXCIpO1xuICAgICAgY29uc3QgYXV0aFVzZXJJZCA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJhdXRoX3VzZXJfaWRcIik7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QSEFOVE9NX0NPTk5FQ1RfQVVUSCwgXCJBdXRoIHJlZGlyZWN0IHBhcmFtZXRlcnNcIiwge1xuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgYWNjb3VudERlcml2YXRpb25JbmRleCxcbiAgICAgICAgZXhwaXJlc0luTXMsXG4gICAgICAgIGF1dGhVc2VySWRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFvcmdhbml6YXRpb25JZCkge1xuICAgICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LlBIQU5UT01fQ09OTkVDVF9BVVRILCBcIk1pc3Npbmcgb3JnYW5pemF0aW9uX2lkIGluIGF1dGggcmVzcG9uc2VcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3JnYW5pemF0aW9uX2lkIGluIGF1dGggcmVzcG9uc2VcIik7XG4gICAgICB9XG4gICAgICBpZiAob3JnYW5pemF0aW9uSWQuc3RhcnRzV2l0aChcInRlbXAtXCIpKSB7XG4gICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgRGVidWdDYXRlZ29yeS5QSEFOVE9NX0NPTk5FQ1RfQVVUSCxcbiAgICAgICAgICBcIlJlY2VpdmVkIHRlbXBvcmFyeSBvcmdhbml6YXRpb25faWQsIHNlcnZlciBtYXkgbm90IGJlIGNvbmZpZ3VyZWQgcHJvcGVybHlcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcmdhbml6YXRpb25JZFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBvcmdhbml6YXRpb25JZCxcbiAgICAgICAgYWNjb3VudERlcml2YXRpb25JbmRleDogYWNjb3VudERlcml2YXRpb25JbmRleCA/IHBhcnNlSW50KGFjY291bnREZXJpdmF0aW9uSW5kZXgpIDogMCxcbiAgICAgICAgZXhwaXJlc0luTXM6IGV4cGlyZXNJbk1zID8gcGFyc2VJbnQoZXhwaXJlc0luTXMpIDogMCxcbiAgICAgICAgYXV0aFVzZXJJZDogYXV0aFVzZXJJZCB8fCB2b2lkIDAsXG4gICAgICAgIHByb3ZpZGVyXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwicGhhbnRvbS1hdXRoLWNvbnRleHRcIik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlcnMvZW1iZWRkZWQvYWRhcHRlcnMvcGhhbnRvbS1hcHAudHNcbmltcG9ydCB7IGlzUGhhbnRvbUV4dGVuc2lvbkluc3RhbGxlZCBhcyBpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWQzIH0gZnJvbSBcIkBwaGFudG9tL2Jyb3dzZXItaW5qZWN0ZWQtc2RrXCI7XG5cbi8vIHNyYy9pc1BoYW50b21Mb2dpbkF2YWlsYWJsZS50c1xuaW1wb3J0IHsgaXNQaGFudG9tRXh0ZW5zaW9uSW5zdGFsbGVkIGFzIGlzUGhhbnRvbUV4dGVuc2lvbkluc3RhbGxlZDIgfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1pbmplY3RlZC1zZGtcIjtcbmFzeW5jIGZ1bmN0aW9uIGlzUGhhbnRvbUxvZ2luQXZhaWxhYmxlKHRpbWVvdXRNcyA9IDNlMykge1xuICBjb25zdCBleHRlbnNpb25JbnN0YWxsZWQgPSBhd2FpdCB3YWl0Rm9yRXh0ZW5zaW9uKHRpbWVvdXRNcyk7XG4gIGlmICghZXh0ZW5zaW9uSW5zdGFsbGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cucGhhbnRvbT8uYXBwPy5mZWF0dXJlcyB8fCB0eXBlb2Ygd2luZG93LnBoYW50b20uYXBwLmZlYXR1cmVzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cucGhhbnRvbS5hcHAuZmVhdHVyZXMoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2UuZmVhdHVyZXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5mZWF0dXJlcy5pbmNsdWRlcyhcInBoYW50b21fbG9naW5cIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIFBoYW50b20gZXh0ZW5zaW9uIGZlYXR1cmVzXCIsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JFeHRlbnNpb24odGltZW91dE1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hlY2tJbnRlcnZhbCA9IDEwMDtcbiAgICBjb25zdCBjaGVja0ZvckV4dGVuc2lvbiA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWQyKCkpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dE1zKSB7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGNoZWNrRm9yRXh0ZW5zaW9uLCBjaGVja0ludGVydmFsKTtcbiAgICB9O1xuICAgIGNoZWNrRm9yRXh0ZW5zaW9uKCk7XG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2VtYmVkZGVkL2FkYXB0ZXJzL3BoYW50b20tYXBwLnRzXG52YXIgQnJvd3NlclBoYW50b21BcHBQcm92aWRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBQaGFudG9tIGV4dGVuc2lvbiBpcyBpbnN0YWxsZWQgaW4gdGhlIGJyb3dzZXJcbiAgICovXG4gIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiBpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWQzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZSB1c2luZyB0aGUgUGhhbnRvbSBicm93c2VyIGV4dGVuc2lvblxuICAgKi9cbiAgYXN5bmMgYXV0aGVudGljYXRlKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlBoYW50b20gZXh0ZW5zaW9uIGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIHRoZSBQaGFudG9tIGJyb3dzZXIgZXh0ZW5zaW9uIHRvIHVzZSB0aGlzIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgbG9naW5BdmFpbGFibGUgPSBhd2FpdCBpc1BoYW50b21Mb2dpbkF2YWlsYWJsZSgpO1xuICAgIGlmICghbG9naW5BdmFpbGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQaGFudG9tIExvZ2luIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSB1cGRhdGUgeW91ciBQaGFudG9tIGV4dGVuc2lvbiB0byB1c2UgdGhpcyBhdXRoZW50aWNhdGlvbiBtZXRob2QuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoIXdpbmRvdy5waGFudG9tPy5hcHA/LmxvZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBoYW50b20gZXh0ZW5zaW9uIGxvZ2luIG1ldGhvZCBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cucGhhbnRvbS5hcHAubG9naW4oe1xuICAgICAgICBwdWJsaWNLZXk6IG9wdGlvbnMucHVibGljS2V5LFxuICAgICAgICBhcHBJZDogb3B0aW9ucy5hcHBJZCxcbiAgICAgICAgc2Vzc2lvbklkOiBvcHRpb25zLnNlc3Npb25JZFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LndhbGxldElkIHx8ICFyZXN1bHQub3JnYW5pemF0aW9uSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSBmcm9tIFBoYW50b20gZXh0ZW5zaW9uXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2FsbGV0SWQ6IHJlc3VsdC53YWxsZXRJZCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHJlc3VsdC5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgcHJvdmlkZXI6IFwicGhhbnRvbVwiLFxuICAgICAgICBhY2NvdW50RGVyaXZhdGlvbkluZGV4OiByZXN1bHQuYWNjb3VudERlcml2YXRpb25JbmRleCA/PyAwLFxuICAgICAgICBleHBpcmVzSW5NczogcmVzdWx0LmV4cGlyZXNJbk1zID8/IDAsXG4gICAgICAgIGF1dGhVc2VySWQ6IHJlc3VsdC5hdXRoVXNlcklkXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGhhbnRvbSBleHRlbnNpb24gYXV0aGVudGljYXRpb24gZmFpbGVkOiAke1N0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXJzL2VtYmVkZGVkL2FkYXB0ZXJzL2xvZ2dlci50c1xudmFyIEJyb3dzZXJMb2dnZXIgPSBjbGFzcyB7XG4gIGluZm8oY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBkZWJ1Zy5pbmZvKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxuICB3YXJuKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgZGVidWcud2FybihjYXRlZ29yeSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgZXJyb3IoY2F0ZWdvcnksIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBkZWJ1Zy5lcnJvcihjYXRlZ29yeSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbiAgbG9nKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgZGVidWcubG9nKGNhdGVnb3J5LCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVycy9lbWJlZGRlZC9pbmRleC50c1xuaW1wb3J0IHsgQU5BTFlUSUNTX0hFQURFUlMgfSBmcm9tIFwiQHBoYW50b20vY29uc3RhbnRzXCI7XG52YXIgRW1iZWRkZWRQcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgQ29yZUVtYmVkZGVkUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5FTUJFRERFRF9QUk9WSURFUiwgXCJJbml0aWFsaXppbmcgQnJvd3NlciBFbWJlZGRlZFByb3ZpZGVyXCIsIHsgY29uZmlnIH0pO1xuICAgIGNvbnN0IHVybFBhcmFtc0FjY2Vzc29yID0gbmV3IEJyb3dzZXJVUkxQYXJhbXNBY2Nlc3NvcigpO1xuICAgIGNvbnN0IHN0YW1wZXIgPSBuZXcgSW5kZXhlZERiU3RhbXBlcih7XG4gICAgICBkYk5hbWU6IGBwaGFudG9tLWVtYmVkZGVkLXNkay0ke2NvbmZpZy5hcHBJZH1gLFxuICAgICAgc3RvcmVOYW1lOiBcImNyeXB0by1rZXlzXCIsXG4gICAgICBrZXlOYW1lOiBcInNpZ25pbmcta2V5XCJcbiAgICB9KTtcbiAgICBjb25zdCBwbGF0Zm9ybU5hbWUgPSBnZXRQbGF0Zm9ybU5hbWUoKTtcbiAgICBjb25zdCB7IG5hbWU6IGJyb3dzZXJOYW1lLCB2ZXJzaW9uIH0gPSBkZXRlY3RCcm93c2VyKCk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB7XG4gICAgICBzdG9yYWdlOiBuZXcgQnJvd3NlclN0b3JhZ2UoKSxcbiAgICAgIGF1dGhQcm92aWRlcjogbmV3IEJyb3dzZXJBdXRoUHJvdmlkZXIodXJsUGFyYW1zQWNjZXNzb3IpLFxuICAgICAgcGhhbnRvbUFwcFByb3ZpZGVyOiBuZXcgQnJvd3NlclBoYW50b21BcHBQcm92aWRlcigpLFxuICAgICAgdXJsUGFyYW1zQWNjZXNzb3IsXG4gICAgICBzdGFtcGVyLFxuICAgICAgbmFtZTogcGxhdGZvcm1OYW1lLFxuICAgICAgLy8gVXNlIGRldGVjdGVkIGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvbiBmb3IgaWRlbnRpZmljYXRpb25cbiAgICAgIGFuYWx5dGljc0hlYWRlcnM6IHtcbiAgICAgICAgW0FOQUxZVElDU19IRUFERVJTLlNES19UWVBFXTogXCJicm93c2VyXCIsXG4gICAgICAgIFtBTkFMWVRJQ1NfSEVBREVSUy5QTEFURk9STV06IGJyb3dzZXJOYW1lLFxuICAgICAgICAvLyBmaXJlZm94LCBjaHJvbWUsIHNhZmFyaSwgZXRjLlxuICAgICAgICBbQU5BTFlUSUNTX0hFQURFUlMuUExBVEZPUk1fVkVSU0lPTl06IHZlcnNpb24sXG4gICAgICAgIC8vIEZ1bGwgdXNlciBhZ2VudCBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvXG4gICAgICAgIFtBTkFMWVRJQ1NfSEVBREVSUy5BUFBfSURdOiBjb25maWcuYXBwSWQsXG4gICAgICAgIFtBTkFMWVRJQ1NfSEVBREVSUy5XQUxMRVRfVFlQRV06IGNvbmZpZy5lbWJlZGRlZFdhbGxldFR5cGUsXG4gICAgICAgIFtBTkFMWVRJQ1NfSEVBREVSUy5TREtfVkVSU0lPTl06IFwiMS4wLjJcIlxuICAgICAgICAvLyBSZXBsYWNlZCBhdCBidWlsZCB0aW1lXG4gICAgICB9XG4gICAgfTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5FTUJFRERFRF9QUk9WSURFUiwgXCJEZXRlY3RlZCBwbGF0Zm9ybVwiLCB7IHBsYXRmb3JtTmFtZSB9KTtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgQnJvd3NlckxvZ2dlcigpO1xuICAgIHN1cGVyKGNvbmZpZywgcGxhdGZvcm0sIGxvZ2dlcik7XG4gICAgdGhpcy5hZGRyZXNzVHlwZXMgPSBjb25maWcuYWRkcmVzc1R5cGVzO1xuICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5FTUJFRERFRF9QUk9WSURFUiwgXCJCcm93c2VyIEVtYmVkZGVkUHJvdmlkZXIgaW5pdGlhbGl6ZWRcIik7XG4gIH1cbiAgZ2V0RW5hYmxlZEFkZHJlc3NUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzVHlwZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9Qcm92aWRlck1hbmFnZXIudHNcbmltcG9ydCB7XG4gIEVNQkVEREVEX1BST1ZJREVSX0FVVEhfVFlQRVNcbn0gZnJvbSBcIkBwaGFudG9tL2VtYmVkZGVkLXByb3ZpZGVyLWNvcmVcIjtcbmltcG9ydCB7IERFRkFVTFRfV0FMTEVUX0FQSV9VUkwsIERFRkFVTFRfRU1CRURERURfV0FMTEVUX1RZUEUsIERFRkFVTFRfQVVUSF9VUkwgYXMgREVGQVVMVF9BVVRIX1VSTDIgfSBmcm9tIFwiQHBoYW50b20vY29uc3RhbnRzXCI7XG5cbi8vIHNyYy91dGlscy9hdXRoLWNhbGxiYWNrLnRzXG5mdW5jdGlvbiBpc0F1dGhGYWlsdXJlQ2FsbGJhY2soc2VhcmNoUGFyYW1zKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiICYmICFzZWFyY2hQYXJhbXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXJhbXMgPSBzZWFyY2hQYXJhbXMgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgY29uc3QgcmVzcG9uc2VUeXBlID0gcGFyYW1zLmdldChcInJlc3BvbnNlX3R5cGVcIik7XG4gIGNvbnN0IHNlc3Npb25JZCA9IHBhcmFtcy5nZXQoXCJzZXNzaW9uX2lkXCIpO1xuICByZXR1cm4gcmVzcG9uc2VUeXBlID09PSBcImZhaWx1cmVcIiAmJiAhIXNlc3Npb25JZDtcbn1cbmZ1bmN0aW9uIGlzQXV0aENhbGxiYWNrVXJsKHNlYXJjaFBhcmFtcykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhc2VhcmNoUGFyYW1zKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcGFyYW1zID0gc2VhcmNoUGFyYW1zIHx8IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gIGNvbnN0IHNlc3Npb25JZCA9IHBhcmFtcy5nZXQoXCJzZXNzaW9uX2lkXCIpO1xuICByZXR1cm4gISEoc2Vzc2lvbklkICYmIChwYXJhbXMuaGFzKFwicmVzcG9uc2VfdHlwZVwiKSB8fCBwYXJhbXMuaGFzKFwid2FsbGV0X2lkXCIpKSk7XG59XG5cbi8vIHNyYy91dGlscy9kZWVwbGluay50c1xuZnVuY3Rpb24gZ2V0RGVlcGxpbmtUb1BoYW50b20ocmVmKSB7XG4gIGlmICghd2luZG93LmxvY2F0aW9uLmhyZWYuc3RhcnRzV2l0aChcImh0dHA6XCIpICYmICF3aW5kb3cubG9jYXRpb24uaHJlZi5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVUkwgcHJvdG9jb2wgLSBvbmx5IEhUVFAvSFRUUFMgVVJMcyBhcmUgc3VwcG9ydGVkIGZvciBkZWVwbGlua3NcIik7XG4gIH1cbiAgY29uc3QgY3VycmVudFVybCA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gIGNvbnN0IHJlZlBhcmFtID0gcmVmID8gYD9yZWY9JHtlbmNvZGVVUklDb21wb25lbnQocmVmKX1gIDogXCJcIjtcbiAgcmV0dXJuIGBodHRwczovL3BoYW50b20uYXBwL3VsL2Jyb3dzZS8ke2N1cnJlbnRVcmx9JHtyZWZQYXJhbX1gO1xufVxuXG4vLyBzcmMvUHJvdmlkZXJNYW5hZ2VyLnRzXG52YXIgUHJvdmlkZXJNYW5hZ2VyID0gY2xhc3Mge1xuICAvLyBUcmFjayB3aGljaCBwcm92aWRlcnMgaGF2ZSBmb3J3YXJkaW5nIHNldCB1cFxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFByb3ZpZGVyS2V5ID0gbnVsbDtcbiAgICAvLyBFdmVudCBtYW5hZ2VtZW50IGZvciBmb3J3YXJkaW5nIHByb3ZpZGVyIGV2ZW50c1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJvdmlkZXJGb3J3YXJkaW5nU2V0dXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkluaXRpYWxpemluZyBQcm92aWRlck1hbmFnZXJcIiwgeyBjb25maWcgfSk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJTZXR0aW5nIGRlZmF1bHQgcHJvdmlkZXJcIik7XG4gICAgdGhpcy5zZXREZWZhdWx0UHJvdmlkZXIoKTtcbiAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJQcm92aWRlck1hbmFnZXIgaW5pdGlhbGl6ZWRcIiwge1xuICAgICAgY3VycmVudFByb3ZpZGVyS2V5OiB0aGlzLmN1cnJlbnRQcm92aWRlcktleVxuICAgIH0pO1xuICB9XG4gIGdldFZhbGlkYXRlZEN1cnJlbnRVcmwoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBjdXJyZW50VXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgaWYgKCFjdXJyZW50VXJsLnN0YXJ0c1dpdGgoXCJodHRwOlwiKSAmJiAhY3VycmVudFVybC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVSTCBwcm90b2NvbCAtIG9ubHkgSFRUUC9IVFRQUyBVUkxzIGFyZSBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VXJsO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gYSBkaWZmZXJlbnQgcHJvdmlkZXIgdHlwZVxuICAgKi9cbiAgc3dpdGNoUHJvdmlkZXIodHlwZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5lbWJlZGRlZFdhbGxldFR5cGUgJiYgIVtcImFwcC13YWxsZXRcIiwgXCJ1c2VyLXdhbGxldFwiXS5pbmNsdWRlcyhvcHRpb25zLmVtYmVkZGVkV2FsbGV0VHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgZW1iZWRkZWRXYWxsZXRUeXBlOiAke29wdGlvbnMuZW1iZWRkZWRXYWxsZXRUeXBlfS4gTXVzdCBiZSBcImFwcC13YWxsZXRcIiBvciBcInVzZXItd2FsbGV0XCIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRQcm92aWRlcktleSh0eXBlLCBvcHRpb25zPy5lbWJlZGRlZFdhbGxldFR5cGUpO1xuICAgIGlmICghdGhpcy5wcm92aWRlcnMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMuY3JlYXRlUHJvdmlkZXIodHlwZSwgb3B0aW9ucz8uZW1iZWRkZWRXYWxsZXRUeXBlKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQoa2V5KTtcbiAgICB0aGlzLmN1cnJlbnRQcm92aWRlcktleSA9IGtleTtcbiAgICB0aGlzLmVuc3VyZVByb3ZpZGVyRXZlbnRGb3J3YXJkaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgYWN0aXZlIHByb3ZpZGVyXG4gICAqL1xuICBnZXRDdXJyZW50UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBwcm92aWRlciB0eXBlIGFuZCBvcHRpb25zXG4gICAqL1xuICBnZXRDdXJyZW50UHJvdmlkZXJJbmZvKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50UHJvdmlkZXJLZXkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuY3VycmVudFByb3ZpZGVyS2V5LnNwbGl0KFwiLVwiKTtcbiAgICBjb25zdCBbdHlwZSwgZW1iZWRkZWRXYWxsZXRUeXBlXSA9IHBhcnRzO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgZW1iZWRkZWRXYWxsZXRUeXBlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwcm92aWRlciBpcyBhbGxvd2VkIGJ5IHRoZSBjb25maWdcbiAgICovXG4gIGlzUHJvdmlkZXJBbGxvd2VkKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVycy5pbmNsdWRlcyhwcm92aWRlcik7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdXNpbmcgdGhlIGN1cnJlbnQgcHJvdmlkZXJcbiAgICogQXV0b21hdGljYWxseSBzd2l0Y2hlcyBwcm92aWRlciBiYXNlZCBvbiBhdXRoT3B0aW9ucy5wcm92aWRlclxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChhdXRoT3B0aW9ucykge1xuICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIlN0YXJ0aW5nIGNvbm5lY3Rpb25cIiwge1xuICAgICAgY3VycmVudFByb3ZpZGVyS2V5OiB0aGlzLmN1cnJlbnRQcm92aWRlcktleSxcbiAgICAgIGF1dGhPcHRpb25zOiB7IHByb3ZpZGVyOiBhdXRoT3B0aW9ucy5wcm92aWRlciB9XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLmlzUHJvdmlkZXJBbGxvd2VkKGF1dGhPcHRpb25zLnByb3ZpZGVyKSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBgUHJvdmlkZXIgXCIke2F1dGhPcHRpb25zLnByb3ZpZGVyfVwiIGlzIG5vdCBpbiB0aGUgYWxsb3dlZCBwcm92aWRlcnMgbGlzdDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZy5wcm92aWRlcnMpfWA7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RlZFByb3ZpZGVyID0gYXV0aE9wdGlvbnMucHJvdmlkZXI7XG4gICAgbGV0IHRhcmdldFByb3ZpZGVyVHlwZSA9IG51bGw7XG4gICAgaWYgKHJlcXVlc3RlZFByb3ZpZGVyID09PSBcImluamVjdGVkXCIpIHtcbiAgICAgIHRhcmdldFByb3ZpZGVyVHlwZSA9IFwiaW5qZWN0ZWRcIjtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RlZFByb3ZpZGVyID09PSBcImRlZXBsaW5rXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlZXBsaW5rVXJsID0gZ2V0RGVlcGxpbmtUb1BoYW50b20oKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlZXBsaW5rVXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkcmVzc2VzOiBbXSxcbiAgICAgICAgICB3YWxsZXRJZDogdm9pZCAwLFxuICAgICAgICAgIGF1dGhVc2VySWQ6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBvcGVuIGRlZXBsaW5rXCI7XG4gICAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJEZWVwbGluayBlcnJvclwiLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gZGVlcGxpbms6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRU1CRURERURfUFJPVklERVJfQVVUSF9UWVBFUy5pbmNsdWRlcyhyZXF1ZXN0ZWRQcm92aWRlcikpIHtcbiAgICAgIHRhcmdldFByb3ZpZGVyVHlwZSA9IFwiZW1iZWRkZWRcIjtcbiAgICB9XG4gICAgaWYgKHRhcmdldFByb3ZpZGVyVHlwZSkge1xuICAgICAgY29uc3QgY3VycmVudEluZm8gPSB0aGlzLmdldEN1cnJlbnRQcm92aWRlckluZm8oKTtcbiAgICAgIGlmIChjdXJyZW50SW5mbz8udHlwZSAhPT0gdGFyZ2V0UHJvdmlkZXJUeXBlKSB7XG4gICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQXV0by1zd2l0Y2hpbmcgcHJvdmlkZXIgYmFzZWQgb24gYXV0aCBvcHRpb25zXCIsIHtcbiAgICAgICAgICBmcm9tOiBjdXJyZW50SW5mbz8udHlwZSxcbiAgICAgICAgICB0bzogdGFyZ2V0UHJvdmlkZXJUeXBlLFxuICAgICAgICAgIHJlcXVlc3RlZFByb3ZpZGVyXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzd2l0Y2hPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0YXJnZXRQcm92aWRlclR5cGUgPT09IFwiZW1iZWRkZWRcIikge1xuICAgICAgICAgIHN3aXRjaE9wdGlvbnMuZW1iZWRkZWRXYWxsZXRUeXBlID0gY3VycmVudEluZm8/LmVtYmVkZGVkV2FsbGV0VHlwZSB8fCB0aGlzLmNvbmZpZy5lbWJlZGRlZFdhbGxldFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zd2l0Y2hQcm92aWRlcih0YXJnZXRQcm92aWRlclR5cGUsIHN3aXRjaE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuY3VycmVudFByb3ZpZGVyKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiTm8gcHJvdmlkZXIgc2VsZWN0ZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBzZWxlY3RlZFwiKTtcbiAgICB9XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJEZWxlZ2F0aW5nIHRvIHByb3ZpZGVyIGNvbm5lY3QgbWV0aG9kXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY3VycmVudFByb3ZpZGVyLmNvbm5lY3QoYXV0aE9wdGlvbnMpO1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQ29ubmVjdGlvbiBzdWNjZXNzZnVsLCBzYXZpbmcgcHJlZmVyZW5jZXNcIiwge1xuICAgICAgYWRkcmVzc0NvdW50OiByZXN1bHQuYWRkcmVzc2VzPy5sZW5ndGggfHwgMCxcbiAgICAgIHByb3ZpZGVyOiBhdXRoT3B0aW9ucy5wcm92aWRlclxuICAgIH0pO1xuICAgIHRoaXMuc2F2ZVByb3ZpZGVyUHJlZmVyZW5jZSgpO1xuICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkNvbm5lY3QgY29tcGxldGVkXCIsIHtcbiAgICAgIGFkZHJlc3NlczogcmVzdWx0LmFkZHJlc3NlcyxcbiAgICAgIHByb3ZpZGVyOiBhdXRoT3B0aW9ucy5wcm92aWRlclxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgZnJvbSBjdXJyZW50IHByb3ZpZGVyXG4gICAqL1xuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50UHJvdmlkZXIpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgdGhpcy5jdXJyZW50UHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWRkcmVzc2VzIGZyb20gY3VycmVudCBwcm92aWRlclxuICAgKi9cbiAgZ2V0QWRkcmVzc2VzKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50UHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyLmdldEFkZHJlc3NlcygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50IHByb3ZpZGVyIGlzIGNvbm5lY3RlZFxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyPy5pc0Nvbm5lY3RlZCgpID8/IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IGF1dG8tY29ubmVjdCB3aXRoIGZhbGxiYWNrIHN0cmF0ZWd5XG4gICAqIFRyaWVzIGVtYmVkZGVkIHByb3ZpZGVyIGZpcnN0IGlmIGl0IGV4aXN0cyBhbmQgaXMgYWxsb3dlZCwgdGhlbiBpbmplY3RlZCBwcm92aWRlciBpZiBhbGxvd2VkXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgcHJvdmlkZXIgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZFxuICAgKi9cbiAgYXN5bmMgYXV0b0Nvbm5lY3QoKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJTdGFydGluZyBhdXRvLWNvbm5lY3Qgd2l0aCBmYWxsYmFjayBzdHJhdGVneVwiKTtcbiAgICBpZiAoaXNBdXRoRmFpbHVyZUNhbGxiYWNrKCkpIHtcbiAgICAgIGRlYnVnLndhcm4oRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkF1dGggZmFpbHVyZSBkZXRlY3RlZCBpbiBVUkwsIHNraXBwaW5nIGF1dG9Db25uZWN0IGZhbGxiYWNrXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbWJlZGRlZFdhbGxldFR5cGUgPSB0aGlzLmNvbmZpZy5lbWJlZGRlZFdhbGxldFR5cGUgfHwgXCJ1c2VyLXdhbGxldFwiO1xuICAgIGNvbnN0IGVtYmVkZGVkS2V5ID0gdGhpcy5nZXRQcm92aWRlcktleShcImVtYmVkZGVkXCIsIGVtYmVkZGVkV2FsbGV0VHlwZSk7XG4gICAgY29uc3QgZW1iZWRkZWRBbGxvd2VkID0gdGhpcy5jb25maWcucHJvdmlkZXJzLnNvbWUoKHApID0+IHAgIT09IFwiaW5qZWN0ZWRcIik7XG4gICAgaWYgKGVtYmVkZGVkQWxsb3dlZCAmJiB0aGlzLnByb3ZpZGVycy5oYXMoZW1iZWRkZWRLZXkpKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIlRyeWluZyBhdXRvLWNvbm5lY3Qgd2l0aCBleGlzdGluZyBlbWJlZGRlZCBwcm92aWRlclwiKTtcbiAgICAgIGNvbnN0IGVtYmVkZGVkUHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQoZW1iZWRkZWRLZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQcm92aWRlciA9IHRoaXMuY3VycmVudFByb3ZpZGVyO1xuICAgICAgICBjb25zdCBwcmV2aW91c0tleSA9IHRoaXMuY3VycmVudFByb3ZpZGVyS2V5O1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IGVtYmVkZGVkUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFByb3ZpZGVyS2V5ID0gZW1iZWRkZWRLZXk7XG4gICAgICAgIHRoaXMuZW5zdXJlUHJvdmlkZXJFdmVudEZvcndhcmRpbmcoKTtcbiAgICAgICAgYXdhaXQgZW1iZWRkZWRQcm92aWRlci5hdXRvQ29ubmVjdCgpO1xuICAgICAgICBpZiAoZW1iZWRkZWRQcm92aWRlci5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiRW1iZWRkZWQgYXV0by1jb25uZWN0IHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgICAgdGhpcy5zYXZlUHJvdmlkZXJQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJFbWJlZGRlZCBwcm92aWRlciBkaWQgbm90IGNvbm5lY3QsIHJlc3RvcmluZyBwcmV2aW91cyBwcm92aWRlclwiKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByZXZpb3VzUHJvdmlkZXI7XG4gICAgICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXJLZXkgPSBwcmV2aW91c0tleTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJFbWJlZGRlZCBhdXRvLWNvbm5lY3QgZmFpbGVkXCIsIHtcbiAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXV0aENhbGxiYWNrVXJsKCkpIHtcbiAgICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkluIGF1dGggY2FsbGJhY2sgVVJMLCBub3QgYXR0ZW1wdGluZyBpbmplY3RlZCBmYWxsYmFja1wiKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5qZWN0ZWRBbGxvd2VkID0gdGhpcy5jb25maWcucHJvdmlkZXJzLmluY2x1ZGVzKFwiaW5qZWN0ZWRcIik7XG4gICAgY29uc3QgaW5qZWN0ZWRLZXkgPSB0aGlzLmdldFByb3ZpZGVyS2V5KFwiaW5qZWN0ZWRcIik7XG4gICAgaWYgKGluamVjdGVkQWxsb3dlZCAmJiB0aGlzLnByb3ZpZGVycy5oYXMoaW5qZWN0ZWRLZXkpKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIlRyeWluZyBhdXRvLWNvbm5lY3Qgd2l0aCBleGlzdGluZyBpbmplY3RlZCBwcm92aWRlclwiKTtcbiAgICAgIGNvbnN0IGluamVjdGVkUHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQoaW5qZWN0ZWRLZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBpbmplY3RlZFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlcktleSA9IGluamVjdGVkS2V5O1xuICAgICAgICB0aGlzLmVuc3VyZVByb3ZpZGVyRXZlbnRGb3J3YXJkaW5nKCk7XG4gICAgICAgIGF3YWl0IGluamVjdGVkUHJvdmlkZXIuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKGluamVjdGVkUHJvdmlkZXIuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkluamVjdGVkIGF1dG8tY29ubmVjdCBzdWNjZXNzZnVsXCIpO1xuICAgICAgICAgIHRoaXMuc2F2ZVByb3ZpZGVyUHJlZmVyZW5jZSgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkluamVjdGVkIGF1dG8tY29ubmVjdCBmYWlsZWRcIiwge1xuICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkF1dG8tY29ubmVjdCBmYWlsZWQgZm9yIGFsbCBhbGxvd2VkIHByb3ZpZGVyc1wiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBldmVudCBsaXN0ZW5lciAtIHN0b3JlcyBjYWxsYmFjayBhbmQgZW5zdXJlcyBjdXJyZW50IHByb3ZpZGVyIGZvcndhcmRzIGV2ZW50cyB0byBQcm92aWRlck1hbmFnZXJcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQWRkaW5nIGV2ZW50IGxpc3RlbmVyXCIsIHsgZXZlbnQgfSk7XG4gICAgaWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQpPy5hZGQoY2FsbGJhY2spO1xuICAgIHRoaXMuZW5zdXJlUHJvdmlkZXJFdmVudEZvcndhcmRpbmcoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJSZW1vdmluZyBldmVudCBsaXN0ZW5lclwiLCB7IGV2ZW50IH0pO1xuICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KT8uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk/LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW1pdCBldmVudCB0byBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICovXG4gIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkVtaXR0aW5nIGV2ZW50IHRvIHN0b3JlZCBjYWxsYmFja3NcIiwge1xuICAgICAgZXZlbnQsXG4gICAgICBsaXN0ZW5lckNvdW50OiB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk/LnNpemUgfHwgMCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQ2FsbGluZyBzdG9yZWQgY2FsbGJhY2sgZm9yIGV2ZW50XCIsIHsgZXZlbnQgfSk7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkV2ZW50IGNhbGxiYWNrIGVycm9yXCIsIHsgZXZlbnQsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiTm8gc3RvcmVkIGNhbGxiYWNrcyBmb3IgZXZlbnRcIiwgeyBldmVudCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZSBjdXJyZW50IHByb3ZpZGVyIGZvcndhcmRzIGl0cyBldmVudHMgdG8gdGhpcyBQcm92aWRlck1hbmFnZXJcbiAgICogT25seSBzZXRzIHVwIGZvcndhcmRpbmcgb25jZSBwZXIgcHJvdmlkZXIgaW5zdGFuY2UgdG8gYXZvaWQgYWNjdW11bGF0aW9uXG4gICAqL1xuICBlbnN1cmVQcm92aWRlckV2ZW50Rm9yd2FyZGluZygpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFByb3ZpZGVyIHx8ICEoXCJvblwiIGluIHRoaXMuY3VycmVudFByb3ZpZGVyKSkge1xuICAgICAgZGVidWcud2FybihEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQ3VycmVudCBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGV2ZW50c1wiLCB7XG4gICAgICAgIHByb3ZpZGVyVHlwZTogdGhpcy5nZXRDdXJyZW50UHJvdmlkZXJJbmZvKCk/LnR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm92aWRlckZvcndhcmRpbmdTZXR1cC5oYXModGhpcy5jdXJyZW50UHJvdmlkZXIpKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkV2ZW50IGZvcndhcmRpbmcgYWxyZWFkeSBzZXQgdXAgZm9yIGN1cnJlbnQgcHJvdmlkZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiU2V0dGluZyB1cCBldmVudCBmb3J3YXJkaW5nIGZyb20gY3VycmVudCBwcm92aWRlclwiKTtcbiAgICBjb25zdCBldmVudHNUb0ZvcndhcmQgPSBbXG4gICAgICBcImNvbm5lY3Rfc3RhcnRcIixcbiAgICAgIFwiY29ubmVjdFwiLFxuICAgICAgXCJjb25uZWN0X2Vycm9yXCIsXG4gICAgICBcImRpc2Nvbm5lY3RcIixcbiAgICAgIFwiZXJyb3JcIixcbiAgICAgIFwic3BlbmRpbmdfbGltaXRfcmVhY2hlZFwiXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50c1RvRm9yd2FyZCkge1xuICAgICAgY29uc3QgZm9yd2FyZGluZ0NhbGxiYWNrID0gKGRhdGEpID0+IHtcbiAgICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuUFJPVklERVJfTUFOQUdFUiwgXCJGb3J3YXJkaW5nIGV2ZW50IGZyb20gcHJvdmlkZXJcIiwgeyBldmVudCwgZGF0YSB9KTtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCBkYXRhKTtcbiAgICAgIH07XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkF0dGFjaGluZyBmb3J3YXJkaW5nIGNhbGxiYWNrIGZvciBldmVudFwiLCB7IGV2ZW50IH0pO1xuICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXIub24oZXZlbnQsIGZvcndhcmRpbmdDYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMucHJvdmlkZXJGb3J3YXJkaW5nU2V0dXAuYWRkKHRoaXMuY3VycmVudFByb3ZpZGVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcHJvdmlkZXIgYmFzZWQgb24gaW5pdGlhbCBjb25maWdcbiAgICogQ3JlYXRlcyBwcm92aWRlcnMgYmFzZWQgb24gdGhlIGFsbG93ZWQgcHJvdmlkZXJzIGFycmF5XG4gICAqL1xuICBzZXREZWZhdWx0UHJvdmlkZXIoKSB7XG4gICAgY29uc3QgZGVmYXVsdEVtYmVkZGVkVHlwZSA9IHRoaXMuY29uZmlnLmVtYmVkZGVkV2FsbGV0VHlwZSB8fCBcInVzZXItd2FsbGV0XCI7XG4gICAgY29uc3QgaGFzSW5qZWN0ZWQgPSB0aGlzLmNvbmZpZy5wcm92aWRlcnMuaW5jbHVkZXMoXCJpbmplY3RlZFwiKTtcbiAgICBjb25zdCBoYXNFbWJlZGRlZCA9IHRoaXMuY29uZmlnLnByb3ZpZGVycy5zb21lKChwKSA9PiBwICE9PSBcImluamVjdGVkXCIgJiYgcCAhPT0gXCJkZWVwbGlua1wiKTtcbiAgICBpZiAoaGFzSW5qZWN0ZWQpIHtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LlBST1ZJREVSX01BTkFHRVIsIFwiQ3JlYXRpbmcgaW5qZWN0ZWQgcHJvdmlkZXIgKGFsbG93ZWQgYnkgcHJvdmlkZXJzIGFycmF5KVwiKTtcbiAgICAgIHRoaXMuY3JlYXRlUHJvdmlkZXIoXCJpbmplY3RlZFwiKTtcbiAgICB9XG4gICAgaWYgKGhhc0VtYmVkZGVkKSB7XG4gICAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5QUk9WSURFUl9NQU5BR0VSLCBcIkNyZWF0aW5nIGVtYmVkZGVkIHByb3ZpZGVyIChhbGxvd2VkIGJ5IHByb3ZpZGVycyBhcnJheSlcIik7XG4gICAgICB0aGlzLmNyZWF0ZVByb3ZpZGVyKFwiZW1iZWRkZWRcIiwgZGVmYXVsdEVtYmVkZGVkVHlwZSk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0VHlwZTtcbiAgICBpZiAoaGFzRW1iZWRkZWQgJiYgdGhpcy5wcm92aWRlcnMuaGFzKGBlbWJlZGRlZC0ke2RlZmF1bHRFbWJlZGRlZFR5cGV9YCkpIHtcbiAgICAgIGRlZmF1bHRUeXBlID0gXCJlbWJlZGRlZFwiO1xuICAgIH0gZWxzZSBpZiAoaGFzSW5qZWN0ZWQgJiYgdGhpcy5wcm92aWRlcnMuaGFzKFwiaW5qZWN0ZWRcIikpIHtcbiAgICAgIGRlZmF1bHRUeXBlID0gXCJpbmplY3RlZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCBwcm92aWRlcnMgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBwcm92aWRlcnMgYXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHN3aXRjaE9wdGlvbnMgPSB7fTtcbiAgICBpZiAoZGVmYXVsdFR5cGUgPT09IFwiZW1iZWRkZWRcIikge1xuICAgICAgc3dpdGNoT3B0aW9ucy5lbWJlZGRlZFdhbGxldFR5cGUgPSBkZWZhdWx0RW1iZWRkZWRUeXBlO1xuICAgIH1cbiAgICB0aGlzLnN3aXRjaFByb3ZpZGVyKGRlZmF1bHRUeXBlLCBzd2l0Y2hPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcHJvdmlkZXIgaW5zdGFuY2VcbiAgICovXG4gIGNyZWF0ZVByb3ZpZGVyKHR5cGUsIGVtYmVkZGVkV2FsbGV0VHlwZSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0UHJvdmlkZXJLZXkodHlwZSwgZW1iZWRkZWRXYWxsZXRUeXBlKTtcbiAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKGtleSkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHByb3ZpZGVyO1xuICAgIGlmICh0eXBlID09PSBcImluamVjdGVkXCIpIHtcbiAgICAgIHByb3ZpZGVyID0gbmV3IEluamVjdGVkUHJvdmlkZXIoe1xuICAgICAgICBhZGRyZXNzVHlwZXM6IHRoaXMuY29uZmlnLmFkZHJlc3NUeXBlcyB8fCBbQWRkcmVzc1R5cGUuc29sYW5hXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVtYmVkZGVkXCIpIHtcbiAgICAgIGlmICghdGhpcy5jb25maWcuYXBwSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBwSWQgaXMgcmVxdWlyZWQgZm9yIGVtYmVkZGVkIHByb3ZpZGVyXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXBpQmFzZVVybCA9IHRoaXMuY29uZmlnLmFwaUJhc2VVcmwgfHwgREVGQVVMVF9XQUxMRVRfQVBJX1VSTDtcbiAgICAgIGNvbnN0IGF1dGhVcmwgPSB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucz8uYXV0aFVybCB8fCBERUZBVUxUX0FVVEhfVVJMMjtcbiAgICAgIHByb3ZpZGVyID0gbmV3IEVtYmVkZGVkUHJvdmlkZXIoe1xuICAgICAgICBhcGlCYXNlVXJsLFxuICAgICAgICBhcHBJZDogdGhpcy5jb25maWcuYXBwSWQsXG4gICAgICAgIGF1dGhPcHRpb25zOiB7XG4gICAgICAgICAgLi4udGhpcy5jb25maWcuYXV0aE9wdGlvbnMgfHwge30sXG4gICAgICAgICAgYXV0aFVybCxcbiAgICAgICAgICByZWRpcmVjdFVybDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnM/LnJlZGlyZWN0VXJsIHx8IHRoaXMuZ2V0VmFsaWRhdGVkQ3VycmVudFVybCgpXG4gICAgICAgIH0sXG4gICAgICAgIGVtYmVkZGVkV2FsbGV0VHlwZTogZW1iZWRkZWRXYWxsZXRUeXBlIHx8IERFRkFVTFRfRU1CRURERURfV0FMTEVUX1RZUEUsXG4gICAgICAgIGFkZHJlc3NUeXBlczogdGhpcy5jb25maWcuYWRkcmVzc1R5cGVzIHx8IFtBZGRyZXNzVHlwZS5zb2xhbmFdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm92aWRlciB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIHRoaXMucHJvdmlkZXJzLnNldChrZXksIHByb3ZpZGVyKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUga2V5IGZvciBwcm92aWRlciBpbnN0YW5jZXNcbiAgICovXG4gIGdldFByb3ZpZGVyS2V5KHR5cGUsIGVtYmVkZGVkV2FsbGV0VHlwZSkge1xuICAgIGlmICh0eXBlID09PSBcImluamVjdGVkXCIpIHtcbiAgICAgIHJldHVybiBcImluamVjdGVkXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVtYmVkZGVkXCIpIHtcbiAgICAgIHJldHVybiBgZW1iZWRkZWQtJHtlbWJlZGRlZFdhbGxldFR5cGUgfHwgXCJhcHAtd2FsbGV0XCJ9YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm92aWRlciB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmUgcHJvdmlkZXIgcHJlZmVyZW5jZSB0byBsb2NhbFN0b3JhZ2VcbiAgICovXG4gIHNhdmVQcm92aWRlclByZWZlcmVuY2UoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSB0aGlzLmdldEN1cnJlbnRQcm92aWRlckluZm8oKTtcbiAgICAgIGlmIChwcmVmZXJlbmNlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwicGhhbnRvbS1wcm92aWRlci1wcmVmZXJlbmNlXCIsIEpTT04uc3RyaW5naWZ5KHByZWZlcmVuY2UpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHByb3ZpZGVyIHByZWZlcmVuY2U6XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Ccm93c2VyU0RLLnRzXG5pbXBvcnQgeyBFTUJFRERFRF9QUk9WSURFUl9BVVRIX1RZUEVTIGFzIEVNQkVEREVEX1BST1ZJREVSX0FVVEhfVFlQRVMyIH0gZnJvbSBcIkBwaGFudG9tL2VtYmVkZGVkLXByb3ZpZGVyLWNvcmVcIjtcbmltcG9ydCB7IERFRkFVTFRfRU1CRURERURfV0FMTEVUX1RZUEUgYXMgREVGQVVMVF9FTUJFRERFRF9XQUxMRVRfVFlQRTIgfSBmcm9tIFwiQHBoYW50b20vY29uc3RhbnRzXCI7XG52YXIgQlJPV1NFUl9TREtfUFJPVklERVJfVFlQRVMgPSBbXG4gIC4uLkVNQkVEREVEX1BST1ZJREVSX0FVVEhfVFlQRVMyLFxuICBcImluamVjdGVkXCIsXG4gIFwiZGVlcGxpbmtcIlxuXTtcbnZhciBCcm93c2VyU0RLID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLndhbGxldFJlZ2lzdHJ5ID0gZ2V0V2FsbGV0UmVnaXN0cnkoKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkluaXRpYWxpemluZyBCcm93c2VyU0RLXCIsIHtcbiAgICAgIHByb3ZpZGVyczogY29uZmlnLnByb3ZpZGVycyxcbiAgICAgIGVtYmVkZGVkV2FsbGV0VHlwZTogY29uZmlnLmVtYmVkZGVkV2FsbGV0VHlwZSxcbiAgICAgIGFkZHJlc3NUeXBlczogY29uZmlnLmFkZHJlc3NUeXBlc1xuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWcucHJvdmlkZXJzKSB8fCBjb25maWcucHJvdmlkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJJbnZhbGlkIHByb3ZpZGVycyBhcnJheVwiLCB7IHByb3ZpZGVyczogY29uZmlnLnByb3ZpZGVycyB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByb3ZpZGVycyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IG9mIEF1dGhQcm92aWRlclR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWRQcm92aWRlcnMgPSBjb25maWcucHJvdmlkZXJzLmZpbHRlcigocCkgPT4gIUJST1dTRVJfU0RLX1BST1ZJREVSX1RZUEVTLmluY2x1ZGVzKHApKTtcbiAgICBpZiAoaW52YWxpZFByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkludmFsaWQgcHJvdmlkZXIgdHlwZXNcIiwge1xuICAgICAgICBpbnZhbGlkUHJvdmlkZXJzLFxuICAgICAgICB2YWxpZFByb3ZpZGVyczogQlJPV1NFUl9TREtfUFJPVklERVJfVFlQRVNcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBwcm92aWRlciB0eXBlKHMpOiAke2ludmFsaWRQcm92aWRlcnMuam9pbihcIiwgXCIpfS4gVmFsaWQgcHJvdmlkZXJzIGFyZTogJHtCUk9XU0VSX1NES19QUk9WSURFUl9UWVBFUy5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaGFzRW1iZWRkZWRQcm92aWRlcnMgPSBjb25maWcucHJvdmlkZXJzLnNvbWUoKHApID0+IHAgIT09IFwiaW5qZWN0ZWRcIik7XG4gICAgaWYgKGhhc0VtYmVkZGVkUHJvdmlkZXJzICYmICFjb25maWcuYXBwSWQpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiYXBwSWQgcmVxdWlyZWQgZm9yIGVtYmVkZGVkIHByb3ZpZGVyc1wiLCB7XG4gICAgICAgIHByb3ZpZGVyczogY29uZmlnLnByb3ZpZGVyc1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcHBJZCBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGVtYmVkZGVkIHByb3ZpZGVycyAoZ29vZ2xlLCBhcHBsZSwgcGhhbnRvbSwgZXRjLilcIik7XG4gICAgfVxuICAgIGNvbnN0IGVtYmVkZGVkV2FsbGV0VHlwZSA9IGNvbmZpZy5lbWJlZGRlZFdhbGxldFR5cGUgfHwgREVGQVVMVF9FTUJFRERFRF9XQUxMRVRfVFlQRTI7XG4gICAgaWYgKCFbXCJhcHAtd2FsbGV0XCIsIFwidXNlci13YWxsZXRcIl0uaW5jbHVkZXMoZW1iZWRkZWRXYWxsZXRUeXBlKSkge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJJbnZhbGlkIGVtYmVkZGVkV2FsbGV0VHlwZVwiLCB7XG4gICAgICAgIGVtYmVkZGVkV2FsbGV0VHlwZTogY29uZmlnLmVtYmVkZGVkV2FsbGV0VHlwZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGVtYmVkZGVkV2FsbGV0VHlwZTogJHtjb25maWcuZW1iZWRkZWRXYWxsZXRUeXBlfS4gTXVzdCBiZSBcImFwcC13YWxsZXRcIiBvciBcInVzZXItd2FsbGV0XCIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5wcm92aWRlck1hbmFnZXIgPSBuZXcgUHJvdmlkZXJNYW5hZ2VyKGNvbmZpZyk7XG4gICAgdm9pZCB0aGlzLmRpc2NvdmVyV2FsbGV0cygpO1xuICB9XG4gIGRpc2NvdmVyV2FsbGV0cygpIHtcbiAgICByZXR1cm4gdGhpcy53YWxsZXRSZWdpc3RyeS5kaXNjb3Zlcih0aGlzLmNvbmZpZy5hZGRyZXNzVHlwZXMpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICAvLyA9PT09PSBDSEFJTiBBUEkgPT09PT1cbiAgLyoqXG4gICAqIEFjY2VzcyBTb2xhbmEgY2hhaW4gb3BlcmF0aW9uc1xuICAgKi9cbiAgZ2V0IHNvbGFuYSgpIHtcbiAgICBjb25zdCBjdXJyZW50UHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyTWFuYWdlci5nZXRDdXJyZW50UHJvdmlkZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvdmlkZXIgYXZhaWxhYmxlLiBDYWxsIGNvbm5lY3QoKSBmaXJzdC5cIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50UHJvdmlkZXIuc29sYW5hO1xuICB9XG4gIC8qKlxuICAgKiBBY2Nlc3MgRXRoZXJldW0gY2hhaW4gb3BlcmF0aW9uc1xuICAgKi9cbiAgZ2V0IGV0aGVyZXVtKCkge1xuICAgIGNvbnN0IGN1cnJlbnRQcm92aWRlciA9IHRoaXMucHJvdmlkZXJNYW5hZ2VyLmdldEN1cnJlbnRQcm92aWRlcigpO1xuICAgIGlmICghY3VycmVudFByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBhdmFpbGFibGUuIENhbGwgY29ubmVjdCgpIGZpcnN0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRQcm92aWRlci5ldGhlcmV1bTtcbiAgfVxuICAvLyA9PT09PSBDT05ORUNUSU9OIE1BTkFHRU1FTlQgPT09PT1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChvcHRpb25zKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIlN0YXJ0aW5nIGNvbm5lY3Rpb25cIiwgb3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXJNYW5hZ2VyLmNvbm5lY3Qob3B0aW9ucyk7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQ29ubmVjdGlvbiBzdWNjZXNzZnVsXCIsIHtcbiAgICAgICAgYWRkcmVzc0NvdW50OiByZXN1bHQuYWRkcmVzc2VzLmxlbmd0aCxcbiAgICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQ29ubmVjdGlvbiBmYWlsZWRcIiwgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHRoZSB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkRpc2Nvbm5lY3RpbmdcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXJNYW5hZ2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJEaXNjb25uZWN0aW9uIHN1Y2Nlc3NmdWxcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiRGlzY29ubmVjdGlvbiBmYWlsZWRcIiwgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvLyA9PT09PSBTVEFURSBRVUVSSUVTID09PT09XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgU0RLIGlzIGNvbm5lY3RlZCB0byBhIHdhbGxldFxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJNYW5hZ2VyLmlzQ29ubmVjdGVkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgY29ubmVjdGVkIHdhbGxldCBhZGRyZXNzZXNcbiAgICovXG4gIGdldEFkZHJlc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck1hbmFnZXIuZ2V0QWRkcmVzc2VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBwcm92aWRlclxuICAgKi9cbiAgZ2V0Q3VycmVudFByb3ZpZGVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck1hbmFnZXIuZ2V0Q3VycmVudFByb3ZpZGVySW5mbygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZW5hYmxlZCBhZGRyZXNzIHR5cGVzIGZvciB0aGUgY3VycmVudCBwcm92aWRlclxuICAgKiAtIEZvciBlbWJlZGRlZCBwcm92aWRlcjogcmV0dXJucyBjb25maWcuYWRkcmVzc1R5cGVzXG4gICAqIC0gRm9yIFBoYW50b20gaW5qZWN0ZWQ6IHJldHVybnMgY29uZmlnLmFkZHJlc3NUeXBlc1xuICAgKiAtIEZvciBkaXNjb3ZlcmVkIHdhbGxldHM6IHJldHVybnMgdGhlIHdhbGxldCdzIGFkZHJlc3NUeXBlcyBmcm9tIHJlZ2lzdHJ5XG4gICAqL1xuICBnZXRFbmFibGVkQWRkcmVzc1R5cGVzKCkge1xuICAgIGNvbnN0IGN1cnJlbnRQcm92aWRlciA9IHRoaXMucHJvdmlkZXJNYW5hZ2VyLmdldEN1cnJlbnRQcm92aWRlcigpO1xuICAgIGlmICghY3VycmVudFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50UHJvdmlkZXIuZ2V0RW5hYmxlZEFkZHJlc3NUeXBlcygpO1xuICB9XG4gIC8vID09PT09IFVUSUxJVFkgTUVUSE9EUyA9PT09PVxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVyIGZvciBwcm92aWRlciBldmVudHMgKGNvbm5lY3QsIGNvbm5lY3Rfc3RhcnQsIGNvbm5lY3RfZXJyb3IsIGRpc2Nvbm5lY3QsIGVycm9yKVxuICAgKiBXb3JrcyB3aXRoIGJvdGggZW1iZWRkZWQgYW5kIGluamVjdGVkIHByb3ZpZGVyc1xuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQWRkaW5nIGV2ZW50IGxpc3RlbmVyXCIsIHsgZXZlbnQgfSk7XG4gICAgdGhpcy5wcm92aWRlck1hbmFnZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZvciBwcm92aWRlciBldmVudHNcbiAgICogV29ya3Mgd2l0aCBib3RoIGVtYmVkZGVkIGFuZCBpbmplY3RlZCBwcm92aWRlcnNcbiAgICovXG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJSZW1vdmluZyBldmVudCBsaXN0ZW5lclwiLCB7IGV2ZW50IH0pO1xuICAgIHRoaXMucHJvdmlkZXJNYW5hZ2VyLm9mZihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IGF1dG8tY29ubmVjdGlvbiB1c2luZyBleGlzdGluZyBzZXNzaW9uXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2V0dGluZyB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICogVHJpZXMgZW1iZWRkZWQgcHJvdmlkZXIgZmlyc3QsIHRoZW4gaW5qZWN0ZWQgcHJvdmlkZXIgYXMgZmFsbGJhY2tcbiAgICovXG4gIGFzeW5jIGF1dG9Db25uZWN0KCkge1xuICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkF0dGVtcHRpbmcgYXV0by1jb25uZWN0IHdpdGggZmFsbGJhY2sgc3RyYXRlZ3lcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlck1hbmFnZXIuYXV0b0Nvbm5lY3QoKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQXV0by1jb25uZWN0IHN1Y2Nlc3NmdWxcIiwge1xuICAgICAgICBwcm92aWRlclR5cGU6IHRoaXMuZ2V0Q3VycmVudFByb3ZpZGVySW5mbygpPy50eXBlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcubG9nKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiQXV0by1jb25uZWN0IGZhaWxlZCBmb3IgYWxsIHByb3ZpZGVyc1wiKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRGVidWcoKSB7XG4gICAgZGVidWcuZW5hYmxlKCk7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkRlYnVnIGxvZ2dpbmcgZW5hYmxlZFwiKTtcbiAgfVxuICBkaXNhYmxlRGVidWcoKSB7XG4gICAgZGVidWcuZGlzYWJsZSgpO1xuICB9XG4gIHNldERlYnVnTGV2ZWwobGV2ZWwpIHtcbiAgICBkZWJ1Zy5zZXRMZXZlbChsZXZlbCk7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkRlYnVnIGxldmVsIHVwZGF0ZWRcIiwgeyBsZXZlbCB9KTtcbiAgfVxuICBzZXREZWJ1Z0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgZGVidWcuc2V0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGRlYnVnLmluZm8oRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJEZWJ1ZyBjYWxsYmFjayB1cGRhdGVkXCIpO1xuICB9XG4gIGNvbmZpZ3VyZURlYnVnKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuZW5hYmxlZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoY29uZmlnLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbmFibGVEZWJ1ZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlRGVidWcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5sZXZlbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnNldERlYnVnTGV2ZWwoY29uZmlnLmxldmVsKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5jYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnNldERlYnVnQ2FsbGJhY2soY29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgLy8gPT09PT0gQVVUTy1DT05GSVJNIE1FVEhPRFMgKEluamVjdGVkIFByb3ZpZGVyIE9ubHkpID09PT09XG4gIC8qKlxuICAgKiBFbmFibGUgYXV0by1jb25maXJtIGZvciB0cmFuc2FjdGlvbnNcbiAgICogT25seSBhdmFpbGFibGUgZm9yIGluamVjdGVkIHByb3ZpZGVyc1xuICAgKi9cbiAgYXN5bmMgZW5hYmxlQXV0b0NvbmZpcm0ocGFyYW1zKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkVuYWJsaW5nIGF1dG8tY29uZmlybVwiLCB7IHBhcmFtcyB9KTtcbiAgICBjb25zdCBjdXJyZW50UHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyTWFuYWdlci5nZXRDdXJyZW50UHJvdmlkZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvdmlkZXIgYXZhaWxhYmxlLiBDYWxsIGNvbm5lY3QoKSBmaXJzdC5cIik7XG4gICAgfVxuICAgIGlmICghKFwiZW5hYmxlQXV0b0NvbmZpcm1cIiBpbiBjdXJyZW50UHJvdmlkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvLWNvbmZpcm0gaXMgb25seSBhdmFpbGFibGUgZm9yIGluamVjdGVkIHByb3ZpZGVyc1wiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJlbnRQcm92aWRlci5lbmFibGVBdXRvQ29uZmlybShwYXJhbXMpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkF1dG8tY29uZmlybSBlbmFibGVkIHN1Y2Nlc3NmdWxseVwiLCB7IHJlc3VsdCB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiRmFpbGVkIHRvIGVuYWJsZSBhdXRvLWNvbmZpcm1cIiwgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBhdXRvLWNvbmZpcm0gZm9yIHRyYW5zYWN0aW9uc1xuICAgKiBPbmx5IGF2YWlsYWJsZSBmb3IgaW5qZWN0ZWQgcHJvdmlkZXJzXG4gICAqL1xuICBhc3luYyBkaXNhYmxlQXV0b0NvbmZpcm0oKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkRpc2FibGluZyBhdXRvLWNvbmZpcm1cIik7XG4gICAgY29uc3QgY3VycmVudFByb3ZpZGVyID0gdGhpcy5wcm92aWRlck1hbmFnZXIuZ2V0Q3VycmVudFByb3ZpZGVyKCk7XG4gICAgaWYgKCFjdXJyZW50UHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb3ZpZGVyIGF2YWlsYWJsZS4gQ2FsbCBjb25uZWN0KCkgZmlyc3QuXCIpO1xuICAgIH1cbiAgICBpZiAoIShcImRpc2FibGVBdXRvQ29uZmlybVwiIGluIGN1cnJlbnRQcm92aWRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dG8tY29uZmlybSBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgaW5qZWN0ZWQgcHJvdmlkZXJzXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgY3VycmVudFByb3ZpZGVyLmRpc2FibGVBdXRvQ29uZmlybSgpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkF1dG8tY29uZmlybSBkaXNhYmxlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiRmFpbGVkIHRvIGRpc2FibGUgYXV0by1jb25maXJtXCIsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGF1dG8tY29uZmlybSBzdGF0dXNcbiAgICogT25seSBhdmFpbGFibGUgZm9yIGluamVjdGVkIHByb3ZpZGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0QXV0b0NvbmZpcm1TdGF0dXMoKSB7XG4gICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkdldHRpbmcgYXV0by1jb25maXJtIHN0YXR1c1wiKTtcbiAgICBjb25zdCBjdXJyZW50UHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyTWFuYWdlci5nZXRDdXJyZW50UHJvdmlkZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvdmlkZXIgYXZhaWxhYmxlLiBDYWxsIGNvbm5lY3QoKSBmaXJzdC5cIik7XG4gICAgfVxuICAgIGlmICghKFwiZ2V0QXV0b0NvbmZpcm1TdGF0dXNcIiBpbiBjdXJyZW50UHJvdmlkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvLWNvbmZpcm0gaXMgb25seSBhdmFpbGFibGUgZm9yIGluamVjdGVkIHByb3ZpZGVyc1wiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJlbnRQcm92aWRlci5nZXRBdXRvQ29uZmlybVN0YXR1cygpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkdvdCBhdXRvLWNvbmZpcm0gc3RhdHVzXCIsIHsgcmVzdWx0IH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcuZXJyb3IoRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJGYWlsZWQgdG8gZ2V0IGF1dG8tY29uZmlybSBzdGF0dXNcIiwgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHN1cHBvcnRlZCBjaGFpbnMgZm9yIGF1dG8tY29uZmlybVxuICAgKiBPbmx5IGF2YWlsYWJsZSBmb3IgaW5qZWN0ZWQgcHJvdmlkZXJzXG4gICAqL1xuICBhc3luYyBnZXRTdXBwb3J0ZWRBdXRvQ29uZmlybUNoYWlucygpIHtcbiAgICBkZWJ1Zy5pbmZvKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiR2V0dGluZyBzdXBwb3J0ZWQgYXV0by1jb25maXJtIGNoYWluc1wiKTtcbiAgICBjb25zdCBjdXJyZW50UHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyTWFuYWdlci5nZXRDdXJyZW50UHJvdmlkZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvdmlkZXIgYXZhaWxhYmxlLiBDYWxsIGNvbm5lY3QoKSBmaXJzdC5cIik7XG4gICAgfVxuICAgIGlmICghKFwiZ2V0U3VwcG9ydGVkQXV0b0NvbmZpcm1DaGFpbnNcIiBpbiBjdXJyZW50UHJvdmlkZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvLWNvbmZpcm0gaXMgb25seSBhdmFpbGFibGUgZm9yIGluamVjdGVkIHByb3ZpZGVyc1wiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGN1cnJlbnRQcm92aWRlci5nZXRTdXBwb3J0ZWRBdXRvQ29uZmlybUNoYWlucygpO1xuICAgICAgZGVidWcuaW5mbyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkdvdCBzdXBwb3J0ZWQgYXV0by1jb25maXJtIGNoYWluc1wiLCB7IHJlc3VsdCB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnLmVycm9yKERlYnVnQ2F0ZWdvcnkuQlJPV1NFUl9TREssIFwiRmFpbGVkIHRvIGdldCBzdXBwb3J0ZWQgYXV0by1jb25maXJtIGNoYWluc1wiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBnZXREaXNjb3ZlcmVkV2FsbGV0cygpIHtcbiAgICBkZWJ1Zy5sb2coRGVidWdDYXRlZ29yeS5CUk9XU0VSX1NESywgXCJHZXR0aW5nIGRpc2NvdmVyZWQgd2FsbGV0c1wiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsV2FsbGV0cyA9IHRoaXMud2FsbGV0UmVnaXN0cnkuZ2V0QnlBZGRyZXNzVHlwZXModGhpcy5jb25maWcuYWRkcmVzc1R5cGVzKTtcbiAgICAgIGRlYnVnLmxvZyhEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIlJldHJpZXZlZCBkaXNjb3ZlcmVkIHdhbGxldHNcIiwge1xuICAgICAgICBjb3VudDogYWxsV2FsbGV0cy5sZW5ndGgsXG4gICAgICAgIHdhbGxldElkczogYWxsV2FsbGV0cy5tYXAoKHcpID0+IHcuaWQpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxXYWxsZXRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1Zy5lcnJvcihEZWJ1Z0NhdGVnb3J5LkJST1dTRVJfU0RLLCBcIkZhaWxlZCB0byBnZXQgZGlzY292ZXJlZCB3YWxsZXRzXCIsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3dhaXRGb3JQaGFudG9tRXh0ZW5zaW9uLnRzXG5pbXBvcnQgeyBpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWQgYXMgaXNQaGFudG9tRXh0ZW5zaW9uSW5zdGFsbGVkNCB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLWluamVjdGVkLXNka1wiO1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclBoYW50b21FeHRlbnNpb24odGltZW91dE1zID0gM2UzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hlY2tJbnRlcnZhbCA9IDEwMDtcbiAgICBjb25zdCBjaGVja0ZvckV4dGVuc2lvbiA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc1BoYW50b21FeHRlbnNpb25JbnN0YWxsZWQ0KCkpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dE1zKSB7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGNoZWNrRm9yRXh0ZW5zaW9uLCBjaGVja0ludGVydmFsKTtcbiAgICB9O1xuICAgIGNoZWNrRm9yRXh0ZW5zaW9uKCk7XG4gIH0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IE5ldHdvcmtJZCB9IGZyb20gXCJAcGhhbnRvbS9jb25zdGFudHNcIjtcbmltcG9ydCB7IEFkZHJlc3NUeXBlIGFzIEFkZHJlc3NUeXBlMyB9IGZyb20gXCJAcGhhbnRvbS9jbGllbnRcIjtcbmV4cG9ydCB7XG4gIEFkZHJlc3NUeXBlMyBhcyBBZGRyZXNzVHlwZSxcbiAgQnJvd3NlclNESyxcbiAgRGVidWdDYXRlZ29yeSxcbiAgRGVidWdMZXZlbCxcbiAgTmV0d29ya0lkLFxuICBkZWJ1ZyxcbiAgZGV0ZWN0QnJvd3NlcixcbiAgZ2V0QnJvd3NlckRpc3BsYXlOYW1lLFxuICBnZXREZWVwbGlua1RvUGhhbnRvbSxcbiAgZ2V0UGxhdGZvcm1OYW1lLFxuICBpc01vYmlsZURldmljZSxcbiAgaXNQaGFudG9tTG9naW5BdmFpbGFibGUsXG4gIHBhcnNlQnJvd3NlckZyb21Vc2VyQWdlbnQsXG4gIHdhaXRGb3JQaGFudG9tRXh0ZW5zaW9uXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/browser-sdk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/client/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@phantom/client/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressType: () => (/* reexport safe */ _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoAddressFormatEnum),\n/* harmony export */   DerivationPath: () => (/* binding */ DerivationPath),\n/* harmony export */   NetworkId: () => (/* reexport safe */ _phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId),\n/* harmony export */   PhantomClient: () => (/* binding */ PhantomClient),\n/* harmony export */   SpendingLimitError: () => (/* binding */ SpendingLimitError),\n/* harmony export */   TransactionBlockedError: () => (/* binding */ TransactionBlockedError),\n/* harmony export */   WalletServiceError: () => (/* binding */ WalletServiceError),\n/* harmony export */   deriveSubmissionConfig: () => (/* binding */ deriveSubmissionConfig),\n/* harmony export */   generateKeyPair: () => (/* reexport safe */ _phantom_crypto__WEBPACK_IMPORTED_MODULE_19__.generateKeyPair),\n/* harmony export */   getAxiosErrorData: () => (/* binding */ getAxiosErrorData),\n/* harmony export */   getDerivationPathForNetwork: () => (/* binding */ getDerivationPathForNetwork),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getNetworkConfig: () => (/* binding */ getNetworkConfig),\n/* harmony export */   getNetworkDescription: () => (/* binding */ getNetworkDescription),\n/* harmony export */   getNetworkIdsByChain: () => (/* binding */ getNetworkIdsByChain),\n/* harmony export */   getSupportedNetworkIds: () => (/* binding */ getSupportedNetworkIds),\n/* harmony export */   parseWalletServiceError: () => (/* binding */ parseWalletServiceError),\n/* harmony export */   supportsTransactionSubmission: () => (/* binding */ supportsTransactionSubmission)\n/* harmony export */ });\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/configuration.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/api/kmsrpcapi.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-wallet.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/get-accounts.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-transaction.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-utf8-message.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/user-policy-one-of.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-organization.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-authenticator.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/delete-authenticator.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/grant-organization-access.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/add-user-to-organization.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/derivation-info.js\");\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/algorithm.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n/* harmony import */ var _phantom_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @phantom/utils */ \"(ssr)/./node_modules/@phantom/utils/dist/index.mjs\");\n/* harmony import */ var _phantom_crypto__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @phantom/crypto */ \"(ssr)/./node_modules/@phantom/crypto/dist/index.mjs\");\n// src/PhantomClient.ts\n\n\n\n\n// src/caip2-mappings.ts\n\nvar CAIP2_NETWORK_MAPPINGS = {\n  // Solana networks\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.SOLANA_MAINNET]: {\n    chain: \"solana\",\n    network: \"mainnet\",\n    description: \"Solana Mainnet-Beta\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.SOLANA_DEVNET]: {\n    chain: \"solana\",\n    network: \"devnet\",\n    description: \"Solana Devnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.SOLANA_TESTNET]: {\n    chain: \"solana\",\n    network: \"testnet\",\n    description: \"Solana Testnet\"\n  },\n  // Ethereum/EVM networks\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.ETHEREUM_MAINNET]: {\n    chain: \"ethereum\",\n    network: \"mainnet\",\n    description: \"Ethereum Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.ETHEREUM_SEPOLIA]: {\n    chain: \"ethereum\",\n    network: \"sepolia\",\n    description: \"Sepolia Testnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.POLYGON_MAINNET]: {\n    chain: \"polygon\",\n    network: \"mainnet\",\n    description: \"Polygon Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.POLYGON_AMOY]: {\n    chain: \"polygon\",\n    network: \"amoy\",\n    description: \"Polygon Amoy Testnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.BASE_MAINNET]: {\n    chain: \"base\",\n    network: \"mainnet\",\n    description: \"Base Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.BASE_SEPOLIA]: {\n    chain: \"base\",\n    network: \"sepolia\",\n    description: \"Base Sepolia Testnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.ARBITRUM_ONE]: {\n    chain: \"arbitrum\",\n    network: \"mainnet\",\n    description: \"Arbitrum One\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.ARBITRUM_SEPOLIA]: {\n    chain: \"arbitrum\",\n    network: \"sepolia\",\n    description: \"Arbitrum Sepolia Testnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.MONAD_MAINNET]: {\n    chain: \"monad\",\n    network: \"mainnet\",\n    description: \"Monad Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.MONAD_TESTNET]: {\n    chain: \"monad\",\n    network: \"testnet\",\n    description: \"Monad Testnet\"\n  },\n  // Bitcoin networks (for future support)\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.BITCOIN_MAINNET]: {\n    chain: \"bitcoin\",\n    network: \"mainnet\",\n    description: \"Bitcoin Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.BITCOIN_TESTNET]: {\n    chain: \"bitcoin\",\n    network: \"testnet\",\n    description: \"Bitcoin Testnet\"\n  },\n  // Sui networks (for future support)\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.SUI_MAINNET]: {\n    chain: \"sui\",\n    network: \"mainnet\",\n    description: \"Sui Mainnet\"\n  },\n  [_phantom_constants__WEBPACK_IMPORTED_MODULE_1__.NetworkId.SUI_TESTNET]: {\n    chain: \"sui\",\n    network: \"testnet\",\n    description: \"Sui Testnet\"\n  }\n};\nfunction deriveSubmissionConfig(networkId) {\n  const mapping = CAIP2_NETWORK_MAPPINGS[networkId];\n  if (!mapping) {\n    return void 0;\n  }\n  return {\n    chain: mapping.chain,\n    network: mapping.network\n  };\n}\nfunction supportsTransactionSubmission(networkId) {\n  return networkId in CAIP2_NETWORK_MAPPINGS;\n}\nfunction getNetworkDescription(networkId) {\n  return CAIP2_NETWORK_MAPPINGS[networkId]?.description;\n}\nfunction getSupportedNetworkIds() {\n  return Object.keys(CAIP2_NETWORK_MAPPINGS);\n}\nfunction getNetworkIdsByChain(chain) {\n  return Object.entries(CAIP2_NETWORK_MAPPINGS).filter(([_, mapping]) => mapping.chain.toLowerCase() === chain.toLowerCase()).map(([networkId]) => networkId);\n}\n\n// src/constants.ts\n\nvar DerivationPath = {\n  // Solana - BIP44 standard for Solana (coin type 501)\n  Solana: (accountIndex = 0) => `m/44'/501'/${accountIndex}'/0'`,\n  // Ethereum - BIP44 standard for Ethereum and all EVM-compatible chains (coin type 60)\n  Ethereum: (accountIndex = 0) => `m/44'/60'/0'/0/${accountIndex}`,\n  // Bitcoin - BIP84 standard for Bitcoin (coin type 0)\n  Bitcoin: (accountIndex = 0) => `m/84'/0'/${accountIndex}'/0`,\n  // Sui - BIP44 standard for Sui (coin type 784)\n  Sui: (accountIndex = 0) => `m/44'/784'/${accountIndex}'/0'/0'`\n};\nfunction getDerivationPathForNetwork(networkId, accountIndex = 0) {\n  const network = networkId.split(\":\")[0].toLowerCase();\n  switch (network) {\n    case \"solana\":\n      return DerivationPath.Solana(accountIndex);\n    case \"sui\":\n      return DerivationPath.Sui(accountIndex);\n    case \"bitcoin\":\n    case \"btc\":\n      return DerivationPath.Bitcoin(accountIndex);\n    case \"eip155\":\n    case \"ethereum\":\n    case \"eth\":\n    default:\n      return DerivationPath.Ethereum(accountIndex);\n  }\n}\nfunction getNetworkConfig(networkId, accountIndex = 0) {\n  const network = networkId.split(\":\")[0].toLowerCase();\n  switch (network) {\n    case \"solana\":\n      return {\n        derivationPath: DerivationPath.Solana(accountIndex),\n        curve: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoCurveEnum.ed25519,\n        algorithm: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_3__.Algorithm.ed25519,\n        addressFormat: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoAddressFormatEnum.solana\n      };\n    case \"sui\":\n      return {\n        derivationPath: DerivationPath.Sui(accountIndex),\n        curve: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoCurveEnum.ed25519,\n        algorithm: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_3__.Algorithm.ed25519,\n        addressFormat: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoAddressFormatEnum.sui\n      };\n    case \"bitcoin\":\n    case \"btc\":\n      return {\n        derivationPath: DerivationPath.Bitcoin(accountIndex),\n        curve: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoCurveEnum.secp256k1,\n        algorithm: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_3__.Algorithm.secp256k1,\n        addressFormat: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoAddressFormatEnum.bitcoinSegwit\n        // Bitcoin uses a different format, but for SDK consistency we use Ethereum format\n      };\n    case \"eip155\":\n      return {\n        derivationPath: DerivationPath.Ethereum(accountIndex),\n        curve: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoCurveEnum.secp256k1,\n        algorithm: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_3__.Algorithm.secp256k1,\n        addressFormat: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_2__.DerivationInfoAddressFormatEnum.ethereum\n        // EVM chains use Ethereum address format\n      };\n    default:\n      return null;\n  }\n}\n\n// src/errors.ts\n\nvar WalletServiceError = class extends Error {\n  constructor(data, errorName) {\n    super(data.detail);\n    this.name = errorName;\n    this.type = data.type;\n    this.title = data.title;\n    this.detail = data.detail;\n    this.requestId = data.requestId;\n  }\n};\nfunction getAxiosErrorData(error) {\n  if ((0,axios__WEBPACK_IMPORTED_MODULE_4__.isAxiosError)(error)) {\n    return error.response?.data;\n  }\n  return void 0;\n}\nfunction getErrorMessage(error, fallbackMessage = \"An error occurred\") {\n  if (error instanceof WalletServiceError) {\n    return error.detail || error.title || error.message || fallbackMessage;\n  }\n  const data = getAxiosErrorData(error);\n  if (data) {\n    return data.message || data.detail || data.title || fallbackMessage;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return fallbackMessage;\n}\nfunction parseWalletServiceError(data) {\n  if (!data || !data.type) {\n    return null;\n  }\n  switch (data.type) {\n    case \"spending-limit-exceeded\":\n      return new SpendingLimitError(data);\n    case \"transaction-blocked\":\n      return new TransactionBlockedError(data);\n    default:\n      return null;\n  }\n}\nvar SpendingLimitError = class extends WalletServiceError {\n  constructor(data) {\n    super(data, \"SpendingLimitError\");\n    this.previousSpendCents = data.previousSpendCents;\n    this.transactionSpendCents = data.transactionSpendCents;\n    this.totalSpendCents = data.totalSpendCents;\n    this.limitCents = data.limitCents;\n  }\n};\nvar TransactionBlockedError = class extends WalletServiceError {\n  constructor(data) {\n    super(data, \"TransactionBlockedError\");\n    this.scannerResult = data.scannerResult;\n  }\n};\n\n// src/PhantomClient.ts\n\nvar PhantomClient = class {\n  constructor(config, stamper) {\n    this.config = {\n      ...config,\n      walletType: config.walletType || \"user-wallet\"\n    };\n    this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create();\n    const customHeaders = {};\n    if (config.headers) {\n      Object.assign(customHeaders, config.headers);\n    }\n    if (Object.keys(customHeaders).length > 0) {\n      this.axiosInstance.interceptors.request.use((config2) => {\n        Object.assign(config2.headers, customHeaders);\n        return config2;\n      });\n    }\n    if (stamper) {\n      this.axiosInstance.interceptors.request.use(async (config2) => {\n        return await this.stampRequest(config2, stamper);\n      });\n      this.stamper = stamper;\n    }\n    const configuration = new _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_7__.Configuration({\n      basePath: config.apiBaseUrl\n    });\n    this.kmsApi = new _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_8__.KMSRPCApi(configuration, config.apiBaseUrl, this.axiosInstance);\n  }\n  setOrganizationId(organizationId) {\n    if (!organizationId) {\n      throw new Error(\"organizationId is required\");\n    }\n    this.config.organizationId = organizationId;\n  }\n  async createWallet(walletName) {\n    try {\n      if (!this.config.organizationId) {\n        throw new Error(\"organizationId is required to create a wallet\");\n      }\n      const timestamp = await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)();\n      const walletRequest = {\n        organizationId: this.config.organizationId,\n        walletName: walletName || `Wallet ${timestamp}`,\n        accounts: [\n          DerivationPath.Solana(),\n          DerivationPath.Ethereum(),\n          DerivationPath.Bitcoin(),\n          DerivationPath.Sui()\n        ]\n      };\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_9__.CreateWalletMethodEnum.createWallet,\n        params: walletRequest,\n        timestampMs: timestamp\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const walletResult = response.data.result;\n      const requestAccounts = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_10__.GetAccountsMethodEnum.getAccounts,\n        params: {\n          accounts: [\n            DerivationPath.Solana(),\n            DerivationPath.Ethereum(),\n            DerivationPath.Bitcoin(),\n            DerivationPath.Sui()\n          ],\n          organizationId: this.config.organizationId,\n          walletId: walletResult.walletId\n        },\n        timestampMs: timestamp\n      };\n      const accountsResponse = await this.kmsApi.postKmsRpc(requestAccounts);\n      const accountsResult = accountsResponse.data.result;\n      return {\n        walletId: walletResult.walletId,\n        addresses: accountsResult.map((account) => ({\n          addressType: account.addressFormat,\n          address: account.address\n        }))\n      };\n    } catch (error) {\n      console.error(\"Failed to create wallet:\", error.response?.data || error.message);\n      throw new Error(`Failed to create wallet: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  async prepare(transaction, organizationId, submissionConfig, account, methodName) {\n    try {\n      const request = {\n        transaction,\n        organizationId,\n        submissionConfig,\n        simulationConfig: { account }\n      };\n      const response = await this.axiosInstance.post(`${this.config.apiBaseUrl}/prepare`, request, {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"X-Rpc-Method\": methodName\n        }\n      });\n      return response.data;\n    } catch (error) {\n      const errorData = getAxiosErrorData(error);\n      const walletServiceError = parseWalletServiceError(errorData);\n      if (walletServiceError) {\n        throw walletServiceError;\n      }\n      const message = errorData?.detail || getErrorMessage(error, \"Failed to submit transaction\");\n      throw new Error(message);\n    }\n  }\n  async getTransactionForSigning(params) {\n    const { encodedTransaction, networkId, submissionConfig, account } = params;\n    const isEvmTransaction = (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.isEthereumChain)(networkId);\n    const isSolanaTransaction = (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.isSolanaChain)(networkId);\n    if (isEvmTransaction) {\n      return { kind: \"RLP_ENCODED\", bytes: encodedTransaction };\n    }\n    if (isSolanaTransaction && this.config.walletType === \"user-wallet\") {\n      if (!account) {\n        throw new Error(\"Account is required to simulate Solana transactions with spending limits\");\n      }\n      try {\n        const prepareResponse = await this.prepare(\n          encodedTransaction,\n          this.config.organizationId,\n          submissionConfig,\n          account,\n          params.methodName\n        );\n        return prepareResponse.transaction;\n      } catch (e) {\n        if (e instanceof WalletServiceError) {\n          throw e;\n        }\n        const errorMessage = e instanceof Error ? e.message : String(e);\n        throw new Error(errorMessage);\n      }\n    }\n    return encodedTransaction;\n  }\n  getRpcMethodName(networkId, includeSubmissionConfig) {\n    const isEvm = (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.isEthereumChain)(networkId);\n    if (isEvm) {\n      return includeSubmissionConfig ? \"eth_sendTransaction\" : \"eth_signTransaction\";\n    }\n    return includeSubmissionConfig ? \"signAndSendTransaction\" : \"signTransaction\";\n  }\n  /**\n   * Private method for shared signing logic\n   */\n  async performTransactionSigning(params, includeSubmissionConfig) {\n    const walletId = params.walletId;\n    const encodedTransaction = params.transaction;\n    const networkIdParam = params.networkId;\n    const derivationIndex = params.derivationIndex ?? 0;\n    const methodName = this.getRpcMethodName(networkIdParam, includeSubmissionConfig);\n    try {\n      if (!this.config.organizationId) {\n        throw new Error(\"organizationId is required to sign a transaction\");\n      }\n      const submissionConfig = deriveSubmissionConfig(networkIdParam);\n      if (!submissionConfig) {\n        throw new Error(`SubmissionConfig could not be derived for network ID: ${networkIdParam}`);\n      }\n      const networkConfig = getNetworkConfig(networkIdParam, derivationIndex);\n      if (!networkConfig) {\n        throw new Error(`Unsupported network ID: ${networkIdParam}`);\n      }\n      const derivationInfo = {\n        derivationPath: networkConfig.derivationPath,\n        curve: networkConfig.curve,\n        addressFormat: networkConfig.addressFormat\n      };\n      const transactionForSigning = await this.getTransactionForSigning({\n        encodedTransaction,\n        networkId: networkIdParam,\n        submissionConfig,\n        account: params.account,\n        methodName\n      });\n      const signRequest = {\n        organizationId: this.config.organizationId,\n        walletId,\n        transaction: transactionForSigning,\n        derivationInfo\n      };\n      if (includeSubmissionConfig) {\n        signRequest.submissionConfig = submissionConfig;\n      }\n      if (includeSubmissionConfig && params.account) {\n        signRequest.simulationConfig = {\n          account: params.account\n        };\n      }\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_11__.SignTransactionMethodEnum.signTransaction,\n        params: signRequest,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request, {\n        headers: {\n          \"X-Rpc-Method\": methodName\n        }\n      });\n      const result = response.data.result;\n      const rpcSubmissionResult = response.data[\"rpc_submission_result\"];\n      const hash = includeSubmissionConfig && rpcSubmissionResult ? rpcSubmissionResult.result : null;\n      return {\n        signedTransaction: result.transaction,\n        // Base64 encoded signed transaction\n        hash\n      };\n    } catch (error) {\n      const actionType = includeSubmissionConfig ? \"sign and send\" : \"sign\";\n      if (error instanceof WalletServiceError) {\n        throw error;\n      }\n      throw new Error(getErrorMessage(error, `Failed to ${actionType} transaction`));\n    }\n  }\n  /**\n   * Sign a transaction\n   */\n  async signTransaction(params) {\n    const result = await this.performTransactionSigning(params, false);\n    return {\n      rawTransaction: result.signedTransaction\n    };\n  }\n  /**\n   * Sign and send a transaction\n   */\n  async signAndSendTransaction(params) {\n    const result = await this.performTransactionSigning(params, true);\n    return {\n      rawTransaction: result.signedTransaction,\n      hash: result.hash\n    };\n  }\n  async getWalletAddresses(walletId, derivationPaths, derivationIndex) {\n    try {\n      const accountIndex = derivationIndex ?? 0;\n      const paths = derivationPaths || [\n        DerivationPath.Solana(accountIndex),\n        DerivationPath.Ethereum(accountIndex),\n        DerivationPath.Bitcoin(accountIndex),\n        DerivationPath.Sui(accountIndex)\n      ];\n      const requestAccounts = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_10__.GetAccountsMethodEnum.getAccounts,\n        params: {\n          accounts: paths,\n          organizationId: this.config.organizationId,\n          walletId\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const accountsResponse = await this.kmsApi.postKmsRpc(requestAccounts);\n      const accountsResult = accountsResponse.data.result;\n      const addresses = accountsResult.map((account) => ({\n        addressType: account.addressFormat,\n        address: account.address\n      }));\n      return addresses;\n    } catch (error) {\n      console.error(\"Failed to get wallet addresses:\", error.response?.data || error.message);\n      throw new Error(`Failed to get wallet addresses: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Sign an Ethereum message using EIP-191 personal sign\n   */\n  async ethereumSignMessage(params) {\n    const walletId = params.walletId;\n    const messageParam = params.message;\n    const networkIdParam = params.networkId;\n    const derivationIndex = params.derivationIndex ?? 0;\n    try {\n      if (!this.config.organizationId) {\n        throw new Error(\"organizationId is required to sign a message\");\n      }\n      const networkConfig = getNetworkConfig(networkIdParam, derivationIndex);\n      if (!networkConfig) {\n        throw new Error(`Unsupported network ID: ${networkIdParam}`);\n      }\n      const derivationInfo = {\n        derivationPath: networkConfig.derivationPath,\n        curve: networkConfig.curve,\n        addressFormat: networkConfig.addressFormat\n      };\n      const base64StringMessage = messageParam;\n      const request = {\n        method: \"ethereumSignMessage\",\n        params: {\n          message: base64StringMessage,\n          organizationId: this.config.organizationId,\n          walletId,\n          derivationInfo\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result.signature;\n    } catch (error) {\n      console.error(\"Failed to sign Ethereum message:\", error.response?.data || error.message);\n      throw new Error(`Failed to sign Ethereum message: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Sign a UTF-8 message for Solana\n   */\n  async signUtf8Message(params) {\n    const walletId = params.walletId;\n    const messageParam = params.message;\n    const networkIdParam = params.networkId;\n    const derivationIndex = params.derivationIndex ?? 0;\n    try {\n      if (!this.config.organizationId) {\n        throw new Error(\"organizationId is required to sign a message\");\n      }\n      const networkConfig = getNetworkConfig(networkIdParam, derivationIndex);\n      if (!networkConfig) {\n        throw new Error(`Unsupported network ID: ${networkIdParam}`);\n      }\n      const derivationInfo = {\n        derivationPath: networkConfig.derivationPath,\n        curve: networkConfig.curve,\n        addressFormat: networkConfig.addressFormat\n      };\n      const signRequest = {\n        organizationId: this.config.organizationId,\n        walletId,\n        message: messageParam,\n        algorithm: networkConfig.algorithm,\n        derivationInfo\n      };\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_12__.SignUTF8MessageMethodEnum.signUtf8Message,\n        params: signRequest,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result.signature;\n    } catch (error) {\n      console.error(\"Failed to sign raw payload:\", error.response?.data || error.message);\n      throw new Error(`Failed to sign raw payload: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Sign EIP-712 typed data for Ethereum\n   */\n  async ethereumSignTypedData(params) {\n    const walletId = params.walletId;\n    const typedData = params.typedData;\n    const networkIdParam = params.networkId;\n    const derivationIndex = params.derivationIndex ?? 0;\n    try {\n      if (!this.config.organizationId) {\n        throw new Error(\"organizationId is required to sign typed data\");\n      }\n      const networkConfig = getNetworkConfig(networkIdParam, derivationIndex);\n      if (!networkConfig) {\n        throw new Error(`Unsupported network ID: ${networkIdParam}`);\n      }\n      const derivationInfo = {\n        derivationPath: networkConfig.derivationPath,\n        curve: networkConfig.curve,\n        addressFormat: networkConfig.addressFormat\n      };\n      const request = {\n        method: \"ethereumSignTypedData\",\n        params: {\n          typedData,\n          organizationId: this.config.organizationId,\n          walletId,\n          derivationInfo\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result.signature;\n    } catch (error) {\n      console.error(\"Failed to sign typed data:\", error.response?.data || error.message);\n      throw new Error(`Failed to sign typed data: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  async getWallets(limit, offset) {\n    try {\n      const request = {\n        method: \"getOrganizationWallets\",\n        params: {\n          organizationId: this.config.organizationId,\n          limit: limit || 20,\n          offset: offset || 0\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return {\n        wallets: result.wallets.map((wallet) => ({\n          walletId: wallet.walletId,\n          walletName: wallet.walletName\n        })),\n        totalCount: result.totalCount,\n        limit: result.limit,\n        offset: result.offset\n      };\n    } catch (error) {\n      console.error(\"Failed to get wallets:\", error.response?.data || error.message);\n      throw new Error(`Failed to get wallets: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Get organization details by organization ID\n   */\n  async getOrganization(organizationId) {\n    try {\n      const request = {\n        method: \"getOrganization\",\n        params: {\n          organizationId\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to get organization:\", error.response?.data || error.message);\n      throw new Error(`Failed to get organization: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Create a new organization with the specified name and users\n   * @param name Organization name\n   * @param users Array of users with their authenticators\n   */\n  validateNameLength(name, type) {\n    const MAX_NAME_LENGTH = 64;\n    if (name.length > MAX_NAME_LENGTH) {\n      throw new Error(`${type} name cannot exceed ${MAX_NAME_LENGTH} characters. Current length: ${name.length}`);\n    }\n  }\n  async createOrganization(name, users, tags) {\n    try {\n      if (!name) {\n        throw new Error(\"Organization name is required\");\n      }\n      this.validateNameLength(name, \"Organization\");\n      if (!users || users.length === 0) {\n        throw new Error(\"At least one user is required\");\n      }\n      for (const user of users) {\n        if (user.username) {\n          this.validateNameLength(user.username, \"Username\");\n        }\n        for (const auth of user.authenticators) {\n          if (auth.authenticatorName) {\n            this.validateNameLength(auth.authenticatorName, \"Authenticator\");\n          }\n        }\n      }\n      const params = {\n        organizationName: name,\n        users: users.map((userConfig) => ({\n          username: userConfig.username || `user-${(0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.randomUUID)()}`,\n          authenticators: userConfig.authenticators,\n          policy: userConfig.role === \"ADMIN\" ? {\n            type: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_13__.UserPolicyOneOfTypeEnum.root\n          } : { type: \"CEL\", preset: \"LEGACY_USER_ROLE\" }\n        })),\n        tags\n      };\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_14__.CreateOrganizationMethodEnum.createOrganization,\n        params,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to create organization:\", error.response?.data || error.message);\n      throw new Error(`Failed to create organization: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Create an authenticator for a user in an organization\n   */\n  async createAuthenticator(params) {\n    try {\n      if (params.username) {\n        this.validateNameLength(params.username, \"Username\");\n      }\n      if (params.authenticatorName) {\n        this.validateNameLength(params.authenticatorName, \"Authenticator\");\n      }\n      if (params.authenticator?.authenticatorName) {\n        this.validateNameLength(params.authenticator.authenticatorName, \"Authenticator\");\n      }\n      const requestParams = {\n        organizationId: params.organizationId,\n        username: params.username,\n        authenticatorName: params.authenticatorName,\n        authenticator: params.authenticator,\n        replaceExpirable: params.replaceExpirable\n      };\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_15__.CreateAuthenticatorMethodEnum.createAuthenticator,\n        params: requestParams,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to create authenticator:\", error.response?.data || error.message);\n      throw new Error(`Failed to create authenticator: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Delete an authenticator for a user in an organization\n   */\n  async deleteAuthenticator(params) {\n    try {\n      const requestParams = {\n        organizationId: params.organizationId,\n        username: params.username,\n        authenticatorId: params.authenticatorId\n      };\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_16__.DeleteAuthenticatorMethodEnum.deleteAuthenticator,\n        params: requestParams,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to delete authenticator:\", error.response?.data || error.message);\n      throw new Error(`Failed to delete authenticator: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  async grantOrganizationAccess(params) {\n    try {\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_17__.GrantOrganizationAccessMethodEnum.grantOrganizationAccess,\n        params,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to grant organization access:\", error.response?.data || error.message);\n      throw new Error(`Failed to grant organization access: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Add a new user to an organization\n   */\n  async addUserToOrganization(params) {\n    try {\n      const request = {\n        method: _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_18__.AddUserToOrganizationMethodEnum.addUserToOrganization,\n        params,\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      await this.kmsApi.postKmsRpc(request);\n    } catch (error) {\n      console.error(\"Failed to add user to organization:\", error.response?.data || error.message);\n      throw new Error(`Failed to add user to organization: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Get a wallet by tag from the specified organization\n   */\n  async getWalletWithTag(params) {\n    try {\n      const request = {\n        method: \"getWalletWithTag\",\n        params: {\n          organizationId: params.organizationId,\n          tag: params.tag,\n          derivationPaths: params.derivationPaths\n        },\n        timestampMs: await (0,_phantom_utils__WEBPACK_IMPORTED_MODULE_5__.getSecureTimestamp)()\n      };\n      const response = await this.kmsApi.postKmsRpc(request);\n      const result = response.data.result;\n      return result;\n    } catch (error) {\n      console.error(\"Failed to get wallet with tag:\", error.response?.data || error.message);\n      throw new Error(`Failed to get wallet with tag: ${error.response?.data?.message || error.message}`);\n    }\n  }\n  /**\n   * Stamp an axios request with the provided stamper\n   */\n  async stampRequest(config, stamper) {\n    const requestBody = typeof config.data === \"string\" ? config.data : config.data === void 0 ? \"\" : JSON.stringify(config.data);\n    const dataUtf8 = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(requestBody, \"utf8\");\n    const stamp = await stamper.stamp({\n      data: dataUtf8\n    });\n    config.headers = config.headers || {};\n    config.headers[\"X-Phantom-Stamp\"] = stamp;\n    return config;\n  }\n};\n\n// src/index.ts\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vY2xpZW50L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFjeUM7QUFDZjtBQUNNOztBQUVoQztBQUMrQztBQUMvQztBQUNBO0FBQ0EsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcseURBQVM7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcseURBQVM7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcseURBQVM7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcseURBQVM7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyx5REFBUztBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHLHlEQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUM3QztBQUNBLDJCQUEyQixrRUFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5REFBeUQsK0NBQStDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0ZBQWlDO0FBQ2pEO0FBQ0EsMkJBQTJCLGtFQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhEQUE4RCwrQ0FBK0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RkFBK0I7QUFDL0M7QUFDQSwyQkFBMkIsa0VBQWtCO0FBQzdDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2REFBNkQsK0NBQStDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQixrRUFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3REFBd0QsK0NBQStDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFNO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrRDtBQUNXO0FBR3BCO0FBb0J2QyIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vY2xpZW50L2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9QaGFudG9tQ2xpZW50LnRzXG5pbXBvcnQge1xuICBBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtLFxuICBDb25maWd1cmF0aW9uLFxuICBDcmVhdGVBdXRoZW50aWNhdG9yTWV0aG9kRW51bSxcbiAgQ3JlYXRlT3JnYW5pemF0aW9uTWV0aG9kRW51bSxcbiAgQ3JlYXRlV2FsbGV0TWV0aG9kRW51bSxcbiAgRGVsZXRlQXV0aGVudGljYXRvck1ldGhvZEVudW0sXG4gIEdldEFjY291bnRzTWV0aG9kRW51bSxcbiAgR3JhbnRPcmdhbml6YXRpb25BY2Nlc3NNZXRob2RFbnVtLFxuICBLTVNSUENBcGksXG4gIFNpZ25UcmFuc2FjdGlvbk1ldGhvZEVudW0sXG4gIFNpZ25VVEY4TWVzc2FnZU1ldGhvZEVudW0sXG4gIFVzZXJQb2xpY3lPbmVPZlR5cGVFbnVtXG59IGZyb20gXCJAcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5cbi8vIHNyYy9jYWlwMi1tYXBwaW5ncy50c1xuaW1wb3J0IHsgTmV0d29ya0lkIH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xudmFyIENBSVAyX05FVFdPUktfTUFQUElOR1MgPSB7XG4gIC8vIFNvbGFuYSBuZXR3b3Jrc1xuICBbTmV0d29ya0lkLlNPTEFOQV9NQUlOTkVUXToge1xuICAgIGNoYWluOiBcInNvbGFuYVwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlNvbGFuYSBNYWlubmV0LUJldGFcIlxuICB9LFxuICBbTmV0d29ya0lkLlNPTEFOQV9ERVZORVRdOiB7XG4gICAgY2hhaW46IFwic29sYW5hXCIsXG4gICAgbmV0d29yazogXCJkZXZuZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTb2xhbmEgRGV2bmV0XCJcbiAgfSxcbiAgW05ldHdvcmtJZC5TT0xBTkFfVEVTVE5FVF06IHtcbiAgICBjaGFpbjogXCJzb2xhbmFcIixcbiAgICBuZXR3b3JrOiBcInRlc3RuZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTb2xhbmEgVGVzdG5ldFwiXG4gIH0sXG4gIC8vIEV0aGVyZXVtL0VWTSBuZXR3b3Jrc1xuICBbTmV0d29ya0lkLkVUSEVSRVVNX01BSU5ORVRdOiB7XG4gICAgY2hhaW46IFwiZXRoZXJldW1cIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJFdGhlcmV1bSBNYWlubmV0XCJcbiAgfSxcbiAgW05ldHdvcmtJZC5FVEhFUkVVTV9TRVBPTElBXToge1xuICAgIGNoYWluOiBcImV0aGVyZXVtXCIsXG4gICAgbmV0d29yazogXCJzZXBvbGlhXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU2Vwb2xpYSBUZXN0bmV0XCJcbiAgfSxcbiAgW05ldHdvcmtJZC5QT0xZR09OX01BSU5ORVRdOiB7XG4gICAgY2hhaW46IFwicG9seWdvblwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlBvbHlnb24gTWFpbm5ldFwiXG4gIH0sXG4gIFtOZXR3b3JrSWQuUE9MWUdPTl9BTU9ZXToge1xuICAgIGNoYWluOiBcInBvbHlnb25cIixcbiAgICBuZXR3b3JrOiBcImFtb3lcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQb2x5Z29uIEFtb3kgVGVzdG5ldFwiXG4gIH0sXG4gIFtOZXR3b3JrSWQuQkFTRV9NQUlOTkVUXToge1xuICAgIGNoYWluOiBcImJhc2VcIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCYXNlIE1haW5uZXRcIlxuICB9LFxuICBbTmV0d29ya0lkLkJBU0VfU0VQT0xJQV06IHtcbiAgICBjaGFpbjogXCJiYXNlXCIsXG4gICAgbmV0d29yazogXCJzZXBvbGlhXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmFzZSBTZXBvbGlhIFRlc3RuZXRcIlxuICB9LFxuICBbTmV0d29ya0lkLkFSQklUUlVNX09ORV06IHtcbiAgICBjaGFpbjogXCJhcmJpdHJ1bVwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFyYml0cnVtIE9uZVwiXG4gIH0sXG4gIFtOZXR3b3JrSWQuQVJCSVRSVU1fU0VQT0xJQV06IHtcbiAgICBjaGFpbjogXCJhcmJpdHJ1bVwiLFxuICAgIG5ldHdvcms6IFwic2Vwb2xpYVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFyYml0cnVtIFNlcG9saWEgVGVzdG5ldFwiXG4gIH0sXG4gIFtOZXR3b3JrSWQuTU9OQURfTUFJTk5FVF06IHtcbiAgICBjaGFpbjogXCJtb25hZFwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1vbmFkIE1haW5uZXRcIlxuICB9LFxuICBbTmV0d29ya0lkLk1PTkFEX1RFU1RORVRdOiB7XG4gICAgY2hhaW46IFwibW9uYWRcIixcbiAgICBuZXR3b3JrOiBcInRlc3RuZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJNb25hZCBUZXN0bmV0XCJcbiAgfSxcbiAgLy8gQml0Y29pbiBuZXR3b3JrcyAoZm9yIGZ1dHVyZSBzdXBwb3J0KVxuICBbTmV0d29ya0lkLkJJVENPSU5fTUFJTk5FVF06IHtcbiAgICBjaGFpbjogXCJiaXRjb2luXCIsXG4gICAgbmV0d29yazogXCJtYWlubmV0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQml0Y29pbiBNYWlubmV0XCJcbiAgfSxcbiAgW05ldHdvcmtJZC5CSVRDT0lOX1RFU1RORVRdOiB7XG4gICAgY2hhaW46IFwiYml0Y29pblwiLFxuICAgIG5ldHdvcms6IFwidGVzdG5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJpdGNvaW4gVGVzdG5ldFwiXG4gIH0sXG4gIC8vIFN1aSBuZXR3b3JrcyAoZm9yIGZ1dHVyZSBzdXBwb3J0KVxuICBbTmV0d29ya0lkLlNVSV9NQUlOTkVUXToge1xuICAgIGNoYWluOiBcInN1aVwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN1aSBNYWlubmV0XCJcbiAgfSxcbiAgW05ldHdvcmtJZC5TVUlfVEVTVE5FVF06IHtcbiAgICBjaGFpbjogXCJzdWlcIixcbiAgICBuZXR3b3JrOiBcInRlc3RuZXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTdWkgVGVzdG5ldFwiXG4gIH1cbn07XG5mdW5jdGlvbiBkZXJpdmVTdWJtaXNzaW9uQ29uZmlnKG5ldHdvcmtJZCkge1xuICBjb25zdCBtYXBwaW5nID0gQ0FJUDJfTkVUV09SS19NQVBQSU5HU1tuZXR3b3JrSWRdO1xuICBpZiAoIW1hcHBpbmcpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2hhaW46IG1hcHBpbmcuY2hhaW4sXG4gICAgbmV0d29yazogbWFwcGluZy5uZXR3b3JrXG4gIH07XG59XG5mdW5jdGlvbiBzdXBwb3J0c1RyYW5zYWN0aW9uU3VibWlzc2lvbihuZXR3b3JrSWQpIHtcbiAgcmV0dXJuIG5ldHdvcmtJZCBpbiBDQUlQMl9ORVRXT1JLX01BUFBJTkdTO1xufVxuZnVuY3Rpb24gZ2V0TmV0d29ya0Rlc2NyaXB0aW9uKG5ldHdvcmtJZCkge1xuICByZXR1cm4gQ0FJUDJfTkVUV09SS19NQVBQSU5HU1tuZXR3b3JrSWRdPy5kZXNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZE5ldHdvcmtJZHMoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhDQUlQMl9ORVRXT1JLX01BUFBJTkdTKTtcbn1cbmZ1bmN0aW9uIGdldE5ldHdvcmtJZHNCeUNoYWluKGNoYWluKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhDQUlQMl9ORVRXT1JLX01BUFBJTkdTKS5maWx0ZXIoKFtfLCBtYXBwaW5nXSkgPT4gbWFwcGluZy5jaGFpbi50b0xvd2VyQ2FzZSgpID09PSBjaGFpbi50b0xvd2VyQ2FzZSgpKS5tYXAoKFtuZXR3b3JrSWRdKSA9PiBuZXR3b3JrSWQpO1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG5pbXBvcnQgeyBEZXJpdmF0aW9uSW5mb0N1cnZlRW51bSwgRGVyaXZhdGlvbkluZm9BZGRyZXNzRm9ybWF0RW51bSwgQWxnb3JpdGhtIH0gZnJvbSBcIkBwaGFudG9tL29wZW5hcGktd2FsbGV0LXNlcnZpY2VcIjtcbnZhciBEZXJpdmF0aW9uUGF0aCA9IHtcbiAgLy8gU29sYW5hIC0gQklQNDQgc3RhbmRhcmQgZm9yIFNvbGFuYSAoY29pbiB0eXBlIDUwMSlcbiAgU29sYW5hOiAoYWNjb3VudEluZGV4ID0gMCkgPT4gYG0vNDQnLzUwMScvJHthY2NvdW50SW5kZXh9Jy8wJ2AsXG4gIC8vIEV0aGVyZXVtIC0gQklQNDQgc3RhbmRhcmQgZm9yIEV0aGVyZXVtIGFuZCBhbGwgRVZNLWNvbXBhdGlibGUgY2hhaW5zIChjb2luIHR5cGUgNjApXG4gIEV0aGVyZXVtOiAoYWNjb3VudEluZGV4ID0gMCkgPT4gYG0vNDQnLzYwJy8wJy8wLyR7YWNjb3VudEluZGV4fWAsXG4gIC8vIEJpdGNvaW4gLSBCSVA4NCBzdGFuZGFyZCBmb3IgQml0Y29pbiAoY29pbiB0eXBlIDApXG4gIEJpdGNvaW46IChhY2NvdW50SW5kZXggPSAwKSA9PiBgbS84NCcvMCcvJHthY2NvdW50SW5kZXh9Jy8wYCxcbiAgLy8gU3VpIC0gQklQNDQgc3RhbmRhcmQgZm9yIFN1aSAoY29pbiB0eXBlIDc4NClcbiAgU3VpOiAoYWNjb3VudEluZGV4ID0gMCkgPT4gYG0vNDQnLzc4NCcvJHthY2NvdW50SW5kZXh9Jy8wJy8wJ2Bcbn07XG5mdW5jdGlvbiBnZXREZXJpdmF0aW9uUGF0aEZvck5ldHdvcmsobmV0d29ya0lkLCBhY2NvdW50SW5kZXggPSAwKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrSWQuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAobmV0d29yaykge1xuICAgIGNhc2UgXCJzb2xhbmFcIjpcbiAgICAgIHJldHVybiBEZXJpdmF0aW9uUGF0aC5Tb2xhbmEoYWNjb3VudEluZGV4KTtcbiAgICBjYXNlIFwic3VpXCI6XG4gICAgICByZXR1cm4gRGVyaXZhdGlvblBhdGguU3VpKGFjY291bnRJbmRleCk7XG4gICAgY2FzZSBcImJpdGNvaW5cIjpcbiAgICBjYXNlIFwiYnRjXCI6XG4gICAgICByZXR1cm4gRGVyaXZhdGlvblBhdGguQml0Y29pbihhY2NvdW50SW5kZXgpO1xuICAgIGNhc2UgXCJlaXAxNTVcIjpcbiAgICBjYXNlIFwiZXRoZXJldW1cIjpcbiAgICBjYXNlIFwiZXRoXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZXJpdmF0aW9uUGF0aC5FdGhlcmV1bShhY2NvdW50SW5kZXgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmtJZCwgYWNjb3VudEluZGV4ID0gMCkge1xuICBjb25zdCBuZXR3b3JrID0gbmV0d29ya0lkLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKG5ldHdvcmspIHtcbiAgICBjYXNlIFwic29sYW5hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogRGVyaXZhdGlvblBhdGguU29sYW5hKGFjY291bnRJbmRleCksXG4gICAgICAgIGN1cnZlOiBEZXJpdmF0aW9uSW5mb0N1cnZlRW51bS5lZDI1NTE5LFxuICAgICAgICBhbGdvcml0aG06IEFsZ29yaXRobS5lZDI1NTE5LFxuICAgICAgICBhZGRyZXNzRm9ybWF0OiBEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtLnNvbGFuYVxuICAgICAgfTtcbiAgICBjYXNlIFwic3VpXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogRGVyaXZhdGlvblBhdGguU3VpKGFjY291bnRJbmRleCksXG4gICAgICAgIGN1cnZlOiBEZXJpdmF0aW9uSW5mb0N1cnZlRW51bS5lZDI1NTE5LFxuICAgICAgICBhbGdvcml0aG06IEFsZ29yaXRobS5lZDI1NTE5LFxuICAgICAgICBhZGRyZXNzRm9ybWF0OiBEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtLnN1aVxuICAgICAgfTtcbiAgICBjYXNlIFwiYml0Y29pblwiOlxuICAgIGNhc2UgXCJidGNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlcml2YXRpb25QYXRoOiBEZXJpdmF0aW9uUGF0aC5CaXRjb2luKGFjY291bnRJbmRleCksXG4gICAgICAgIGN1cnZlOiBEZXJpdmF0aW9uSW5mb0N1cnZlRW51bS5zZWNwMjU2azEsXG4gICAgICAgIGFsZ29yaXRobTogQWxnb3JpdGhtLnNlY3AyNTZrMSxcbiAgICAgICAgYWRkcmVzc0Zvcm1hdDogRGVyaXZhdGlvbkluZm9BZGRyZXNzRm9ybWF0RW51bS5iaXRjb2luU2Vnd2l0XG4gICAgICAgIC8vIEJpdGNvaW4gdXNlcyBhIGRpZmZlcmVudCBmb3JtYXQsIGJ1dCBmb3IgU0RLIGNvbnNpc3RlbmN5IHdlIHVzZSBFdGhlcmV1bSBmb3JtYXRcbiAgICAgIH07XG4gICAgY2FzZSBcImVpcDE1NVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVyaXZhdGlvblBhdGg6IERlcml2YXRpb25QYXRoLkV0aGVyZXVtKGFjY291bnRJbmRleCksXG4gICAgICAgIGN1cnZlOiBEZXJpdmF0aW9uSW5mb0N1cnZlRW51bS5zZWNwMjU2azEsXG4gICAgICAgIGFsZ29yaXRobTogQWxnb3JpdGhtLnNlY3AyNTZrMSxcbiAgICAgICAgYWRkcmVzc0Zvcm1hdDogRGVyaXZhdGlvbkluZm9BZGRyZXNzRm9ybWF0RW51bS5ldGhlcmV1bVxuICAgICAgICAvLyBFVk0gY2hhaW5zIHVzZSBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gc3JjL2Vycm9ycy50c1xuaW1wb3J0IHsgaXNBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG52YXIgV2FsbGV0U2VydmljZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGVycm9yTmFtZSkge1xuICAgIHN1cGVyKGRhdGEuZGV0YWlsKTtcbiAgICB0aGlzLm5hbWUgPSBlcnJvck5hbWU7XG4gICAgdGhpcy50eXBlID0gZGF0YS50eXBlO1xuICAgIHRoaXMudGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgIHRoaXMuZGV0YWlsID0gZGF0YS5kZXRhaWw7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBkYXRhLnJlcXVlc3RJZDtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldEF4aW9zRXJyb3JEYXRhKGVycm9yKSB7XG4gIGlmIChpc0F4aW9zRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLnJlc3BvbnNlPy5kYXRhO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IsIGZhbGxiYWNrTWVzc2FnZSA9IFwiQW4gZXJyb3Igb2NjdXJyZWRcIikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRTZXJ2aWNlRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuZGV0YWlsIHx8IGVycm9yLnRpdGxlIHx8IGVycm9yLm1lc3NhZ2UgfHwgZmFsbGJhY2tNZXNzYWdlO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBnZXRBeGlvc0Vycm9yRGF0YShlcnJvcik7XG4gIGlmIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEubWVzc2FnZSB8fCBkYXRhLmRldGFpbCB8fCBkYXRhLnRpdGxlIHx8IGZhbGxiYWNrTWVzc2FnZTtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5mdW5jdGlvbiBwYXJzZVdhbGxldFNlcnZpY2VFcnJvcihkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhZGF0YS50eXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICBjYXNlIFwic3BlbmRpbmctbGltaXQtZXhjZWVkZWRcIjpcbiAgICAgIHJldHVybiBuZXcgU3BlbmRpbmdMaW1pdEVycm9yKGRhdGEpO1xuICAgIGNhc2UgXCJ0cmFuc2FjdGlvbi1ibG9ja2VkXCI6XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQmxvY2tlZEVycm9yKGRhdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxudmFyIFNwZW5kaW5nTGltaXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgV2FsbGV0U2VydmljZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEsIFwiU3BlbmRpbmdMaW1pdEVycm9yXCIpO1xuICAgIHRoaXMucHJldmlvdXNTcGVuZENlbnRzID0gZGF0YS5wcmV2aW91c1NwZW5kQ2VudHM7XG4gICAgdGhpcy50cmFuc2FjdGlvblNwZW5kQ2VudHMgPSBkYXRhLnRyYW5zYWN0aW9uU3BlbmRDZW50cztcbiAgICB0aGlzLnRvdGFsU3BlbmRDZW50cyA9IGRhdGEudG90YWxTcGVuZENlbnRzO1xuICAgIHRoaXMubGltaXRDZW50cyA9IGRhdGEubGltaXRDZW50cztcbiAgfVxufTtcbnZhciBUcmFuc2FjdGlvbkJsb2NrZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgV2FsbGV0U2VydmljZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKGRhdGEsIFwiVHJhbnNhY3Rpb25CbG9ja2VkRXJyb3JcIik7XG4gICAgdGhpcy5zY2FubmVyUmVzdWx0ID0gZGF0YS5zY2FubmVyUmVzdWx0O1xuICB9XG59O1xuXG4vLyBzcmMvUGhhbnRvbUNsaWVudC50c1xuaW1wb3J0IHsgZ2V0U2VjdXJlVGltZXN0YW1wLCByYW5kb21VVUlELCBpc0V0aGVyZXVtQ2hhaW4sIGlzU29sYW5hQ2hhaW4gfSBmcm9tIFwiQHBoYW50b20vdXRpbHNcIjtcbnZhciBQaGFudG9tQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YW1wZXIpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIHdhbGxldFR5cGU6IGNvbmZpZy53YWxsZXRUeXBlIHx8IFwidXNlci13YWxsZXRcIlxuICAgIH07XG4gICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3MuY3JlYXRlKCk7XG4gICAgY29uc3QgY3VzdG9tSGVhZGVycyA9IHt9O1xuICAgIGlmIChjb25maWcuaGVhZGVycykge1xuICAgICAgT2JqZWN0LmFzc2lnbihjdXN0b21IZWFkZXJzLCBjb25maWcuaGVhZGVycyk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhjdXN0b21IZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKChjb25maWcyKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnMi5oZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZzI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YW1wZXIpIHtcbiAgICAgIHRoaXMuYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoYXN5bmMgKGNvbmZpZzIpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RhbXBSZXF1ZXN0KGNvbmZpZzIsIHN0YW1wZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YW1wZXIgPSBzdGFtcGVyO1xuICAgIH1cbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oe1xuICAgICAgYmFzZVBhdGg6IGNvbmZpZy5hcGlCYXNlVXJsXG4gICAgfSk7XG4gICAgdGhpcy5rbXNBcGkgPSBuZXcgS01TUlBDQXBpKGNvbmZpZ3VyYXRpb24sIGNvbmZpZy5hcGlCYXNlVXJsLCB0aGlzLmF4aW9zSW5zdGFuY2UpO1xuICB9XG4gIHNldE9yZ2FuaXphdGlvbklkKG9yZ2FuaXphdGlvbklkKSB7XG4gICAgaWYgKCFvcmdhbml6YXRpb25JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3JnYW5pemF0aW9uSWQgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLm9yZ2FuaXphdGlvbklkID0gb3JnYW5pemF0aW9uSWQ7XG4gIH1cbiAgYXN5bmMgY3JlYXRlV2FsbGV0KHdhbGxldE5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcmdhbml6YXRpb25JZCBpcyByZXF1aXJlZCB0byBjcmVhdGUgYSB3YWxsZXRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBhd2FpdCBnZXRTZWN1cmVUaW1lc3RhbXAoKTtcbiAgICAgIGNvbnN0IHdhbGxldFJlcXVlc3QgPSB7XG4gICAgICAgIG9yZ2FuaXphdGlvbklkOiB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgd2FsbGV0TmFtZTogd2FsbGV0TmFtZSB8fCBgV2FsbGV0ICR7dGltZXN0YW1wfWAsXG4gICAgICAgIGFjY291bnRzOiBbXG4gICAgICAgICAgRGVyaXZhdGlvblBhdGguU29sYW5hKCksXG4gICAgICAgICAgRGVyaXZhdGlvblBhdGguRXRoZXJldW0oKSxcbiAgICAgICAgICBEZXJpdmF0aW9uUGF0aC5CaXRjb2luKCksXG4gICAgICAgICAgRGVyaXZhdGlvblBhdGguU3VpKClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogQ3JlYXRlV2FsbGV0TWV0aG9kRW51bS5jcmVhdGVXYWxsZXQsXG4gICAgICAgIHBhcmFtczogd2FsbGV0UmVxdWVzdCxcbiAgICAgICAgdGltZXN0YW1wTXM6IHRpbWVzdGFtcFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5rbXNBcGkucG9zdEttc1JwYyhyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHdhbGxldFJlc3VsdCA9IHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgY29uc3QgcmVxdWVzdEFjY291bnRzID0ge1xuICAgICAgICBtZXRob2Q6IEdldEFjY291bnRzTWV0aG9kRW51bS5nZXRBY2NvdW50cyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgYWNjb3VudHM6IFtcbiAgICAgICAgICAgIERlcml2YXRpb25QYXRoLlNvbGFuYSgpLFxuICAgICAgICAgICAgRGVyaXZhdGlvblBhdGguRXRoZXJldW0oKSxcbiAgICAgICAgICAgIERlcml2YXRpb25QYXRoLkJpdGNvaW4oKSxcbiAgICAgICAgICAgIERlcml2YXRpb25QYXRoLlN1aSgpXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgd2FsbGV0SWQ6IHdhbGxldFJlc3VsdC53YWxsZXRJZFxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXBNczogdGltZXN0YW1wXG4gICAgICB9O1xuICAgICAgY29uc3QgYWNjb3VudHNSZXNwb25zZSA9IGF3YWl0IHRoaXMua21zQXBpLnBvc3RLbXNScGMocmVxdWVzdEFjY291bnRzKTtcbiAgICAgIGNvbnN0IGFjY291bnRzUmVzdWx0ID0gYWNjb3VudHNSZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhbGxldElkOiB3YWxsZXRSZXN1bHQud2FsbGV0SWQsXG4gICAgICAgIGFkZHJlc3NlczogYWNjb3VudHNSZXN1bHQubWFwKChhY2NvdW50KSA9PiAoe1xuICAgICAgICAgIGFkZHJlc3NUeXBlOiBhY2NvdW50LmFkZHJlc3NGb3JtYXQsXG4gICAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgd2FsbGV0OlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB3YWxsZXQ6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh0cmFuc2FjdGlvbiwgb3JnYW5pemF0aW9uSWQsIHN1Ym1pc3Npb25Db25maWcsIGFjY291bnQsIG1ldGhvZE5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG9yZ2FuaXphdGlvbklkLFxuICAgICAgICBzdWJtaXNzaW9uQ29uZmlnLFxuICAgICAgICBzaW11bGF0aW9uQ29uZmlnOiB7IGFjY291bnQgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLnBvc3QoYCR7dGhpcy5jb25maWcuYXBpQmFzZVVybH0vcHJlcGFyZWAsIHJlcXVlc3QsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIFwiWC1ScGMtTWV0aG9kXCI6IG1ldGhvZE5hbWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JEYXRhID0gZ2V0QXhpb3NFcnJvckRhdGEoZXJyb3IpO1xuICAgICAgY29uc3Qgd2FsbGV0U2VydmljZUVycm9yID0gcGFyc2VXYWxsZXRTZXJ2aWNlRXJyb3IoZXJyb3JEYXRhKTtcbiAgICAgIGlmICh3YWxsZXRTZXJ2aWNlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgd2FsbGV0U2VydmljZUVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yRGF0YT8uZGV0YWlsIHx8IGdldEVycm9yTWVzc2FnZShlcnJvciwgXCJGYWlsZWQgdG8gc3VibWl0IHRyYW5zYWN0aW9uXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkZvclNpZ25pbmcocGFyYW1zKSB7XG4gICAgY29uc3QgeyBlbmNvZGVkVHJhbnNhY3Rpb24sIG5ldHdvcmtJZCwgc3VibWlzc2lvbkNvbmZpZywgYWNjb3VudCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGlzRXZtVHJhbnNhY3Rpb24gPSBpc0V0aGVyZXVtQ2hhaW4obmV0d29ya0lkKTtcbiAgICBjb25zdCBpc1NvbGFuYVRyYW5zYWN0aW9uID0gaXNTb2xhbmFDaGFpbihuZXR3b3JrSWQpO1xuICAgIGlmIChpc0V2bVRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4geyBraW5kOiBcIlJMUF9FTkNPREVEXCIsIGJ5dGVzOiBlbmNvZGVkVHJhbnNhY3Rpb24gfTtcbiAgICB9XG4gICAgaWYgKGlzU29sYW5hVHJhbnNhY3Rpb24gJiYgdGhpcy5jb25maWcud2FsbGV0VHlwZSA9PT0gXCJ1c2VyLXdhbGxldFwiKSB7XG4gICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjb3VudCBpcyByZXF1aXJlZCB0byBzaW11bGF0ZSBTb2xhbmEgdHJhbnNhY3Rpb25zIHdpdGggc3BlbmRpbmcgbGltaXRzXCIpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJlcGFyZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcmVwYXJlKFxuICAgICAgICAgIGVuY29kZWRUcmFuc2FjdGlvbixcbiAgICAgICAgICB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgICBzdWJtaXNzaW9uQ29uZmlnLFxuICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgcGFyYW1zLm1ldGhvZE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHByZXBhcmVSZXNwb25zZS50cmFuc2FjdGlvbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBXYWxsZXRTZXJ2aWNlRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkVHJhbnNhY3Rpb247XG4gIH1cbiAgZ2V0UnBjTWV0aG9kTmFtZShuZXR3b3JrSWQsIGluY2x1ZGVTdWJtaXNzaW9uQ29uZmlnKSB7XG4gICAgY29uc3QgaXNFdm0gPSBpc0V0aGVyZXVtQ2hhaW4obmV0d29ya0lkKTtcbiAgICBpZiAoaXNFdm0pIHtcbiAgICAgIHJldHVybiBpbmNsdWRlU3VibWlzc2lvbkNvbmZpZyA/IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiIDogXCJldGhfc2lnblRyYW5zYWN0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlU3VibWlzc2lvbkNvbmZpZyA/IFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiIDogXCJzaWduVHJhbnNhY3Rpb25cIjtcbiAgfVxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2QgZm9yIHNoYXJlZCBzaWduaW5nIGxvZ2ljXG4gICAqL1xuICBhc3luYyBwZXJmb3JtVHJhbnNhY3Rpb25TaWduaW5nKHBhcmFtcywgaW5jbHVkZVN1Ym1pc3Npb25Db25maWcpIHtcbiAgICBjb25zdCB3YWxsZXRJZCA9IHBhcmFtcy53YWxsZXRJZDtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSBwYXJhbXMudHJhbnNhY3Rpb247XG4gICAgY29uc3QgbmV0d29ya0lkUGFyYW0gPSBwYXJhbXMubmV0d29ya0lkO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHBhcmFtcy5kZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gdGhpcy5nZXRScGNNZXRob2ROYW1lKG5ldHdvcmtJZFBhcmFtLCBpbmNsdWRlU3VibWlzc2lvbkNvbmZpZyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3JnYW5pemF0aW9uSWQgaXMgcmVxdWlyZWQgdG8gc2lnbiBhIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VibWlzc2lvbkNvbmZpZyA9IGRlcml2ZVN1Ym1pc3Npb25Db25maWcobmV0d29ya0lkUGFyYW0pO1xuICAgICAgaWYgKCFzdWJtaXNzaW9uQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3VibWlzc2lvbkNvbmZpZyBjb3VsZCBub3QgYmUgZGVyaXZlZCBmb3IgbmV0d29yayBJRDogJHtuZXR3b3JrSWRQYXJhbX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmtJZFBhcmFtLCBkZXJpdmF0aW9uSW5kZXgpO1xuICAgICAgaWYgKCFuZXR3b3JrQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmV0d29yayBJRDogJHtuZXR3b3JrSWRQYXJhbX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2YXRpb25JbmZvID0ge1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogbmV0d29ya0NvbmZpZy5kZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgY3VydmU6IG5ldHdvcmtDb25maWcuY3VydmUsXG4gICAgICAgIGFkZHJlc3NGb3JtYXQ6IG5ldHdvcmtDb25maWcuYWRkcmVzc0Zvcm1hdFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRm9yU2lnbmluZyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25Gb3JTaWduaW5nKHtcbiAgICAgICAgZW5jb2RlZFRyYW5zYWN0aW9uLFxuICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZFBhcmFtLFxuICAgICAgICBzdWJtaXNzaW9uQ29uZmlnLFxuICAgICAgICBhY2NvdW50OiBwYXJhbXMuYWNjb3VudCxcbiAgICAgICAgbWV0aG9kTmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzaWduUmVxdWVzdCA9IHtcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHRoaXMuY29uZmlnLm9yZ2FuaXphdGlvbklkLFxuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uRm9yU2lnbmluZyxcbiAgICAgICAgZGVyaXZhdGlvbkluZm9cbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZVN1Ym1pc3Npb25Db25maWcpIHtcbiAgICAgICAgc2lnblJlcXVlc3Quc3VibWlzc2lvbkNvbmZpZyA9IHN1Ym1pc3Npb25Db25maWc7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZVN1Ym1pc3Npb25Db25maWcgJiYgcGFyYW1zLmFjY291bnQpIHtcbiAgICAgICAgc2lnblJlcXVlc3Quc2ltdWxhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICBhY2NvdW50OiBwYXJhbXMuYWNjb3VudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiBTaWduVHJhbnNhY3Rpb25NZXRob2RFbnVtLnNpZ25UcmFuc2FjdGlvbixcbiAgICAgICAgcGFyYW1zOiBzaWduUmVxdWVzdCxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiWC1ScGMtTWV0aG9kXCI6IG1ldGhvZE5hbWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIGNvbnN0IHJwY1N1Ym1pc3Npb25SZXN1bHQgPSByZXNwb25zZS5kYXRhW1wicnBjX3N1Ym1pc3Npb25fcmVzdWx0XCJdO1xuICAgICAgY29uc3QgaGFzaCA9IGluY2x1ZGVTdWJtaXNzaW9uQ29uZmlnICYmIHJwY1N1Ym1pc3Npb25SZXN1bHQgPyBycGNTdWJtaXNzaW9uUmVzdWx0LnJlc3VsdCA6IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbjogcmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICAvLyBCYXNlNjQgZW5jb2RlZCBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgaGFzaFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGluY2x1ZGVTdWJtaXNzaW9uQ29uZmlnID8gXCJzaWduIGFuZCBzZW5kXCIgOiBcInNpZ25cIjtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFNlcnZpY2VFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1lc3NhZ2UoZXJyb3IsIGBGYWlsZWQgdG8gJHthY3Rpb25UeXBlfSB0cmFuc2FjdGlvbmApKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybVRyYW5zYWN0aW9uU2lnbmluZyhwYXJhbXMsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3VHJhbnNhY3Rpb246IHJlc3VsdC5zaWduZWRUcmFuc2FjdGlvblxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBlcmZvcm1UcmFuc2FjdGlvblNpZ25pbmcocGFyYW1zLCB0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3VHJhbnNhY3Rpb246IHJlc3VsdC5zaWduZWRUcmFuc2FjdGlvbixcbiAgICAgIGhhc2g6IHJlc3VsdC5oYXNoXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRXYWxsZXRBZGRyZXNzZXMod2FsbGV0SWQsIGRlcml2YXRpb25QYXRocywgZGVyaXZhdGlvbkluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjY291bnRJbmRleCA9IGRlcml2YXRpb25JbmRleCA/PyAwO1xuICAgICAgY29uc3QgcGF0aHMgPSBkZXJpdmF0aW9uUGF0aHMgfHwgW1xuICAgICAgICBEZXJpdmF0aW9uUGF0aC5Tb2xhbmEoYWNjb3VudEluZGV4KSxcbiAgICAgICAgRGVyaXZhdGlvblBhdGguRXRoZXJldW0oYWNjb3VudEluZGV4KSxcbiAgICAgICAgRGVyaXZhdGlvblBhdGguQml0Y29pbihhY2NvdW50SW5kZXgpLFxuICAgICAgICBEZXJpdmF0aW9uUGF0aC5TdWkoYWNjb3VudEluZGV4KVxuICAgICAgXTtcbiAgICAgIGNvbnN0IHJlcXVlc3RBY2NvdW50cyA9IHtcbiAgICAgICAgbWV0aG9kOiBHZXRBY2NvdW50c01ldGhvZEVudW0uZ2V0QWNjb3VudHMsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGFjY291bnRzOiBwYXRocyxcbiAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgd2FsbGV0SWRcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgYWNjb3VudHNSZXNwb25zZSA9IGF3YWl0IHRoaXMua21zQXBpLnBvc3RLbXNScGMocmVxdWVzdEFjY291bnRzKTtcbiAgICAgIGNvbnN0IGFjY291bnRzUmVzdWx0ID0gYWNjb3VudHNSZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGFjY291bnRzUmVzdWx0Lm1hcCgoYWNjb3VudCkgPT4gKHtcbiAgICAgICAgYWRkcmVzc1R5cGU6IGFjY291bnQuYWRkcmVzc0Zvcm1hdCxcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gYWRkcmVzc2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCB3YWxsZXQgYWRkcmVzc2VzOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB3YWxsZXQgYWRkcmVzc2VzOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaWduIGFuIEV0aGVyZXVtIG1lc3NhZ2UgdXNpbmcgRUlQLTE5MSBwZXJzb25hbCBzaWduXG4gICAqL1xuICBhc3luYyBldGhlcmV1bVNpZ25NZXNzYWdlKHBhcmFtcykge1xuICAgIGNvbnN0IHdhbGxldElkID0gcGFyYW1zLndhbGxldElkO1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJhbSA9IHBhcmFtcy5tZXNzYWdlO1xuICAgIGNvbnN0IG5ldHdvcmtJZFBhcmFtID0gcGFyYW1zLm5ldHdvcmtJZDtcbiAgICBjb25zdCBkZXJpdmF0aW9uSW5kZXggPSBwYXJhbXMuZGVyaXZhdGlvbkluZGV4ID8/IDA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3JnYW5pemF0aW9uSWQgaXMgcmVxdWlyZWQgdG8gc2lnbiBhIG1lc3NhZ2VcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnID0gZ2V0TmV0d29ya0NvbmZpZyhuZXR3b3JrSWRQYXJhbSwgZGVyaXZhdGlvbkluZGV4KTtcbiAgICAgIGlmICghbmV0d29ya0NvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG5ldHdvcmsgSUQ6ICR7bmV0d29ya0lkUGFyYW19YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXJpdmF0aW9uSW5mbyA9IHtcbiAgICAgICAgZGVyaXZhdGlvblBhdGg6IG5ldHdvcmtDb25maWcuZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIGN1cnZlOiBuZXR3b3JrQ29uZmlnLmN1cnZlLFxuICAgICAgICBhZGRyZXNzRm9ybWF0OiBuZXR3b3JrQ29uZmlnLmFkZHJlc3NGb3JtYXRcbiAgICAgIH07XG4gICAgICBjb25zdCBiYXNlNjRTdHJpbmdNZXNzYWdlID0gbWVzc2FnZVBhcmFtO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiBcImV0aGVyZXVtU2lnbk1lc3NhZ2VcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgbWVzc2FnZTogYmFzZTY0U3RyaW5nTWVzc2FnZSxcbiAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgZGVyaXZhdGlvbkluZm9cbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0LnNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzaWduIEV0aGVyZXVtIG1lc3NhZ2U6XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBFdGhlcmV1bSBtZXNzYWdlOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaWduIGEgVVRGLTggbWVzc2FnZSBmb3IgU29sYW5hXG4gICAqL1xuICBhc3luYyBzaWduVXRmOE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgY29uc3Qgd2FsbGV0SWQgPSBwYXJhbXMud2FsbGV0SWQ7XG4gICAgY29uc3QgbWVzc2FnZVBhcmFtID0gcGFyYW1zLm1lc3NhZ2U7XG4gICAgY29uc3QgbmV0d29ya0lkUGFyYW0gPSBwYXJhbXMubmV0d29ya0lkO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHBhcmFtcy5kZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcmdhbml6YXRpb25JZCBpcyByZXF1aXJlZCB0byBzaWduIGEgbWVzc2FnZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmtJZFBhcmFtLCBkZXJpdmF0aW9uSW5kZXgpO1xuICAgICAgaWYgKCFuZXR3b3JrQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmV0d29yayBJRDogJHtuZXR3b3JrSWRQYXJhbX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2YXRpb25JbmZvID0ge1xuICAgICAgICBkZXJpdmF0aW9uUGF0aDogbmV0d29ya0NvbmZpZy5kZXJpdmF0aW9uUGF0aCxcbiAgICAgICAgY3VydmU6IG5ldHdvcmtDb25maWcuY3VydmUsXG4gICAgICAgIGFkZHJlc3NGb3JtYXQ6IG5ldHdvcmtDb25maWcuYWRkcmVzc0Zvcm1hdFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpZ25SZXF1ZXN0ID0ge1xuICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlUGFyYW0sXG4gICAgICAgIGFsZ29yaXRobTogbmV0d29ya0NvbmZpZy5hbGdvcml0aG0sXG4gICAgICAgIGRlcml2YXRpb25JbmZvXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiBTaWduVVRGOE1lc3NhZ2VNZXRob2RFbnVtLnNpZ25VdGY4TWVzc2FnZSxcbiAgICAgICAgcGFyYW1zOiBzaWduUmVxdWVzdCxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0LnNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzaWduIHJhdyBwYXlsb2FkOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNpZ24gcmF3IHBheWxvYWQ6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gRUlQLTcxMiB0eXBlZCBkYXRhIGZvciBFdGhlcmV1bVxuICAgKi9cbiAgYXN5bmMgZXRoZXJldW1TaWduVHlwZWREYXRhKHBhcmFtcykge1xuICAgIGNvbnN0IHdhbGxldElkID0gcGFyYW1zLndhbGxldElkO1xuICAgIGNvbnN0IHR5cGVkRGF0YSA9IHBhcmFtcy50eXBlZERhdGE7XG4gICAgY29uc3QgbmV0d29ya0lkUGFyYW0gPSBwYXJhbXMubmV0d29ya0lkO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHBhcmFtcy5kZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5vcmdhbml6YXRpb25JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcmdhbml6YXRpb25JZCBpcyByZXF1aXJlZCB0byBzaWduIHR5cGVkIGRhdGFcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnID0gZ2V0TmV0d29ya0NvbmZpZyhuZXR3b3JrSWRQYXJhbSwgZGVyaXZhdGlvbkluZGV4KTtcbiAgICAgIGlmICghbmV0d29ya0NvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG5ldHdvcmsgSUQ6ICR7bmV0d29ya0lkUGFyYW19YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXJpdmF0aW9uSW5mbyA9IHtcbiAgICAgICAgZGVyaXZhdGlvblBhdGg6IG5ldHdvcmtDb25maWcuZGVyaXZhdGlvblBhdGgsXG4gICAgICAgIGN1cnZlOiBuZXR3b3JrQ29uZmlnLmN1cnZlLFxuICAgICAgICBhZGRyZXNzRm9ybWF0OiBuZXR3b3JrQ29uZmlnLmFkZHJlc3NGb3JtYXRcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6IFwiZXRoZXJldW1TaWduVHlwZWREYXRhXCIsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHR5cGVkRGF0YSxcbiAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgZGVyaXZhdGlvbkluZm9cbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0LnNpZ25hdHVyZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzaWduIHR5cGVkIGRhdGE6XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiB0eXBlZCBkYXRhOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFdhbGxldHMobGltaXQsIG9mZnNldCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6IFwiZ2V0T3JnYW5pemF0aW9uV2FsbGV0c1wiLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBvcmdhbml6YXRpb25JZDogdGhpcy5jb25maWcub3JnYW5pemF0aW9uSWQsXG4gICAgICAgICAgbGltaXQ6IGxpbWl0IHx8IDIwLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IHx8IDBcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YWxsZXRzOiByZXN1bHQud2FsbGV0cy5tYXAoKHdhbGxldCkgPT4gKHtcbiAgICAgICAgICB3YWxsZXRJZDogd2FsbGV0LndhbGxldElkLFxuICAgICAgICAgIHdhbGxldE5hbWU6IHdhbGxldC53YWxsZXROYW1lXG4gICAgICAgIH0pKSxcbiAgICAgICAgdG90YWxDb3VudDogcmVzdWx0LnRvdGFsQ291bnQsXG4gICAgICAgIGxpbWl0OiByZXN1bHQubGltaXQsXG4gICAgICAgIG9mZnNldDogcmVzdWx0Lm9mZnNldFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgd2FsbGV0czpcIiwgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgd2FsbGV0czogJHtlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IG9yZ2FuaXphdGlvbiBkZXRhaWxzIGJ5IG9yZ2FuaXphdGlvbiBJRFxuICAgKi9cbiAgYXN5bmMgZ2V0T3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogXCJnZXRPcmdhbml6YXRpb25cIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgb3JnYW5pemF0aW9uSWRcbiAgICAgICAgfSxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBvcmdhbml6YXRpb246XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IG9yZ2FuaXphdGlvbjogJHtlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9yZ2FuaXphdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhbmQgdXNlcnNcbiAgICogQHBhcmFtIG5hbWUgT3JnYW5pemF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHVzZXJzIEFycmF5IG9mIHVzZXJzIHdpdGggdGhlaXIgYXV0aGVudGljYXRvcnNcbiAgICovXG4gIHZhbGlkYXRlTmFtZUxlbmd0aChuYW1lLCB0eXBlKSB7XG4gICAgY29uc3QgTUFYX05BTUVfTEVOR1RIID0gNjQ7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gTUFYX05BTUVfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX0gbmFtZSBjYW5ub3QgZXhjZWVkICR7TUFYX05BTUVfTEVOR1RIfSBjaGFyYWN0ZXJzLiBDdXJyZW50IGxlbmd0aDogJHtuYW1lLmxlbmd0aH1gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY3JlYXRlT3JnYW5pemF0aW9uKG5hbWUsIHVzZXJzLCB0YWdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcmdhbml6YXRpb24gbmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVOYW1lTGVuZ3RoKG5hbWUsIFwiT3JnYW5pemF0aW9uXCIpO1xuICAgICAgaWYgKCF1c2VycyB8fCB1c2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHVzZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHVzZXIgb2YgdXNlcnMpIHtcbiAgICAgICAgaWYgKHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlTmFtZUxlbmd0aCh1c2VyLnVzZXJuYW1lLCBcIlVzZXJuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYXV0aCBvZiB1c2VyLmF1dGhlbnRpY2F0b3JzKSB7XG4gICAgICAgICAgaWYgKGF1dGguYXV0aGVudGljYXRvck5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVOYW1lTGVuZ3RoKGF1dGguYXV0aGVudGljYXRvck5hbWUsIFwiQXV0aGVudGljYXRvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgb3JnYW5pemF0aW9uTmFtZTogbmFtZSxcbiAgICAgICAgdXNlcnM6IHVzZXJzLm1hcCgodXNlckNvbmZpZykgPT4gKHtcbiAgICAgICAgICB1c2VybmFtZTogdXNlckNvbmZpZy51c2VybmFtZSB8fCBgdXNlci0ke3JhbmRvbVVVSUQoKX1gLFxuICAgICAgICAgIGF1dGhlbnRpY2F0b3JzOiB1c2VyQ29uZmlnLmF1dGhlbnRpY2F0b3JzLFxuICAgICAgICAgIHBvbGljeTogdXNlckNvbmZpZy5yb2xlID09PSBcIkFETUlOXCIgPyB7XG4gICAgICAgICAgICB0eXBlOiBVc2VyUG9saWN5T25lT2ZUeXBlRW51bS5yb290XG4gICAgICAgICAgfSA6IHsgdHlwZTogXCJDRUxcIiwgcHJlc2V0OiBcIkxFR0FDWV9VU0VSX1JPTEVcIiB9XG4gICAgICAgIH0pKSxcbiAgICAgICAgdGFnc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogQ3JlYXRlT3JnYW5pemF0aW9uTWV0aG9kRW51bS5jcmVhdGVPcmdhbml6YXRpb24sXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBvcmdhbml6YXRpb246XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG9yZ2FuaXphdGlvbjogJHtlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGF1dGhlbnRpY2F0b3IgZm9yIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb25cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUF1dGhlbnRpY2F0b3IocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXJhbXMudXNlcm5hbWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5hbWVMZW5ndGgocGFyYW1zLnVzZXJuYW1lLCBcIlVzZXJuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5hdXRoZW50aWNhdG9yTmFtZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlTmFtZUxlbmd0aChwYXJhbXMuYXV0aGVudGljYXRvck5hbWUsIFwiQXV0aGVudGljYXRvclwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuYXV0aGVudGljYXRvcj8uYXV0aGVudGljYXRvck5hbWUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5hbWVMZW5ndGgocGFyYW1zLmF1dGhlbnRpY2F0b3IuYXV0aGVudGljYXRvck5hbWUsIFwiQXV0aGVudGljYXRvclwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgIG9yZ2FuaXphdGlvbklkOiBwYXJhbXMub3JnYW5pemF0aW9uSWQsXG4gICAgICAgIHVzZXJuYW1lOiBwYXJhbXMudXNlcm5hbWUsXG4gICAgICAgIGF1dGhlbnRpY2F0b3JOYW1lOiBwYXJhbXMuYXV0aGVudGljYXRvck5hbWUsXG4gICAgICAgIGF1dGhlbnRpY2F0b3I6IHBhcmFtcy5hdXRoZW50aWNhdG9yLFxuICAgICAgICByZXBsYWNlRXhwaXJhYmxlOiBwYXJhbXMucmVwbGFjZUV4cGlyYWJsZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogQ3JlYXRlQXV0aGVudGljYXRvck1ldGhvZEVudW0uY3JlYXRlQXV0aGVudGljYXRvcixcbiAgICAgICAgcGFyYW1zOiByZXF1ZXN0UGFyYW1zLFxuICAgICAgICB0aW1lc3RhbXBNczogYXdhaXQgZ2V0U2VjdXJlVGltZXN0YW1wKClcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMua21zQXBpLnBvc3RLbXNScGMocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGF1dGhlbnRpY2F0b3I6XCIsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGF1dGhlbnRpY2F0b3I6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBhdXRoZW50aWNhdG9yIGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uXG4gICAqL1xuICBhc3luYyBkZWxldGVBdXRoZW50aWNhdG9yKHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBvcmdhbml6YXRpb25JZDogcGFyYW1zLm9yZ2FuaXphdGlvbklkLFxuICAgICAgICB1c2VybmFtZTogcGFyYW1zLnVzZXJuYW1lLFxuICAgICAgICBhdXRoZW50aWNhdG9ySWQ6IHBhcmFtcy5hdXRoZW50aWNhdG9ySWRcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6IERlbGV0ZUF1dGhlbnRpY2F0b3JNZXRob2RFbnVtLmRlbGV0ZUF1dGhlbnRpY2F0b3IsXG4gICAgICAgIHBhcmFtczogcmVxdWVzdFBhcmFtcyxcbiAgICAgICAgdGltZXN0YW1wTXM6IGF3YWl0IGdldFNlY3VyZVRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBhdXRoZW50aWNhdG9yOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBhdXRoZW50aWNhdG9yOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdyYW50T3JnYW5pemF0aW9uQWNjZXNzKHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6IEdyYW50T3JnYW5pemF0aW9uQWNjZXNzTWV0aG9kRW51bS5ncmFudE9yZ2FuaXphdGlvbkFjY2VzcyxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0aW1lc3RhbXBNczogYXdhaXQgZ2V0U2VjdXJlVGltZXN0YW1wKClcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMua21zQXBpLnBvc3RLbXNScGMocmVxdWVzdCk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5kYXRhLnJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ3JhbnQgb3JnYW5pemF0aW9uIGFjY2VzczpcIiwgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBncmFudCBvcmdhbml6YXRpb24gYWNjZXNzOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgdXNlciB0byBhbiBvcmdhbml6YXRpb25cbiAgICovXG4gIGFzeW5jIGFkZFVzZXJUb09yZ2FuaXphdGlvbihwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiBBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtLmFkZFVzZXJUb09yZ2FuaXphdGlvbixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB0aW1lc3RhbXBNczogYXdhaXQgZ2V0U2VjdXJlVGltZXN0YW1wKClcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLmttc0FwaS5wb3N0S21zUnBjKHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFkZCB1c2VyIHRvIG9yZ2FuaXphdGlvbjpcIiwgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgdXNlciB0byBvcmdhbml6YXRpb246ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSB0YWcgZnJvbSB0aGUgc3BlY2lmaWVkIG9yZ2FuaXphdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0V2l0aFRhZyhwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiBcImdldFdhbGxldFdpdGhUYWdcIixcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHBhcmFtcy5vcmdhbml6YXRpb25JZCxcbiAgICAgICAgICB0YWc6IHBhcmFtcy50YWcsXG4gICAgICAgICAgZGVyaXZhdGlvblBhdGhzOiBwYXJhbXMuZGVyaXZhdGlvblBhdGhzXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVzdGFtcE1zOiBhd2FpdCBnZXRTZWN1cmVUaW1lc3RhbXAoKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5rbXNBcGkucG9zdEttc1JwYyhyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgd2FsbGV0IHdpdGggdGFnOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCB3YWxsZXQgd2l0aCB0YWc6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFN0YW1wIGFuIGF4aW9zIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgc3RhbXBlclxuICAgKi9cbiAgYXN5bmMgc3RhbXBSZXF1ZXN0KGNvbmZpZywgc3RhbXBlcikge1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gdHlwZW9mIGNvbmZpZy5kYXRhID09PSBcInN0cmluZ1wiID8gY29uZmlnLmRhdGEgOiBjb25maWcuZGF0YSA9PT0gdm9pZCAwID8gXCJcIiA6IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5kYXRhKTtcbiAgICBjb25zdCBkYXRhVXRmOCA9IEJ1ZmZlci5mcm9tKHJlcXVlc3RCb2R5LCBcInV0ZjhcIik7XG4gICAgY29uc3Qgc3RhbXAgPSBhd2FpdCBzdGFtcGVyLnN0YW1wKHtcbiAgICAgIGRhdGE6IGRhdGFVdGY4XG4gICAgfSk7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcbiAgICBjb25maWcuaGVhZGVyc1tcIlgtUGhhbnRvbS1TdGFtcFwiXSA9IHN0YW1wO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZ2VuZXJhdGVLZXlQYWlyIH0gZnJvbSBcIkBwaGFudG9tL2NyeXB0b1wiO1xuaW1wb3J0IHsgTmV0d29ya0lkIGFzIE5ldHdvcmtJZDIgfSBmcm9tIFwiQHBoYW50b20vY29uc3RhbnRzXCI7XG5pbXBvcnQge1xuICBEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtIGFzIERlcml2YXRpb25JbmZvQWRkcmVzc0Zvcm1hdEVudW0yXG59IGZyb20gXCJAcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlXCI7XG5leHBvcnQge1xuICBEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtMiBhcyBBZGRyZXNzVHlwZSxcbiAgRGVyaXZhdGlvblBhdGgsXG4gIE5ldHdvcmtJZDIgYXMgTmV0d29ya0lkLFxuICBQaGFudG9tQ2xpZW50LFxuICBTcGVuZGluZ0xpbWl0RXJyb3IsXG4gIFRyYW5zYWN0aW9uQmxvY2tlZEVycm9yLFxuICBXYWxsZXRTZXJ2aWNlRXJyb3IsXG4gIGRlcml2ZVN1Ym1pc3Npb25Db25maWcsXG4gIGdlbmVyYXRlS2V5UGFpcixcbiAgZ2V0QXhpb3NFcnJvckRhdGEsXG4gIGdldERlcml2YXRpb25QYXRoRm9yTmV0d29yayxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBnZXROZXR3b3JrQ29uZmlnLFxuICBnZXROZXR3b3JrRGVzY3JpcHRpb24sXG4gIGdldE5ldHdvcmtJZHNCeUNoYWluLFxuICBnZXRTdXBwb3J0ZWROZXR3b3JrSWRzLFxuICBwYXJzZVdhbGxldFNlcnZpY2VFcnJvcixcbiAgc3VwcG9ydHNUcmFuc2FjdGlvblN1Ym1pc3Npb25cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/client/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/constants/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@phantom/constants/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANALYTICS_HEADERS: () => (/* binding */ ANALYTICS_HEADERS),\n/* harmony export */   DEFAULT_AUTH_URL: () => (/* binding */ DEFAULT_AUTH_URL),\n/* harmony export */   DEFAULT_EMBEDDED_WALLET_TYPE: () => (/* binding */ DEFAULT_EMBEDDED_WALLET_TYPE),\n/* harmony export */   DEFAULT_WALLET_API_URL: () => (/* binding */ DEFAULT_WALLET_API_URL),\n/* harmony export */   NETWORK_CONFIGS: () => (/* binding */ NETWORK_CONFIGS),\n/* harmony export */   NetworkId: () => (/* binding */ NetworkId),\n/* harmony export */   PROVIDER_NAMES: () => (/* binding */ PROVIDER_NAMES),\n/* harmony export */   chainIdToNetworkId: () => (/* binding */ chainIdToNetworkId),\n/* harmony export */   getExplorerUrl: () => (/* binding */ getExplorerUrl),\n/* harmony export */   getNetworkConfig: () => (/* binding */ getNetworkConfig),\n/* harmony export */   getNetworksByChain: () => (/* binding */ getNetworksByChain),\n/* harmony export */   getProviderName: () => (/* binding */ getProviderName),\n/* harmony export */   getSupportedNetworks: () => (/* binding */ getSupportedNetworks),\n/* harmony export */   internalCaipToNetworkId: () => (/* binding */ internalCaipToNetworkId),\n/* harmony export */   networkIdToChainId: () => (/* binding */ networkIdToChainId),\n/* harmony export */   networkIdToInternalCaip: () => (/* binding */ networkIdToInternalCaip)\n/* harmony export */ });\n// src/network-ids.ts\nvar NetworkId = /* @__PURE__ */ ((NetworkId2) => {\n  NetworkId2[\"SOLANA_MAINNET\"] = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\n  NetworkId2[\"SOLANA_DEVNET\"] = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\n  NetworkId2[\"SOLANA_TESTNET\"] = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n  NetworkId2[\"ETHEREUM_MAINNET\"] = \"eip155:1\";\n  NetworkId2[\"ETHEREUM_SEPOLIA\"] = \"eip155:11155111\";\n  NetworkId2[\"POLYGON_MAINNET\"] = \"eip155:137\";\n  NetworkId2[\"POLYGON_AMOY\"] = \"eip155:80002\";\n  NetworkId2[\"BASE_MAINNET\"] = \"eip155:8453\";\n  NetworkId2[\"BASE_SEPOLIA\"] = \"eip155:84532\";\n  NetworkId2[\"ARBITRUM_ONE\"] = \"eip155:42161\";\n  NetworkId2[\"ARBITRUM_SEPOLIA\"] = \"eip155:421614\";\n  NetworkId2[\"MONAD_MAINNET\"] = \"eip155:143\";\n  NetworkId2[\"MONAD_TESTNET\"] = \"eip155:10143\";\n  NetworkId2[\"BITCOIN_MAINNET\"] = \"bip122:000000000019d6689c085ae165831e93\";\n  NetworkId2[\"BITCOIN_TESTNET\"] = \"bip122:000000000933ea01ad0ee984209779ba\";\n  NetworkId2[\"SUI_MAINNET\"] = \"sui:35834a8a\";\n  NetworkId2[\"SUI_TESTNET\"] = \"sui:4c78adac\";\n  NetworkId2[\"SUI_DEVNET\"] = \"sui:devnet\";\n  return NetworkId2;\n})(NetworkId || {});\n\n// src/networks.ts\nvar NETWORK_CONFIGS = {\n  // Solana Networks\n  [\"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\" /* SOLANA_MAINNET */]: {\n    name: \"Solana Mainnet\",\n    chain: \"solana\",\n    network: \"mainnet\",\n    internalCaip: \"solana:101\",\n    slip44: \"501\",\n    explorer: {\n      name: \"Solscan\",\n      transactionUrl: \"https://solscan.io/tx/{hash}\",\n      addressUrl: \"https://solscan.io/account/{address}\"\n    }\n  },\n  [\"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\" /* SOLANA_DEVNET */]: {\n    name: \"Solana Devnet\",\n    chain: \"solana\",\n    network: \"devnet\",\n    internalCaip: \"solana:103\",\n    slip44: \"501\",\n    explorer: {\n      name: \"Solscan\",\n      transactionUrl: \"https://solscan.io/tx/{hash}?cluster=devnet\",\n      addressUrl: \"https://solscan.io/account/{address}?cluster=devnet\"\n    }\n  },\n  [\"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\" /* SOLANA_TESTNET */]: {\n    name: \"Solana Testnet\",\n    chain: \"solana\",\n    network: \"testnet\",\n    internalCaip: \"solana:102\",\n    slip44: \"501\",\n    explorer: {\n      name: \"Solscan\",\n      transactionUrl: \"https://solscan.io/tx/{hash}?cluster=testnet\",\n      addressUrl: \"https://solscan.io/account/{address}?cluster=testnet\"\n    }\n  },\n  // Ethereum Networks\n  [\"eip155:1\" /* ETHEREUM_MAINNET */]: {\n    name: \"Ethereum Mainnet\",\n    chain: \"ethereum\",\n    network: \"mainnet\",\n    internalCaip: \"eip155:1\",\n    chainId: 1,\n    slip44: \"60\",\n    explorer: {\n      name: \"Etherscan\",\n      transactionUrl: \"https://etherscan.io/tx/{hash}\",\n      addressUrl: \"https://etherscan.io/address/{address}\"\n    }\n  },\n  [\"eip155:11155111\" /* ETHEREUM_SEPOLIA */]: {\n    name: \"Ethereum Sepolia\",\n    chain: \"ethereum\",\n    network: \"sepolia\",\n    internalCaip: \"eip155:11155111\",\n    chainId: 11155111,\n    slip44: \"60\",\n    explorer: {\n      name: \"Etherscan\",\n      transactionUrl: \"https://sepolia.etherscan.io/tx/{hash}\",\n      addressUrl: \"https://sepolia.etherscan.io/address/{address}\"\n    }\n  },\n  // Polygon Networks\n  [\"eip155:137\" /* POLYGON_MAINNET */]: {\n    name: \"Polygon Mainnet\",\n    chain: \"polygon\",\n    network: \"mainnet\",\n    internalCaip: \"eip155:137\",\n    chainId: 137,\n    slip44: \"137\",\n    explorer: {\n      name: \"Polygonscan\",\n      transactionUrl: \"https://polygonscan.com/tx/{hash}\",\n      addressUrl: \"https://polygonscan.com/address/{address}\"\n    }\n  },\n  [\"eip155:80002\" /* POLYGON_AMOY */]: {\n    name: \"Polygon Amoy\",\n    chain: \"polygon\",\n    network: \"amoy\",\n    internalCaip: \"eip155:80002\",\n    chainId: 80002,\n    slip44: \"137\",\n    explorer: {\n      name: \"Polygonscan\",\n      transactionUrl: \"https://amoy.polygonscan.com/tx/{hash}\",\n      addressUrl: \"https://amoy.polygonscan.com/address/{address}\"\n    }\n  },\n  // Base Networks\n  [\"eip155:8453\" /* BASE_MAINNET */]: {\n    name: \"Base Mainnet\",\n    chain: \"base\",\n    network: \"mainnet\",\n    internalCaip: \"eip155:8453\",\n    chainId: 8453,\n    slip44: \"8453\",\n    explorer: {\n      name: \"Basescan\",\n      transactionUrl: \"https://basescan.org/tx/{hash}\",\n      addressUrl: \"https://basescan.org/address/{address}\"\n    }\n  },\n  [\"eip155:84532\" /* BASE_SEPOLIA */]: {\n    name: \"Base Sepolia\",\n    chain: \"base\",\n    network: \"sepolia\",\n    internalCaip: \"eip155:84532\",\n    chainId: 84532,\n    slip44: \"8453\",\n    explorer: {\n      name: \"Basescan\",\n      transactionUrl: \"https://sepolia.basescan.org/tx/{hash}\",\n      addressUrl: \"https://sepolia.basescan.org/address/{address}\"\n    }\n  },\n  // Arbitrum Networks\n  [\"eip155:42161\" /* ARBITRUM_ONE */]: {\n    name: \"Arbitrum One\",\n    chain: \"arbitrum\",\n    network: \"mainnet\",\n    internalCaip: \"eip155:42161\",\n    chainId: 42161,\n    slip44: \"42161\",\n    explorer: {\n      name: \"Arbiscan\",\n      transactionUrl: \"https://arbiscan.io/tx/{hash}\",\n      addressUrl: \"https://arbiscan.io/address/{address}\"\n    }\n  },\n  [\"eip155:421614\" /* ARBITRUM_SEPOLIA */]: {\n    name: \"Arbitrum Sepolia\",\n    chain: \"arbitrum\",\n    network: \"sepolia\",\n    internalCaip: \"eip155:421614\",\n    chainId: 421614,\n    slip44: \"42161\",\n    explorer: {\n      name: \"Arbiscan\",\n      transactionUrl: \"https://sepolia.arbiscan.io/tx/{hash}\",\n      addressUrl: \"https://sepolia.arbiscan.io/address/{address}\"\n    }\n  },\n  // Monad Networks\n  [\"eip155:143\" /* MONAD_MAINNET */]: {\n    name: \"Monad Mainnet\",\n    chain: \"monad\",\n    network: \"mainnet\",\n    internalCaip: \"eip155:143\",\n    chainId: 143,\n    slip44: \"60\",\n    // Uses Ethereum SLIP-44\n    explorer: {\n      name: \"Monad Explorer\",\n      transactionUrl: \"https://monadexplorer.com/tx/{hash}\",\n      addressUrl: \"https://monadexplorer.com/address/{address}\"\n    }\n  },\n  [\"eip155:10143\" /* MONAD_TESTNET */]: {\n    name: \"Monad Testnet\",\n    chain: \"monad\",\n    network: \"testnet\",\n    internalCaip: \"eip155:10143\",\n    chainId: 10143,\n    slip44: \"60\",\n    // Uses Ethereum SLIP-44\n    explorer: {\n      name: \"Monad Testnet Explorer\",\n      transactionUrl: \"https://testnet.monadexplorer.com/tx/{hash}\",\n      addressUrl: \"https://testnet.monadexplorer.com/address/{address}\"\n    }\n  },\n  // Bitcoin Networks (for future support)\n  [\"bip122:000000000019d6689c085ae165831e93\" /* BITCOIN_MAINNET */]: {\n    name: \"Bitcoin Mainnet\",\n    chain: \"bitcoin\",\n    network: \"mainnet\",\n    internalCaip: \"bip122:000000000019d6689c085ae165831e93\",\n    slip44: \"0\",\n    explorer: {\n      name: \"Blockstream\",\n      transactionUrl: \"https://blockstream.info/tx/{hash}\",\n      addressUrl: \"https://blockstream.info/address/{address}\"\n    }\n  },\n  [\"bip122:000000000933ea01ad0ee984209779ba\" /* BITCOIN_TESTNET */]: {\n    name: \"Bitcoin Testnet\",\n    chain: \"bitcoin\",\n    network: \"testnet\",\n    internalCaip: \"bip122:000000000933ea01ad0ee984209779ba\",\n    slip44: \"0\",\n    explorer: {\n      name: \"Blockstream\",\n      transactionUrl: \"https://blockstream.info/testnet/tx/{hash}\",\n      addressUrl: \"https://blockstream.info/testnet/address/{address}\"\n    }\n  },\n  // Sui Networks (for future support)\n  [\"sui:35834a8a\" /* SUI_MAINNET */]: {\n    name: \"Sui Mainnet\",\n    chain: \"sui\",\n    network: \"mainnet\",\n    internalCaip: \"sui:mainnet\",\n    slip44: \"784\",\n    explorer: {\n      name: \"Sui Explorer\",\n      transactionUrl: \"https://explorer.sui.io/txblock/{hash}?network=mainnet\",\n      addressUrl: \"https://explorer.sui.io/address/{address}?network=mainnet\"\n    }\n  },\n  [\"sui:4c78adac\" /* SUI_TESTNET */]: {\n    name: \"Sui Testnet\",\n    chain: \"sui\",\n    network: \"testnet\",\n    internalCaip: \"sui:testnet\",\n    slip44: \"784\",\n    explorer: {\n      name: \"Sui Explorer\",\n      transactionUrl: \"https://explorer.sui.io/txblock/{hash}?network=testnet\",\n      addressUrl: \"https://explorer.sui.io/address/{address}?network=testnet\"\n    }\n  },\n  [\"sui:devnet\" /* SUI_DEVNET */]: {\n    name: \"Sui Devnet\",\n    chain: \"sui\",\n    network: \"devnet\",\n    internalCaip: \"sui:devnet\",\n    slip44: \"784\",\n    explorer: {\n      name: \"Sui Explorer\",\n      transactionUrl: \"https://explorer.sui.io/txblock/{hash}?network=devnet\",\n      addressUrl: \"https://explorer.sui.io/address/{address}?network=devnet\"\n    }\n  }\n};\nfunction getNetworkConfig(networkId) {\n  return NETWORK_CONFIGS[networkId];\n}\nfunction getExplorerUrl(networkId, type, value) {\n  const config = getNetworkConfig(networkId);\n  if (!config?.explorer)\n    return void 0;\n  const template = type === \"transaction\" ? config.explorer.transactionUrl : config.explorer.addressUrl;\n  const placeholder = type === \"transaction\" ? \"{hash}\" : \"{address}\";\n  return template.replace(placeholder, value);\n}\nfunction getSupportedNetworks() {\n  return Object.keys(NETWORK_CONFIGS);\n}\nfunction getNetworksByChain(chain) {\n  return Object.entries(NETWORK_CONFIGS).filter(([_, config]) => config.chain === chain).map(([networkId]) => networkId);\n}\nfunction chainIdToNetworkId(chainId) {\n  return Object.keys(NETWORK_CONFIGS).find((id) => NETWORK_CONFIGS[id].chainId === chainId);\n}\nfunction networkIdToChainId(networkId) {\n  return NETWORK_CONFIGS[networkId]?.chainId;\n}\nfunction networkIdToInternalCaip(networkId) {\n  const config = NETWORK_CONFIGS[networkId];\n  if (!config || !config.internalCaip) {\n    throw new Error(`No internal CAIP mapping found for NetworkId: ${networkId}`);\n  }\n  return config.internalCaip;\n}\nfunction internalCaipToNetworkId(internalCaip) {\n  const networkId = Object.keys(NETWORK_CONFIGS).find(\n    (id) => NETWORK_CONFIGS[id].internalCaip === internalCaip\n  );\n  if (!networkId) {\n    throw new Error(`No NetworkId mapping found for internal CAIP: ${internalCaip}`);\n  }\n  return networkId;\n}\n\n// src/analytics.ts\nvar ANALYTICS_HEADERS = {\n  SDK_TYPE: \"x-phantom-sdk-type\",\n  // server, browser-sdk, react-native-sdk\n  SDK_VERSION: \"x-phantom-sdk-version\",\n  // SDK version, e.g. 1.0.0\n  PLATFORM: \"x-phantom-platform\",\n  // firefox, chrome, safari, ios, android, etc.\n  WALLET_TYPE: \"x-phantom-wallet-type\",\n  // app-wallet, user-wallet\n  APP_ID: \"x-app-id\",\n  // Your application ID for identifying your app in analytics\n  PLATFORM_VERSION: \"x-phantom-platform-version\"\n  // OS version, device model, etc.\n};\n\n// src/environments.ts\nvar DEFAULT_AUTH_URL = \"https://connect.phantom.app/login\";\nvar DEFAULT_WALLET_API_URL = \"https://api.phantom.app/v1/wallets\";\nvar DEFAULT_EMBEDDED_WALLET_TYPE = \"user-wallet\";\n\n// src/provider-names.ts\nvar PROVIDER_NAMES = {\n  google: \"Google\",\n  apple: \"Apple\",\n  phantom: \"Phantom\",\n  device: \"Device\",\n  injected: \"Wallet\",\n  deeplink: \"Deeplink\"\n};\nfunction getProviderName(provider) {\n  return PROVIDER_NAMES[provider] || \"Wallet\";\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vY29uc3RhbnRzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25ELCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRCwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRCxpREFBaUQsUUFBUTtBQUN6RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hELG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdELHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQsaURBQWlELFFBQVE7QUFDekQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0QseURBQXlELFFBQVE7QUFDakU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRCxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQsc0RBQXNELFFBQVE7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRSw4REFBOEQsUUFBUTtBQUN0RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxxREFBcUQsUUFBUTtBQUM3RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEtBQUs7QUFDakUsNkRBQTZELFFBQVE7QUFDckU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Qsb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLO0FBQzdELG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RCxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssTUFBTSxRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vY29uc3RhbnRzL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9uZXR3b3JrLWlkcy50c1xudmFyIE5ldHdvcmtJZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtJZDIpID0+IHtcbiAgTmV0d29ya0lkMltcIlNPTEFOQV9NQUlOTkVUXCJdID0gXCJzb2xhbmE6NWV5a3Q0VXNGdjhQOE5KZFRSRXBZMXZ6cUtxWkt2ZHBcIjtcbiAgTmV0d29ya0lkMltcIlNPTEFOQV9ERVZORVRcIl0gPSBcInNvbGFuYTpFdFdUUkFCWmFZcTZpTWZlWUtvdVJ1MTY2VlUyeHFhMVwiO1xuICBOZXR3b3JrSWQyW1wiU09MQU5BX1RFU1RORVRcIl0gPSBcInNvbGFuYTo0dWhjVkp5VTlwSmt2UXlTODh1UkRpc3dIWFNDa1kzelwiO1xuICBOZXR3b3JrSWQyW1wiRVRIRVJFVU1fTUFJTk5FVFwiXSA9IFwiZWlwMTU1OjFcIjtcbiAgTmV0d29ya0lkMltcIkVUSEVSRVVNX1NFUE9MSUFcIl0gPSBcImVpcDE1NToxMTE1NTExMVwiO1xuICBOZXR3b3JrSWQyW1wiUE9MWUdPTl9NQUlOTkVUXCJdID0gXCJlaXAxNTU6MTM3XCI7XG4gIE5ldHdvcmtJZDJbXCJQT0xZR09OX0FNT1lcIl0gPSBcImVpcDE1NTo4MDAwMlwiO1xuICBOZXR3b3JrSWQyW1wiQkFTRV9NQUlOTkVUXCJdID0gXCJlaXAxNTU6ODQ1M1wiO1xuICBOZXR3b3JrSWQyW1wiQkFTRV9TRVBPTElBXCJdID0gXCJlaXAxNTU6ODQ1MzJcIjtcbiAgTmV0d29ya0lkMltcIkFSQklUUlVNX09ORVwiXSA9IFwiZWlwMTU1OjQyMTYxXCI7XG4gIE5ldHdvcmtJZDJbXCJBUkJJVFJVTV9TRVBPTElBXCJdID0gXCJlaXAxNTU6NDIxNjE0XCI7XG4gIE5ldHdvcmtJZDJbXCJNT05BRF9NQUlOTkVUXCJdID0gXCJlaXAxNTU6MTQzXCI7XG4gIE5ldHdvcmtJZDJbXCJNT05BRF9URVNUTkVUXCJdID0gXCJlaXAxNTU6MTAxNDNcIjtcbiAgTmV0d29ya0lkMltcIkJJVENPSU5fTUFJTk5FVFwiXSA9IFwiYmlwMTIyOjAwMDAwMDAwMDAxOWQ2Njg5YzA4NWFlMTY1ODMxZTkzXCI7XG4gIE5ldHdvcmtJZDJbXCJCSVRDT0lOX1RFU1RORVRcIl0gPSBcImJpcDEyMjowMDAwMDAwMDA5MzNlYTAxYWQwZWU5ODQyMDk3NzliYVwiO1xuICBOZXR3b3JrSWQyW1wiU1VJX01BSU5ORVRcIl0gPSBcInN1aTozNTgzNGE4YVwiO1xuICBOZXR3b3JrSWQyW1wiU1VJX1RFU1RORVRcIl0gPSBcInN1aTo0Yzc4YWRhY1wiO1xuICBOZXR3b3JrSWQyW1wiU1VJX0RFVk5FVFwiXSA9IFwic3VpOmRldm5ldFwiO1xuICByZXR1cm4gTmV0d29ya0lkMjtcbn0pKE5ldHdvcmtJZCB8fCB7fSk7XG5cbi8vIHNyYy9uZXR3b3Jrcy50c1xudmFyIE5FVFdPUktfQ09ORklHUyA9IHtcbiAgLy8gU29sYW5hIE5ldHdvcmtzXG4gIFtcInNvbGFuYTo1ZXlrdDRVc0Z2OFA4TkpkVFJFcFkxdnpxS3FaS3ZkcFwiIC8qIFNPTEFOQV9NQUlOTkVUICovXToge1xuICAgIG5hbWU6IFwiU29sYW5hIE1haW5uZXRcIixcbiAgICBjaGFpbjogXCJzb2xhbmFcIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBpbnRlcm5hbENhaXA6IFwic29sYW5hOjEwMVwiLFxuICAgIHNsaXA0NDogXCI1MDFcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJTb2xzY2FuXCIsXG4gICAgICB0cmFuc2FjdGlvblVybDogXCJodHRwczovL3NvbHNjYW4uaW8vdHgve2hhc2h9XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vc29sc2Nhbi5pby9hY2NvdW50L3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICBbXCJzb2xhbmE6RXRXVFJBQlphWXE2aU1mZVlLb3VSdTE2NlZVMnhxYTFcIiAvKiBTT0xBTkFfREVWTkVUICovXToge1xuICAgIG5hbWU6IFwiU29sYW5hIERldm5ldFwiLFxuICAgIGNoYWluOiBcInNvbGFuYVwiLFxuICAgIG5ldHdvcms6IFwiZGV2bmV0XCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcInNvbGFuYToxMDNcIixcbiAgICBzbGlwNDQ6IFwiNTAxXCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiU29sc2NhblwiLFxuICAgICAgdHJhbnNhY3Rpb25Vcmw6IFwiaHR0cHM6Ly9zb2xzY2FuLmlvL3R4L3toYXNofT9jbHVzdGVyPWRldm5ldFwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL3NvbHNjYW4uaW8vYWNjb3VudC97YWRkcmVzc30/Y2x1c3Rlcj1kZXZuZXRcIlxuICAgIH1cbiAgfSxcbiAgW1wic29sYW5hOjR1aGNWSnlVOXBKa3ZReVM4OHVSRGlzd0hYU0NrWTN6XCIgLyogU09MQU5BX1RFU1RORVQgKi9dOiB7XG4gICAgbmFtZTogXCJTb2xhbmEgVGVzdG5ldFwiLFxuICAgIGNoYWluOiBcInNvbGFuYVwiLFxuICAgIG5ldHdvcms6IFwidGVzdG5ldFwiLFxuICAgIGludGVybmFsQ2FpcDogXCJzb2xhbmE6MTAyXCIsXG4gICAgc2xpcDQ0OiBcIjUwMVwiLFxuICAgIGV4cGxvcmVyOiB7XG4gICAgICBuYW1lOiBcIlNvbHNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vc29sc2Nhbi5pby90eC97aGFzaH0/Y2x1c3Rlcj10ZXN0bmV0XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vc29sc2Nhbi5pby9hY2NvdW50L3thZGRyZXNzfT9jbHVzdGVyPXRlc3RuZXRcIlxuICAgIH1cbiAgfSxcbiAgLy8gRXRoZXJldW0gTmV0d29ya3NcbiAgW1wiZWlwMTU1OjFcIiAvKiBFVEhFUkVVTV9NQUlOTkVUICovXToge1xuICAgIG5hbWU6IFwiRXRoZXJldW0gTWFpbm5ldFwiLFxuICAgIGNoYWluOiBcImV0aGVyZXVtXCIsXG4gICAgbmV0d29yazogXCJtYWlubmV0XCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImVpcDE1NToxXCIsXG4gICAgY2hhaW5JZDogMSxcbiAgICBzbGlwNDQ6IFwiNjBcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJFdGhlcnNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vZXRoZXJzY2FuLmlvL3R4L3toYXNofVwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL2V0aGVyc2Nhbi5pby9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICBbXCJlaXAxNTU6MTExNTUxMTFcIiAvKiBFVEhFUkVVTV9TRVBPTElBICovXToge1xuICAgIG5hbWU6IFwiRXRoZXJldW0gU2Vwb2xpYVwiLFxuICAgIGNoYWluOiBcImV0aGVyZXVtXCIsXG4gICAgbmV0d29yazogXCJzZXBvbGlhXCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImVpcDE1NToxMTE1NTExMVwiLFxuICAgIGNoYWluSWQ6IDExMTU1MTExLFxuICAgIHNsaXA0NDogXCI2MFwiLFxuICAgIGV4cGxvcmVyOiB7XG4gICAgICBuYW1lOiBcIkV0aGVyc2NhblwiLFxuICAgICAgdHJhbnNhY3Rpb25Vcmw6IFwiaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby90eC97aGFzaH1cIixcbiAgICAgIGFkZHJlc3NVcmw6IFwiaHR0cHM6Ly9zZXBvbGlhLmV0aGVyc2Nhbi5pby9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICAvLyBQb2x5Z29uIE5ldHdvcmtzXG4gIFtcImVpcDE1NToxMzdcIiAvKiBQT0xZR09OX01BSU5ORVQgKi9dOiB7XG4gICAgbmFtZTogXCJQb2x5Z29uIE1haW5uZXRcIixcbiAgICBjaGFpbjogXCJwb2x5Z29uXCIsXG4gICAgbmV0d29yazogXCJtYWlubmV0XCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImVpcDE1NToxMzdcIixcbiAgICBjaGFpbklkOiAxMzcsXG4gICAgc2xpcDQ0OiBcIjEzN1wiLFxuICAgIGV4cGxvcmVyOiB7XG4gICAgICBuYW1lOiBcIlBvbHlnb25zY2FuXCIsXG4gICAgICB0cmFuc2FjdGlvblVybDogXCJodHRwczovL3BvbHlnb25zY2FuLmNvbS90eC97aGFzaH1cIixcbiAgICAgIGFkZHJlc3NVcmw6IFwiaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20vYWRkcmVzcy97YWRkcmVzc31cIlxuICAgIH1cbiAgfSxcbiAgW1wiZWlwMTU1OjgwMDAyXCIgLyogUE9MWUdPTl9BTU9ZICovXToge1xuICAgIG5hbWU6IFwiUG9seWdvbiBBbW95XCIsXG4gICAgY2hhaW46IFwicG9seWdvblwiLFxuICAgIG5ldHdvcms6IFwiYW1veVwiLFxuICAgIGludGVybmFsQ2FpcDogXCJlaXAxNTU6ODAwMDJcIixcbiAgICBjaGFpbklkOiA4MDAwMixcbiAgICBzbGlwNDQ6IFwiMTM3XCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiUG9seWdvbnNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vYW1veS5wb2x5Z29uc2Nhbi5jb20vdHgve2hhc2h9XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vYW1veS5wb2x5Z29uc2Nhbi5jb20vYWRkcmVzcy97YWRkcmVzc31cIlxuICAgIH1cbiAgfSxcbiAgLy8gQmFzZSBOZXR3b3Jrc1xuICBbXCJlaXAxNTU6ODQ1M1wiIC8qIEJBU0VfTUFJTk5FVCAqL106IHtcbiAgICBuYW1lOiBcIkJhc2UgTWFpbm5ldFwiLFxuICAgIGNoYWluOiBcImJhc2VcIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBpbnRlcm5hbENhaXA6IFwiZWlwMTU1Ojg0NTNcIixcbiAgICBjaGFpbklkOiA4NDUzLFxuICAgIHNsaXA0NDogXCI4NDUzXCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiQmFzZXNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vYmFzZXNjYW4ub3JnL3R4L3toYXNofVwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL2Jhc2VzY2FuLm9yZy9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICBbXCJlaXAxNTU6ODQ1MzJcIiAvKiBCQVNFX1NFUE9MSUEgKi9dOiB7XG4gICAgbmFtZTogXCJCYXNlIFNlcG9saWFcIixcbiAgICBjaGFpbjogXCJiYXNlXCIsXG4gICAgbmV0d29yazogXCJzZXBvbGlhXCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImVpcDE1NTo4NDUzMlwiLFxuICAgIGNoYWluSWQ6IDg0NTMyLFxuICAgIHNsaXA0NDogXCI4NDUzXCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiQmFzZXNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vc2Vwb2xpYS5iYXNlc2Nhbi5vcmcvdHgve2hhc2h9XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vc2Vwb2xpYS5iYXNlc2Nhbi5vcmcvYWRkcmVzcy97YWRkcmVzc31cIlxuICAgIH1cbiAgfSxcbiAgLy8gQXJiaXRydW0gTmV0d29ya3NcbiAgW1wiZWlwMTU1OjQyMTYxXCIgLyogQVJCSVRSVU1fT05FICovXToge1xuICAgIG5hbWU6IFwiQXJiaXRydW0gT25lXCIsXG4gICAgY2hhaW46IFwiYXJiaXRydW1cIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBpbnRlcm5hbENhaXA6IFwiZWlwMTU1OjQyMTYxXCIsXG4gICAgY2hhaW5JZDogNDIxNjEsXG4gICAgc2xpcDQ0OiBcIjQyMTYxXCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiQXJiaXNjYW5cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vYXJiaXNjYW4uaW8vdHgve2hhc2h9XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vYXJiaXNjYW4uaW8vYWRkcmVzcy97YWRkcmVzc31cIlxuICAgIH1cbiAgfSxcbiAgW1wiZWlwMTU1OjQyMTYxNFwiIC8qIEFSQklUUlVNX1NFUE9MSUEgKi9dOiB7XG4gICAgbmFtZTogXCJBcmJpdHJ1bSBTZXBvbGlhXCIsXG4gICAgY2hhaW46IFwiYXJiaXRydW1cIixcbiAgICBuZXR3b3JrOiBcInNlcG9saWFcIixcbiAgICBpbnRlcm5hbENhaXA6IFwiZWlwMTU1OjQyMTYxNFwiLFxuICAgIGNoYWluSWQ6IDQyMTYxNCxcbiAgICBzbGlwNDQ6IFwiNDIxNjFcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJBcmJpc2NhblwiLFxuICAgICAgdHJhbnNhY3Rpb25Vcmw6IFwiaHR0cHM6Ly9zZXBvbGlhLmFyYmlzY2FuLmlvL3R4L3toYXNofVwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL3NlcG9saWEuYXJiaXNjYW4uaW8vYWRkcmVzcy97YWRkcmVzc31cIlxuICAgIH1cbiAgfSxcbiAgLy8gTW9uYWQgTmV0d29ya3NcbiAgW1wiZWlwMTU1OjE0M1wiIC8qIE1PTkFEX01BSU5ORVQgKi9dOiB7XG4gICAgbmFtZTogXCJNb25hZCBNYWlubmV0XCIsXG4gICAgY2hhaW46IFwibW9uYWRcIixcbiAgICBuZXR3b3JrOiBcIm1haW5uZXRcIixcbiAgICBpbnRlcm5hbENhaXA6IFwiZWlwMTU1OjE0M1wiLFxuICAgIGNoYWluSWQ6IDE0MyxcbiAgICBzbGlwNDQ6IFwiNjBcIixcbiAgICAvLyBVc2VzIEV0aGVyZXVtIFNMSVAtNDRcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJNb25hZCBFeHBsb3JlclwiLFxuICAgICAgdHJhbnNhY3Rpb25Vcmw6IFwiaHR0cHM6Ly9tb25hZGV4cGxvcmVyLmNvbS90eC97aGFzaH1cIixcbiAgICAgIGFkZHJlc3NVcmw6IFwiaHR0cHM6Ly9tb25hZGV4cGxvcmVyLmNvbS9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICBbXCJlaXAxNTU6MTAxNDNcIiAvKiBNT05BRF9URVNUTkVUICovXToge1xuICAgIG5hbWU6IFwiTW9uYWQgVGVzdG5ldFwiLFxuICAgIGNoYWluOiBcIm1vbmFkXCIsXG4gICAgbmV0d29yazogXCJ0ZXN0bmV0XCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImVpcDE1NToxMDE0M1wiLFxuICAgIGNoYWluSWQ6IDEwMTQzLFxuICAgIHNsaXA0NDogXCI2MFwiLFxuICAgIC8vIFVzZXMgRXRoZXJldW0gU0xJUC00NFxuICAgIGV4cGxvcmVyOiB7XG4gICAgICBuYW1lOiBcIk1vbmFkIFRlc3RuZXQgRXhwbG9yZXJcIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vdGVzdG5ldC5tb25hZGV4cGxvcmVyLmNvbS90eC97aGFzaH1cIixcbiAgICAgIGFkZHJlc3NVcmw6IFwiaHR0cHM6Ly90ZXN0bmV0Lm1vbmFkZXhwbG9yZXIuY29tL2FkZHJlc3Mve2FkZHJlc3N9XCJcbiAgICB9XG4gIH0sXG4gIC8vIEJpdGNvaW4gTmV0d29ya3MgKGZvciBmdXR1cmUgc3VwcG9ydClcbiAgW1wiYmlwMTIyOjAwMDAwMDAwMDAxOWQ2Njg5YzA4NWFlMTY1ODMxZTkzXCIgLyogQklUQ09JTl9NQUlOTkVUICovXToge1xuICAgIG5hbWU6IFwiQml0Y29pbiBNYWlubmV0XCIsXG4gICAgY2hhaW46IFwiYml0Y29pblwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGludGVybmFsQ2FpcDogXCJiaXAxMjI6MDAwMDAwMDAwMDE5ZDY2ODljMDg1YWUxNjU4MzFlOTNcIixcbiAgICBzbGlwNDQ6IFwiMFwiLFxuICAgIGV4cGxvcmVyOiB7XG4gICAgICBuYW1lOiBcIkJsb2Nrc3RyZWFtXCIsXG4gICAgICB0cmFuc2FjdGlvblVybDogXCJodHRwczovL2Jsb2Nrc3RyZWFtLmluZm8vdHgve2hhc2h9XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vYmxvY2tzdHJlYW0uaW5mby9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICBbXCJiaXAxMjI6MDAwMDAwMDAwOTMzZWEwMWFkMGVlOTg0MjA5Nzc5YmFcIiAvKiBCSVRDT0lOX1RFU1RORVQgKi9dOiB7XG4gICAgbmFtZTogXCJCaXRjb2luIFRlc3RuZXRcIixcbiAgICBjaGFpbjogXCJiaXRjb2luXCIsXG4gICAgbmV0d29yazogXCJ0ZXN0bmV0XCIsXG4gICAgaW50ZXJuYWxDYWlwOiBcImJpcDEyMjowMDAwMDAwMDA5MzNlYTAxYWQwZWU5ODQyMDk3NzliYVwiLFxuICAgIHNsaXA0NDogXCIwXCIsXG4gICAgZXhwbG9yZXI6IHtcbiAgICAgIG5hbWU6IFwiQmxvY2tzdHJlYW1cIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vYmxvY2tzdHJlYW0uaW5mby90ZXN0bmV0L3R4L3toYXNofVwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL2Jsb2Nrc3RyZWFtLmluZm8vdGVzdG5ldC9hZGRyZXNzL3thZGRyZXNzfVwiXG4gICAgfVxuICB9LFxuICAvLyBTdWkgTmV0d29ya3MgKGZvciBmdXR1cmUgc3VwcG9ydClcbiAgW1wic3VpOjM1ODM0YThhXCIgLyogU1VJX01BSU5ORVQgKi9dOiB7XG4gICAgbmFtZTogXCJTdWkgTWFpbm5ldFwiLFxuICAgIGNoYWluOiBcInN1aVwiLFxuICAgIG5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgIGludGVybmFsQ2FpcDogXCJzdWk6bWFpbm5ldFwiLFxuICAgIHNsaXA0NDogXCI3ODRcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJTdWkgRXhwbG9yZXJcIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vZXhwbG9yZXIuc3VpLmlvL3R4YmxvY2sve2hhc2h9P25ldHdvcms9bWFpbm5ldFwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL2V4cGxvcmVyLnN1aS5pby9hZGRyZXNzL3thZGRyZXNzfT9uZXR3b3JrPW1haW5uZXRcIlxuICAgIH1cbiAgfSxcbiAgW1wic3VpOjRjNzhhZGFjXCIgLyogU1VJX1RFU1RORVQgKi9dOiB7XG4gICAgbmFtZTogXCJTdWkgVGVzdG5ldFwiLFxuICAgIGNoYWluOiBcInN1aVwiLFxuICAgIG5ldHdvcms6IFwidGVzdG5ldFwiLFxuICAgIGludGVybmFsQ2FpcDogXCJzdWk6dGVzdG5ldFwiLFxuICAgIHNsaXA0NDogXCI3ODRcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJTdWkgRXhwbG9yZXJcIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vZXhwbG9yZXIuc3VpLmlvL3R4YmxvY2sve2hhc2h9P25ldHdvcms9dGVzdG5ldFwiLFxuICAgICAgYWRkcmVzc1VybDogXCJodHRwczovL2V4cGxvcmVyLnN1aS5pby9hZGRyZXNzL3thZGRyZXNzfT9uZXR3b3JrPXRlc3RuZXRcIlxuICAgIH1cbiAgfSxcbiAgW1wic3VpOmRldm5ldFwiIC8qIFNVSV9ERVZORVQgKi9dOiB7XG4gICAgbmFtZTogXCJTdWkgRGV2bmV0XCIsXG4gICAgY2hhaW46IFwic3VpXCIsXG4gICAgbmV0d29yazogXCJkZXZuZXRcIixcbiAgICBpbnRlcm5hbENhaXA6IFwic3VpOmRldm5ldFwiLFxuICAgIHNsaXA0NDogXCI3ODRcIixcbiAgICBleHBsb3Jlcjoge1xuICAgICAgbmFtZTogXCJTdWkgRXhwbG9yZXJcIixcbiAgICAgIHRyYW5zYWN0aW9uVXJsOiBcImh0dHBzOi8vZXhwbG9yZXIuc3VpLmlvL3R4YmxvY2sve2hhc2h9P25ldHdvcms9ZGV2bmV0XCIsXG4gICAgICBhZGRyZXNzVXJsOiBcImh0dHBzOi8vZXhwbG9yZXIuc3VpLmlvL2FkZHJlc3Mve2FkZHJlc3N9P25ldHdvcms9ZGV2bmV0XCJcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBnZXROZXR3b3JrQ29uZmlnKG5ldHdvcmtJZCkge1xuICByZXR1cm4gTkVUV09SS19DT05GSUdTW25ldHdvcmtJZF07XG59XG5mdW5jdGlvbiBnZXRFeHBsb3JlclVybChuZXR3b3JrSWQsIHR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldE5ldHdvcmtDb25maWcobmV0d29ya0lkKTtcbiAgaWYgKCFjb25maWc/LmV4cGxvcmVyKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlbXBsYXRlID0gdHlwZSA9PT0gXCJ0cmFuc2FjdGlvblwiID8gY29uZmlnLmV4cGxvcmVyLnRyYW5zYWN0aW9uVXJsIDogY29uZmlnLmV4cGxvcmVyLmFkZHJlc3NVcmw7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gdHlwZSA9PT0gXCJ0cmFuc2FjdGlvblwiID8gXCJ7aGFzaH1cIiA6IFwie2FkZHJlc3N9XCI7XG4gIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHBsYWNlaG9sZGVyLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWROZXR3b3JrcygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKE5FVFdPUktfQ09ORklHUyk7XG59XG5mdW5jdGlvbiBnZXROZXR3b3Jrc0J5Q2hhaW4oY2hhaW4pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKE5FVFdPUktfQ09ORklHUykuZmlsdGVyKChbXywgY29uZmlnXSkgPT4gY29uZmlnLmNoYWluID09PSBjaGFpbikubWFwKChbbmV0d29ya0lkXSkgPT4gbmV0d29ya0lkKTtcbn1cbmZ1bmN0aW9uIGNoYWluSWRUb05ldHdvcmtJZChjaGFpbklkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhORVRXT1JLX0NPTkZJR1MpLmZpbmQoKGlkKSA9PiBORVRXT1JLX0NPTkZJR1NbaWRdLmNoYWluSWQgPT09IGNoYWluSWQpO1xufVxuZnVuY3Rpb24gbmV0d29ya0lkVG9DaGFpbklkKG5ldHdvcmtJZCkge1xuICByZXR1cm4gTkVUV09SS19DT05GSUdTW25ldHdvcmtJZF0/LmNoYWluSWQ7XG59XG5mdW5jdGlvbiBuZXR3b3JrSWRUb0ludGVybmFsQ2FpcChuZXR3b3JrSWQpIHtcbiAgY29uc3QgY29uZmlnID0gTkVUV09SS19DT05GSUdTW25ldHdvcmtJZF07XG4gIGlmICghY29uZmlnIHx8ICFjb25maWcuaW50ZXJuYWxDYWlwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbnRlcm5hbCBDQUlQIG1hcHBpbmcgZm91bmQgZm9yIE5ldHdvcmtJZDogJHtuZXR3b3JrSWR9YCk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5pbnRlcm5hbENhaXA7XG59XG5mdW5jdGlvbiBpbnRlcm5hbENhaXBUb05ldHdvcmtJZChpbnRlcm5hbENhaXApIHtcbiAgY29uc3QgbmV0d29ya0lkID0gT2JqZWN0LmtleXMoTkVUV09SS19DT05GSUdTKS5maW5kKFxuICAgIChpZCkgPT4gTkVUV09SS19DT05GSUdTW2lkXS5pbnRlcm5hbENhaXAgPT09IGludGVybmFsQ2FpcFxuICApO1xuICBpZiAoIW5ldHdvcmtJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gTmV0d29ya0lkIG1hcHBpbmcgZm91bmQgZm9yIGludGVybmFsIENBSVA6ICR7aW50ZXJuYWxDYWlwfWApO1xuICB9XG4gIHJldHVybiBuZXR3b3JrSWQ7XG59XG5cbi8vIHNyYy9hbmFseXRpY3MudHNcbnZhciBBTkFMWVRJQ1NfSEVBREVSUyA9IHtcbiAgU0RLX1RZUEU6IFwieC1waGFudG9tLXNkay10eXBlXCIsXG4gIC8vIHNlcnZlciwgYnJvd3Nlci1zZGssIHJlYWN0LW5hdGl2ZS1zZGtcbiAgU0RLX1ZFUlNJT046IFwieC1waGFudG9tLXNkay12ZXJzaW9uXCIsXG4gIC8vIFNESyB2ZXJzaW9uLCBlLmcuIDEuMC4wXG4gIFBMQVRGT1JNOiBcIngtcGhhbnRvbS1wbGF0Zm9ybVwiLFxuICAvLyBmaXJlZm94LCBjaHJvbWUsIHNhZmFyaSwgaW9zLCBhbmRyb2lkLCBldGMuXG4gIFdBTExFVF9UWVBFOiBcIngtcGhhbnRvbS13YWxsZXQtdHlwZVwiLFxuICAvLyBhcHAtd2FsbGV0LCB1c2VyLXdhbGxldFxuICBBUFBfSUQ6IFwieC1hcHAtaWRcIixcbiAgLy8gWW91ciBhcHBsaWNhdGlvbiBJRCBmb3IgaWRlbnRpZnlpbmcgeW91ciBhcHAgaW4gYW5hbHl0aWNzXG4gIFBMQVRGT1JNX1ZFUlNJT046IFwieC1waGFudG9tLXBsYXRmb3JtLXZlcnNpb25cIlxuICAvLyBPUyB2ZXJzaW9uLCBkZXZpY2UgbW9kZWwsIGV0Yy5cbn07XG5cbi8vIHNyYy9lbnZpcm9ubWVudHMudHNcbnZhciBERUZBVUxUX0FVVEhfVVJMID0gXCJodHRwczovL2Nvbm5lY3QucGhhbnRvbS5hcHAvbG9naW5cIjtcbnZhciBERUZBVUxUX1dBTExFVF9BUElfVVJMID0gXCJodHRwczovL2FwaS5waGFudG9tLmFwcC92MS93YWxsZXRzXCI7XG52YXIgREVGQVVMVF9FTUJFRERFRF9XQUxMRVRfVFlQRSA9IFwidXNlci13YWxsZXRcIjtcblxuLy8gc3JjL3Byb3ZpZGVyLW5hbWVzLnRzXG52YXIgUFJPVklERVJfTkFNRVMgPSB7XG4gIGdvb2dsZTogXCJHb29nbGVcIixcbiAgYXBwbGU6IFwiQXBwbGVcIixcbiAgcGhhbnRvbTogXCJQaGFudG9tXCIsXG4gIGRldmljZTogXCJEZXZpY2VcIixcbiAgaW5qZWN0ZWQ6IFwiV2FsbGV0XCIsXG4gIGRlZXBsaW5rOiBcIkRlZXBsaW5rXCJcbn07XG5mdW5jdGlvbiBnZXRQcm92aWRlck5hbWUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIFBST1ZJREVSX05BTUVTW3Byb3ZpZGVyXSB8fCBcIldhbGxldFwiO1xufVxuZXhwb3J0IHtcbiAgQU5BTFlUSUNTX0hFQURFUlMsXG4gIERFRkFVTFRfQVVUSF9VUkwsXG4gIERFRkFVTFRfRU1CRURERURfV0FMTEVUX1RZUEUsXG4gIERFRkFVTFRfV0FMTEVUX0FQSV9VUkwsXG4gIE5FVFdPUktfQ09ORklHUyxcbiAgTmV0d29ya0lkLFxuICBQUk9WSURFUl9OQU1FUyxcbiAgY2hhaW5JZFRvTmV0d29ya0lkLFxuICBnZXRFeHBsb3JlclVybCxcbiAgZ2V0TmV0d29ya0NvbmZpZyxcbiAgZ2V0TmV0d29ya3NCeUNoYWluLFxuICBnZXRQcm92aWRlck5hbWUsXG4gIGdldFN1cHBvcnRlZE5ldHdvcmtzLFxuICBpbnRlcm5hbENhaXBUb05ldHdvcmtJZCxcbiAgbmV0d29ya0lkVG9DaGFpbklkLFxuICBuZXR3b3JrSWRUb0ludGVybmFsQ2FpcFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/constants/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/crypto/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@phantom/crypto/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPairFromSecret: () => (/* binding */ createKeyPairFromSecret),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   signWithSecret: () => (/* binding */ signWithSecret)\n/* harmony export */ });\n/* harmony import */ var tweetnacl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tweetnacl */ \"(ssr)/./node_modules/tweetnacl/nacl-fast.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@phantom/crypto/node_modules/bs58/index.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer */ \"buffer\");\n// src/index.ts\n\n\n\nfunction generateKeyPair() {\n  const keypair = tweetnacl__WEBPACK_IMPORTED_MODULE_0__.sign.keyPair();\n  return {\n    publicKey: bs58__WEBPACK_IMPORTED_MODULE_1__.encode(keypair.publicKey),\n    secretKey: bs58__WEBPACK_IMPORTED_MODULE_1__.encode(keypair.secretKey)\n  };\n}\nfunction createKeyPairFromSecret(b58PrivateKey) {\n  const secretKeyBytes = bs58__WEBPACK_IMPORTED_MODULE_1__.decode(b58PrivateKey);\n  const keypair = tweetnacl__WEBPACK_IMPORTED_MODULE_0__.sign.keyPair.fromSecretKey(secretKeyBytes);\n  return {\n    publicKey: bs58__WEBPACK_IMPORTED_MODULE_1__.encode(keypair.publicKey),\n    secretKey: bs58__WEBPACK_IMPORTED_MODULE_1__.encode(keypair.secretKey)\n  };\n}\nfunction signWithSecret(secretKey, data) {\n  const secretKeyBytes = typeof secretKey === \"string\" ? bs58__WEBPACK_IMPORTED_MODULE_1__.decode(secretKey) : secretKey;\n  let dataBytes;\n  if (typeof data === \"string\") {\n    dataBytes = new TextEncoder().encode(data);\n  } else if (data instanceof buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer) {\n    dataBytes = new Uint8Array(data);\n  } else {\n    dataBytes = data;\n  }\n  return tweetnacl__WEBPACK_IMPORTED_MODULE_0__.sign.detached(dataBytes, secretKeyBytes);\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vY3J5cHRvL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzZCO0FBQ0w7QUFDUTtBQUNoQztBQUNBLGtCQUFrQiwyQ0FBUztBQUMzQjtBQUNBLGVBQWUsd0NBQVc7QUFDMUIsZUFBZSx3Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0NBQVc7QUFDcEMsa0JBQWtCLDJDQUFTO0FBQzNCO0FBQ0EsZUFBZSx3Q0FBVztBQUMxQixlQUFlLHdDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3Q0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QiwwQ0FBTTtBQUNuQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUywyQ0FBUztBQUNsQjtBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL2NyeXB0by9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCBuYWNsIGZyb20gXCJ0d2VldG5hY2xcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZUtleVBhaXIoKSB7XG4gIGNvbnN0IGtleXBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpcigpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleTogYnM1OC5lbmNvZGUoa2V5cGFpci5wdWJsaWNLZXkpLFxuICAgIHNlY3JldEtleTogYnM1OC5lbmNvZGUoa2V5cGFpci5zZWNyZXRLZXkpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlQYWlyRnJvbVNlY3JldChiNThQcml2YXRlS2V5KSB7XG4gIGNvbnN0IHNlY3JldEtleUJ5dGVzID0gYnM1OC5kZWNvZGUoYjU4UHJpdmF0ZUtleSk7XG4gIGNvbnN0IGtleXBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5KHNlY3JldEtleUJ5dGVzKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXk6IGJzNTguZW5jb2RlKGtleXBhaXIucHVibGljS2V5KSxcbiAgICBzZWNyZXRLZXk6IGJzNTguZW5jb2RlKGtleXBhaXIuc2VjcmV0S2V5KVxuICB9O1xufVxuZnVuY3Rpb24gc2lnbldpdGhTZWNyZXQoc2VjcmV0S2V5LCBkYXRhKSB7XG4gIGNvbnN0IHNlY3JldEtleUJ5dGVzID0gdHlwZW9mIHNlY3JldEtleSA9PT0gXCJzdHJpbmdcIiA/IGJzNTguZGVjb2RlKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGxldCBkYXRhQnl0ZXM7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGRhdGFCeXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgZGF0YUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YUJ5dGVzID0gZGF0YTtcbiAgfVxuICByZXR1cm4gbmFjbC5zaWduLmRldGFjaGVkKGRhdGFCeXRlcywgc2VjcmV0S2V5Qnl0ZXMpO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlS2V5UGFpckZyb21TZWNyZXQsXG4gIGdlbmVyYXRlS2V5UGFpcixcbiAgc2lnbldpdGhTZWNyZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/crypto/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/crypto/node_modules/base-x/src/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@phantom/crypto/node_modules/base-x/src/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vY3J5cHRvL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQztBQUMzQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL2NyeXB0by9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/crypto/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/crypto/node_modules/bs58/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@phantom/crypto/node_modules/bs58/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@phantom/crypto/node_modules/base-x/src/index.js\")\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vY3J5cHRvL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxxRkFBUTtBQUM5Qjs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vY3J5cHRvL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/crypto/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/embedded-provider-core/dist/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@phantom/embedded-provider-core/dist/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTHENTICATOR_EXPIRATION_TIME_MS: () => (/* binding */ AUTHENTICATOR_EXPIRATION_TIME_MS),\n/* harmony export */   AUTHENTICATOR_RENEWAL_WINDOW_MS: () => (/* binding */ AUTHENTICATOR_RENEWAL_WINDOW_MS),\n/* harmony export */   EMBEDDED_PROVIDER_AUTH_TYPES: () => (/* binding */ EMBEDDED_PROVIDER_AUTH_TYPES),\n/* harmony export */   EmbeddedEthereumChain: () => (/* binding */ EmbeddedEthereumChain),\n/* harmony export */   EmbeddedProvider: () => (/* binding */ EmbeddedProvider),\n/* harmony export */   EmbeddedSolanaChain: () => (/* binding */ EmbeddedSolanaChain),\n/* harmony export */   generateSessionId: () => (/* binding */ generateSessionId),\n/* harmony export */   retryWithBackoff: () => (/* binding */ retryWithBackoff)\n/* harmony export */ });\n/* harmony import */ var _phantom_base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @phantom/base64url */ \"(ssr)/./node_modules/@phantom/base64url/dist/index.mjs\");\n/* harmony import */ var _phantom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @phantom/client */ \"(ssr)/./node_modules/@phantom/client/dist/index.mjs\");\n/* harmony import */ var _phantom_parsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/parsers */ \"(ssr)/./node_modules/@phantom/parsers/dist/index.mjs\");\n/* harmony import */ var _phantom_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @phantom/utils */ \"(ssr)/./node_modules/@phantom/utils/dist/index.mjs\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/src/esm/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n// src/embedded-provider.ts\n\n\n\n\n\n\n\n// src/constants.ts\nvar AUTHENTICATOR_EXPIRATION_TIME_MS = 7 * 24 * 60 * 60 * 1e3;\nvar AUTHENTICATOR_RENEWAL_WINDOW_MS = 2 * 24 * 60 * 60 * 1e3;\nvar EMBEDDED_PROVIDER_AUTH_TYPES = [\"google\", \"apple\", \"phantom\"];\n\n// src/chains/SolanaChain.ts\n\n\n\n\nvar EmbeddedSolanaChain = class {\n  constructor(provider) {\n    this.provider = provider;\n    this.currentNetworkId = _phantom_constants__WEBPACK_IMPORTED_MODULE_7__.NetworkId.SOLANA_MAINNET;\n    this._connected = false;\n    this._publicKey = null;\n    this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();\n    this.setupEventListeners();\n    this.syncInitialState();\n  }\n  // Wallet adapter compliant properties\n  get connected() {\n    return this._connected;\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  ensureConnected() {\n    if (!this.provider.isConnected()) {\n      throw new Error(\"Solana chain not available. Ensure SDK is connected.\");\n    }\n  }\n  // Standard wallet adapter methods\n  async signMessage(message) {\n    this.ensureConnected();\n    const messageStr = typeof message === \"string\" ? message : new TextDecoder().decode(message);\n    const result = await this.provider.signMessage({\n      message: messageStr,\n      networkId: this.currentNetworkId\n    });\n    const signature = typeof result.signature === \"string\" ? new Uint8Array(bs58__WEBPACK_IMPORTED_MODULE_5__[\"default\"].decode(result.signature)) : result.signature;\n    return {\n      signature,\n      publicKey: this._publicKey || \"\"\n    };\n  }\n  async signTransaction(transaction) {\n    this.ensureConnected();\n    const result = await this.provider.signTransaction({\n      transaction,\n      networkId: this.currentNetworkId\n    });\n    const signedTransaction = (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseSolanaSignedTransaction)(result.rawTransaction);\n    if (!signedTransaction) {\n      throw new Error(\"Failed to parse signed transaction\");\n    }\n    return signedTransaction;\n  }\n  async signAndSendTransaction(transaction) {\n    this.ensureConnected();\n    const result = await this.provider.signAndSendTransaction({\n      transaction,\n      networkId: this.currentNetworkId\n    });\n    if (!result.hash) {\n      throw new Error(\"Transaction not submitted\");\n    }\n    return { signature: result.hash };\n  }\n  async signAllTransactions(transactions) {\n    this.ensureConnected();\n    const results = await Promise.all(transactions.map((tx) => this.signTransaction(tx)));\n    return results;\n  }\n  async signAndSendAllTransactions(transactions) {\n    const results = await Promise.all(transactions.map((tx) => this.signAndSendTransaction(tx)));\n    return { signatures: results.map((result) => result.signature) };\n  }\n  connect(_options) {\n    if (!this.provider.isConnected()) {\n      throw new Error(\"Provider not connected. Call provider connect first.\");\n    }\n    const addresses = this.provider.getAddresses();\n    const solanaAddr = addresses.find((a) => a.addressType === \"Solana\");\n    if (!solanaAddr)\n      throw new Error(\"No Solana address found\");\n    this.updateConnectionState(true, solanaAddr.address);\n    return Promise.resolve({ publicKey: solanaAddr.address });\n  }\n  async disconnect() {\n    return this.provider.disconnect();\n  }\n  switchNetwork(network) {\n    this.currentNetworkId = network === \"mainnet\" ? _phantom_constants__WEBPACK_IMPORTED_MODULE_7__.NetworkId.SOLANA_MAINNET : _phantom_constants__WEBPACK_IMPORTED_MODULE_7__.NetworkId.SOLANA_DEVNET;\n    return Promise.resolve();\n  }\n  getPublicKey() {\n    if (!this.provider.isConnected())\n      return Promise.resolve(null);\n    const addresses = this.provider.getAddresses();\n    const solanaAddr = addresses.find((a) => a.addressType === \"Solana\");\n    return Promise.resolve(solanaAddr?.address || null);\n  }\n  isConnected() {\n    return this._connected && this.provider.isConnected();\n  }\n  setupEventListeners() {\n    this.provider.on(\"connect\", (data) => {\n      const solanaAddress = data.addresses?.find((addr) => addr.addressType === \"Solana\");\n      if (solanaAddress) {\n        this.updateConnectionState(true, solanaAddress.address);\n        this.eventEmitter.emit(\"connect\", solanaAddress.address);\n      }\n    });\n    this.provider.on(\"disconnect\", () => {\n      this.updateConnectionState(false, null);\n      this.eventEmitter.emit(\"disconnect\");\n    });\n  }\n  syncInitialState() {\n    if (this.provider.isConnected()) {\n      const addresses = this.provider.getAddresses();\n      const solanaAddress = addresses.find((a) => a.addressType === \"Solana\");\n      if (solanaAddress) {\n        this.updateConnectionState(true, solanaAddress.address);\n      }\n    }\n  }\n  updateConnectionState(connected, publicKey) {\n    this._connected = connected;\n    this._publicKey = publicKey;\n  }\n  // Event methods for interface compliance\n  on(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n  }\n};\n\n// src/chains/EthereumChain.ts\n\n\nvar EmbeddedEthereumChain = class {\n  constructor(provider) {\n    this.provider = provider;\n    this.currentNetworkId = _phantom_constants__WEBPACK_IMPORTED_MODULE_7__.NetworkId.ETHEREUM_MAINNET;\n    this._connected = false;\n    this._accounts = [];\n    this.eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__.EventEmitter();\n    this.setupEventListeners();\n    this.syncInitialState();\n  }\n  // EIP-1193 compliant properties\n  get connected() {\n    return this._connected;\n  }\n  get chainId() {\n    const chainId = (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.networkIdToChainId)(this.currentNetworkId) || 1;\n    return `0x${chainId.toString(16)}`;\n  }\n  get accounts() {\n    return this._accounts;\n  }\n  ensureConnected() {\n    if (!this.provider.isConnected()) {\n      throw new Error(\"Ethereum chain not available. Ensure SDK is connected.\");\n    }\n  }\n  async request(args) {\n    this.ensureConnected();\n    return this.handleEmbeddedRequest(args);\n  }\n  // Connection methods\n  connect() {\n    if (!this.provider.isConnected()) {\n      throw new Error(\"Provider not connected. Call provider connect first.\");\n    }\n    const addresses = this.provider.getAddresses();\n    const ethAddresses = addresses.filter((a) => a.addressType === \"Ethereum\").map((a) => a.address);\n    this.updateConnectionState(true, ethAddresses);\n    return Promise.resolve(ethAddresses);\n  }\n  async disconnect() {\n    await this.provider.disconnect();\n  }\n  // Standard compliant methods (return raw values)\n  async signPersonalMessage(message, address) {\n    return await this.request({\n      method: \"personal_sign\",\n      params: [message, address]\n    });\n  }\n  async signTypedData(typedData, address) {\n    return await this.request({\n      method: \"eth_signTypedData_v4\",\n      params: [address, JSON.stringify(typedData)]\n    });\n  }\n  async signTransaction(transaction) {\n    let networkId = this.currentNetworkId;\n    if (transaction.chainId) {\n      const numericChainId = typeof transaction.chainId === \"number\" ? transaction.chainId : parseInt(transaction.chainId, 16);\n      const txNetworkId = (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.chainIdToNetworkId)(numericChainId);\n      if (txNetworkId) {\n        networkId = txNetworkId;\n      }\n    }\n    const result = await this.provider.signTransaction({\n      transaction,\n      networkId\n    });\n    return result.rawTransaction;\n  }\n  async sendTransaction(transaction) {\n    if (transaction.chainId) {\n      const numericChainId = typeof transaction.chainId === \"number\" ? transaction.chainId : parseInt(transaction.chainId, 16);\n      await this.switchChain(numericChainId);\n    }\n    const result = await this.provider.signAndSendTransaction({\n      transaction,\n      networkId: this.currentNetworkId\n    });\n    if (!result.hash) {\n      throw new Error(\"Transaction not submitted\");\n    }\n    return result.hash;\n  }\n  switchChain(chainId) {\n    const numericChainId = typeof chainId === \"string\" ? chainId.toLowerCase().startsWith(\"0x\") ? parseInt(chainId, 16) : parseInt(chainId, 10) : chainId;\n    const networkId = (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.chainIdToNetworkId)(numericChainId);\n    if (!networkId) {\n      throw new Error(`Unsupported chainId: ${chainId}`);\n    }\n    this.currentNetworkId = networkId;\n    this.eventEmitter.emit(\"chainChanged\", `0x${numericChainId.toString(16)}`);\n    return Promise.resolve();\n  }\n  getChainId() {\n    const chainId = (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.networkIdToChainId)(this.currentNetworkId);\n    return Promise.resolve(chainId || 1);\n  }\n  async getAccounts() {\n    return this.request({ method: \"eth_accounts\" });\n  }\n  isConnected() {\n    return this._connected && this.provider.isConnected();\n  }\n  setupEventListeners() {\n    this.provider.on(\"connect\", (data) => {\n      const ethAddresses = data.addresses?.filter((addr) => addr.addressType === \"Ethereum\")?.map((addr) => addr.address) || [];\n      if (ethAddresses.length > 0) {\n        this.updateConnectionState(true, ethAddresses);\n        this.eventEmitter.emit(\"connect\", { chainId: this.chainId });\n        this.eventEmitter.emit(\"accountsChanged\", ethAddresses);\n      }\n    });\n    this.provider.on(\"disconnect\", () => {\n      this.updateConnectionState(false, []);\n      this.eventEmitter.emit(\"disconnect\", { code: 4900, message: \"Provider disconnected\" });\n      this.eventEmitter.emit(\"accountsChanged\", []);\n    });\n  }\n  syncInitialState() {\n    if (this.provider.isConnected()) {\n      const addresses = this.provider.getAddresses();\n      const ethAddresses = addresses.filter((a) => a.addressType === \"Ethereum\").map((a) => a.address);\n      if (ethAddresses.length > 0) {\n        this.updateConnectionState(true, ethAddresses);\n      }\n    }\n  }\n  updateConnectionState(connected, accounts) {\n    this._connected = connected;\n    this._accounts = accounts;\n  }\n  async handleEmbeddedRequest(args) {\n    switch (args.method) {\n      case \"personal_sign\": {\n        const [message, _address] = args.params;\n        const result = await this.provider.signEthereumMessage({\n          message,\n          networkId: this.currentNetworkId\n        });\n        return result.signature;\n      }\n      case \"eth_signTypedData_v4\": {\n        const [_typedDataAddress, typedDataStr] = args.params;\n        const typedData = JSON.parse(typedDataStr);\n        const typedDataResult = await this.provider.signTypedDataV4({\n          typedData,\n          networkId: this.currentNetworkId\n        });\n        return typedDataResult.signature;\n      }\n      case \"eth_signTransaction\": {\n        const [transaction] = args.params;\n        const networkIdFromTx = transaction.chainId ? (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.chainIdToNetworkId)(\n          typeof transaction.chainId === \"number\" ? transaction.chainId : parseInt(transaction.chainId, 16)\n        ) : null;\n        const signResult = await this.provider.signTransaction({\n          transaction,\n          networkId: networkIdFromTx || this.currentNetworkId\n        });\n        return signResult.rawTransaction;\n      }\n      case \"eth_sendTransaction\": {\n        const [transaction] = args.params;\n        const networkIdFromTx = transaction.chainId ? (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.chainIdToNetworkId)(\n          typeof transaction.chainId === \"number\" ? transaction.chainId : parseInt(transaction.chainId, 16)\n        ) : null;\n        const sendResult = await this.provider.signAndSendTransaction({\n          transaction,\n          networkId: networkIdFromTx || this.currentNetworkId\n        });\n        return sendResult.hash;\n      }\n      case \"eth_accounts\": {\n        const addresses = this.provider.getAddresses();\n        const ethAddr = addresses.find((a) => a.addressType === \"Ethereum\");\n        return ethAddr ? [ethAddr.address] : [];\n      }\n      case \"eth_chainId\": {\n        return `0x${((0,_phantom_constants__WEBPACK_IMPORTED_MODULE_7__.networkIdToChainId)(this.currentNetworkId) || 1).toString(16)}`;\n      }\n      case \"wallet_switchEthereumChain\": {\n        const [{ chainId }] = args.params;\n        const numericChainId = parseInt(chainId, 16);\n        await this.switchChain(numericChainId);\n        return void 0;\n      }\n      default:\n        throw new Error(`Embedded provider doesn't support method: ${args.method}`);\n    }\n  }\n  // Event methods for interface compliance\n  on(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n  off(event, listener) {\n    this.eventEmitter.off(event, listener);\n  }\n};\n\n// src/utils/retry.ts\nasync function retryWithBackoff(operation, operationName, logger, maxRetries = 3, baseDelay = 1e3) {\n  let lastError;\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      logger.log(\"EMBEDDED_PROVIDER\", `Attempting ${operationName}`, {\n        attempt,\n        maxRetries\n      });\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      logger.warn(\"EMBEDDED_PROVIDER\", `${operationName} failed`, {\n        attempt,\n        maxRetries,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      if (attempt === maxRetries) {\n        logger.error(\"EMBEDDED_PROVIDER\", `${operationName} failed after ${maxRetries} attempts`, {\n          finalError: error instanceof Error ? error.message : String(error)\n        });\n        break;\n      }\n      const delay = baseDelay * Math.pow(2, attempt - 1);\n      logger.log(\"EMBEDDED_PROVIDER\", `Retrying ${operationName} in ${delay}ms`, {\n        attempt: attempt + 1,\n        delay\n      });\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n  throw lastError;\n}\n\n// src/utils/session.ts\nfunction generateSessionId() {\n  return \"session_\" + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + \"_\" + Date.now();\n}\n\n// src/embedded-provider.ts\nvar EmbeddedProvider = class {\n  constructor(config, platform, logger) {\n    this.client = null;\n    this.walletId = null;\n    this.addresses = [];\n    this.eventListeners = /* @__PURE__ */ new Map();\n    this.logger = logger;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Initializing EmbeddedProvider\", { config });\n    if (config.embeddedWalletType === \"app-wallet\") {\n      throw new Error(\"app-wallet type is not currently supported. Please use 'user-wallet' instead.\");\n    }\n    this.config = config;\n    this.platform = platform;\n    this.storage = platform.storage;\n    this.authProvider = platform.authProvider;\n    this.phantomAppProvider = platform.phantomAppProvider;\n    this.urlParamsAccessor = platform.urlParamsAccessor;\n    this.stamper = platform.stamper;\n    this.solana = new EmbeddedSolanaChain(this);\n    this.ethereum = new EmbeddedEthereumChain(this);\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"EmbeddedProvider initialized\");\n  }\n  /*\n   * Event system methods for listening to provider state changes\n   */\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, /* @__PURE__ */ new Set());\n    }\n    this.eventListeners.get(event)?.add(callback);\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Event listener added\", { event });\n  }\n  off(event, callback) {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.delete(callback);\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Event listener removed\", { event });\n    }\n  }\n  emit(event, data) {\n    const listeners = this.eventListeners.get(event);\n    if (listeners && listeners.size > 0) {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Emitting event\", { event, listenerCount: listeners.size, data });\n      listeners.forEach((callback) => {\n        try {\n          callback(data);\n        } catch (error) {\n          this.logger.error(\"EMBEDDED_PROVIDER\", \"Event callback error\", { event, error });\n        }\n      });\n    }\n  }\n  /**\n   * Get the appropriate address for a given network ID from available addresses\n   */\n  getAddressForNetwork(networkId) {\n    const network = networkId.split(\":\")[0].toLowerCase();\n    let targetAddressType;\n    switch (network) {\n      case \"solana\":\n        targetAddressType = _phantom_client__WEBPACK_IMPORTED_MODULE_1__.AddressType.solana;\n        break;\n      case \"eip155\":\n        targetAddressType = _phantom_client__WEBPACK_IMPORTED_MODULE_1__.AddressType.ethereum;\n        break;\n      case \"bitcoin\":\n      case \"btc\":\n        targetAddressType = _phantom_client__WEBPACK_IMPORTED_MODULE_1__.AddressType.bitcoinSegwit;\n        break;\n      case \"sui\":\n        targetAddressType = _phantom_client__WEBPACK_IMPORTED_MODULE_1__.AddressType.sui;\n        break;\n      default:\n        targetAddressType = _phantom_client__WEBPACK_IMPORTED_MODULE_1__.AddressType.ethereum;\n        break;\n    }\n    const matchingAddress = this.addresses.find(\n      (addr) => addr.addressType.toLowerCase() === targetAddressType.toLowerCase()\n    );\n    return matchingAddress?.address;\n  }\n  async getAndFilterWalletAddresses(walletId) {\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    const addresses = await retryWithBackoff(\n      () => this.client.getWalletAddresses(walletId, void 0, derivationIndex),\n      \"getWalletAddresses\",\n      this.logger\n    ).catch(async (error) => {\n      this.logger.error(\"EMBEDDED_PROVIDER\", \"getWalletAddresses failed after retries, disconnecting\", {\n        walletId,\n        error: error.message,\n        derivationIndex\n      });\n      await this.storage.clearSession();\n      this.client = null;\n      this.walletId = null;\n      this.addresses = [];\n      throw error;\n    });\n    return addresses.filter((addr) => this.config.addressTypes.some((type) => type === addr.addressType));\n  }\n  /*\n   * We use this method to make sure the session is not invalid, or there's a different session id in the url.\n   * If there's a different one, we delete the current session and start from scratch.\n   * This prevents issues where users have stale sessions or URL mismatches after redirects.\n   */\n  async validateAndCleanSession(session) {\n    if (!session)\n      return null;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Found existing session, validating\", {\n      sessionId: session.sessionId,\n      status: session.status,\n      walletId: session.walletId\n    });\n    if (session.status !== \"completed\") {\n      const urlSessionId = this.urlParamsAccessor.getParam(\"session_id\");\n      if (session.status === \"pending\" && !urlSessionId) {\n        this.logger.warn(\"EMBEDDED_PROVIDER\", \"Session mismatch detected - pending session without redirect context\", {\n          sessionId: session.sessionId,\n          status: session.status\n        });\n        await this.storage.clearSession();\n        return null;\n      } else if (urlSessionId && urlSessionId !== session.sessionId) {\n        this.logger.warn(\"EMBEDDED_PROVIDER\", \"Session ID mismatch detected\", {\n          storedSessionId: session.sessionId,\n          urlSessionId\n        });\n        await this.storage.clearSession();\n        return null;\n      }\n    }\n    if (session.status === \"completed\" && !this.isSessionValid(session)) {\n      this.logger.warn(\n        \"EMBEDDED_PROVIDER\",\n        \"Session invalid due to authenticator expiration, will regenerate keypair\",\n        {\n          sessionId: session.sessionId,\n          authenticatorExpiresAt: session.authenticatorExpiresAt,\n          currentTime: Date.now(),\n          expired: session.authenticatorExpiresAt < Date.now()\n        }\n      );\n      await this.storage.clearSession();\n      return null;\n    }\n    return session;\n  }\n  /*\n   * Shared connection logic for both connect() and autoConnect().\n   * Handles existing session validation, redirect resume, and session initialization.\n   * Returns ConnectResult if connection succeeds, null if should continue with new auth flow.\n   */\n  async tryExistingConnection(isAutoConnect) {\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Getting existing session\");\n    let session = await this.storage.getSession();\n    session = await this.validateAndCleanSession(session);\n    if (!session) {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"No existing session found\");\n      return null;\n    }\n    if (session.status === \"completed\") {\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Using existing completed session\", {\n        sessionId: session.sessionId,\n        walletId: session.walletId\n      });\n      await this.initializeClientFromSession(session);\n      session.lastUsed = Date.now();\n      await this.storage.saveSession(session);\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Connection from existing session successful\", {\n        walletId: this.walletId,\n        addressCount: this.addresses.length\n      });\n      await this.ensureValidAuthenticator();\n      const result = {\n        walletId: this.walletId,\n        addresses: this.addresses,\n        status: \"completed\",\n        authUserId: session.authUserId,\n        authProvider: session.authProvider\n      };\n      this.emit(\"connect\", {\n        ...result,\n        source: \"existing-session\"\n      });\n      return result;\n    }\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"No completed session found, checking for redirect resume\");\n    if (this.authProvider.resumeAuthFromRedirect) {\n      const authResult = this.authProvider.resumeAuthFromRedirect(session.authProvider);\n      if (authResult) {\n        this.logger.info(\"EMBEDDED_PROVIDER\", \"Resuming from redirect\", {\n          walletId: authResult.walletId,\n          provider: authResult.provider\n        });\n        try {\n          return await this.completeAuthConnection(authResult);\n        } catch (error) {\n          if (error instanceof Error && error.message.includes(\"No session found after redirect\") && !isAutoConnect) {\n            this.logger.warn(\n              \"EMBEDDED_PROVIDER\",\n              \"Session missing during redirect resume - will start fresh auth flow\",\n              {\n                error: error.message,\n                walletId: authResult.walletId\n              }\n            );\n            await this.storage.clearSession();\n            return null;\n          }\n          throw error;\n        }\n      }\n    }\n    return null;\n  }\n  /*\n   * We use this method to validate authentication options before processing them.\n   * This ensures only supported auth providers are used and required tokens are present.\n   */\n  validateAuthOptions(authOptions) {\n    if (!EMBEDDED_PROVIDER_AUTH_TYPES.includes(authOptions.provider)) {\n      throw new Error(\n        `Invalid auth provider: ${authOptions.provider}. Must be ${EMBEDDED_PROVIDER_AUTH_TYPES.join(\", \")}`\n      );\n    }\n  }\n  /*\n   * We use this method to validate if a session is still valid.\n   * This checks session status, required fields, and authenticator expiration.\n   * Sessions never expire by age - only authenticators expire.\n   */\n  isSessionValid(session) {\n    if (!session) {\n      return false;\n    }\n    if (!session.walletId || !session.organizationId || !session.stamperInfo) {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Session missing required fields\", {\n        hasWalletId: !!session.walletId,\n        hasOrganizationId: !!session.organizationId,\n        hasStamperInfo: !!session.stamperInfo\n      });\n      return false;\n    }\n    if (session.status !== \"completed\") {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Session not completed\", { status: session.status });\n      return false;\n    }\n    if (!session.authenticatorExpiresAt) {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Session invalid - missing authenticator timing\", {\n        sessionId: session.sessionId\n      });\n      return false;\n    }\n    if (Date.now() >= session.authenticatorExpiresAt) {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Authenticator expired, session invalid\", {\n        authenticatorExpiresAt: new Date(session.authenticatorExpiresAt).toISOString(),\n        now: (/* @__PURE__ */ new Date()).toISOString()\n      });\n      return false;\n    }\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Session is valid\", {\n      sessionId: session.sessionId,\n      walletId: session.walletId,\n      authenticatorExpires: new Date(session.authenticatorExpiresAt).toISOString()\n    });\n    return true;\n  }\n  /*\n   * Public method to attempt auto-connection using an existing valid session.\n   * This should be called after setting up event listeners to avoid race conditions.\n   * Silently fails if no valid session exists, enabling seamless reconnection.\n   */\n  async autoConnect() {\n    try {\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Starting auto-connect attempt\");\n      this.emit(\"connect_start\", { source: \"auto-connect\" });\n      const result = await this.tryExistingConnection(true);\n      if (result) {\n        this.logger.info(\"EMBEDDED_PROVIDER\", \"Auto-connect successful\", {\n          walletId: result.walletId,\n          addressCount: result.addresses.length\n        });\n        this.emit(\"connect\", {\n          ...result,\n          source: \"auto-connect\"\n        });\n        return;\n      }\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Auto-connect failed: no valid session found\");\n      this.emit(\"connect_error\", {\n        error: \"No valid session found\",\n        source: \"auto-connect\"\n      });\n    } catch (error) {\n      this.logger.error(\"EMBEDDED_PROVIDER\", \"Auto-connect failed\", {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      this.emit(\"connect_error\", {\n        error: error instanceof Error ? error.message : \"Auto-connect failed\",\n        source: \"auto-connect\"\n      });\n      await this.storage.setShouldClearPreviousSession(true);\n    }\n  }\n  /*\n   * We use this method to initialize the stamper and create an organization for new sessions.\n   * This is the first step when no existing session is found and we need to set up a new wallet.\n   */\n  async initializeStamper() {\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Initializing stamper\");\n    await this.stamper.init();\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Resetting keypair to avoid conflicts with existing keypairs\");\n    const stamperInfo = await this.stamper.resetKeyPair();\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Stamper initialized with fresh keypair\", {\n      publicKey: stamperInfo.publicKey,\n      keyId: stamperInfo.keyId,\n      algorithm: this.stamper.algorithm\n    });\n    const expiresInMs = AUTHENTICATOR_EXPIRATION_TIME_MS;\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Stamper ready for auth flow with fresh keypair\", {\n      publicKey: stamperInfo.publicKey,\n      keyId: stamperInfo.keyId\n    });\n    return { stamperInfo, expiresInMs };\n  }\n  async createOrganizationForAppWallet(stamperInfo, expiresInMs) {\n    const tempClient = new _phantom_client__WEBPACK_IMPORTED_MODULE_1__.PhantomClient({\n      apiBaseUrl: this.config.apiBaseUrl,\n      headers: {\n        ...this.platform.analyticsHeaders || {}\n      }\n    });\n    const platformName = this.platform.name || \"unknown\";\n    const shortPubKey = stamperInfo.publicKey.slice(0, 8);\n    const organizationName = `${this.config.appId.substring(0, 8)}-${platformName}-${shortPubKey}`;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Creating organization for app-wallet\", {\n      organizationName,\n      publicKey: stamperInfo.publicKey,\n      platform: platformName\n    });\n    const base64urlPublicKey = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(bs58__WEBPACK_IMPORTED_MODULE_5__[\"default\"].decode(stamperInfo.publicKey));\n    const username = `user-${(0,_phantom_utils__WEBPACK_IMPORTED_MODULE_3__.randomUUID)()}`;\n    const { organizationId } = await tempClient.createOrganization(organizationName, [\n      {\n        username,\n        role: \"ADMIN\",\n        authenticators: [\n          {\n            authenticatorName: `auth-${shortPubKey}`,\n            authenticatorKind: \"keypair\",\n            publicKey: base64urlPublicKey,\n            algorithm: \"Ed25519\",\n            expiresInMs\n          }\n        ]\n      }\n    ]);\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Organization created for app-wallet\", { organizationId });\n    return organizationId;\n  }\n  async connect(authOptions) {\n    try {\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Starting embedded provider connect\", {\n        authOptions: {\n          provider: authOptions.provider\n        }\n      });\n      this.emit(\"connect_start\", {\n        source: \"manual-connect\",\n        authOptions: { provider: authOptions.provider }\n      });\n      const existingResult = await this.tryExistingConnection(false);\n      if (existingResult) {\n        this.logger.info(\"EMBEDDED_PROVIDER\", \"Manual connect using existing connection\", {\n          walletId: existingResult.walletId,\n          addressCount: existingResult.addresses.length\n        });\n        this.emit(\"connect\", {\n          ...existingResult,\n          source: \"manual-existing\"\n        });\n        return existingResult;\n      }\n      this.validateAuthOptions(authOptions);\n      this.logger.info(\n        \"EMBEDDED_PROVIDER\",\n        \"No existing connection available, creating new auth flow with fresh keypair\"\n      );\n      const { stamperInfo, expiresInMs } = await this.initializeStamper();\n      const session = await this.handleAuthFlow(stamperInfo.publicKey, stamperInfo, authOptions, expiresInMs);\n      if (!session) {\n        return {\n          addresses: [],\n          status: \"pending\",\n          authProvider: authOptions.provider\n        };\n      }\n      if (this.config.embeddedWalletType === \"app-wallet\") {\n        session.lastUsed = Date.now();\n        await this.storage.saveSession(session);\n      }\n      await this.initializeClientFromSession(session);\n      await this.ensureValidAuthenticator();\n      const result = {\n        walletId: this.walletId,\n        addresses: this.addresses,\n        status: \"completed\",\n        authUserId: session?.authUserId,\n        authProvider: session?.authProvider\n      };\n      this.emit(\"connect\", {\n        ...result,\n        source: \"manual\"\n      });\n      return result;\n    } catch (error) {\n      this.logger.error(\"EMBEDDED_PROVIDER\", \"Connect failed with error\", {\n        error: error instanceof Error ? {\n          name: error.name,\n          message: error.message,\n          stack: error.stack\n        } : error\n      });\n      this.emit(\"connect_error\", {\n        error: error instanceof Error ? error.message : String(error),\n        source: \"manual-connect\"\n      });\n      if (error instanceof Error) {\n        if (error.message.includes(\"IndexedDB\") || error.message.includes(\"storage\")) {\n          throw new Error(\n            \"Storage error: Unable to access browser storage. Please ensure storage is available and try again.\"\n          );\n        }\n        if (error.message.includes(\"network\") || error.message.includes(\"fetch\")) {\n          throw new Error(\n            \"Network error: Unable to connect to authentication server. Please check your internet connection and try again.\"\n          );\n        }\n        if (error.message.includes(\"JWT\") || error.message.includes(\"jwt\")) {\n          throw new Error(`JWT Authentication error: ${error.message}`);\n        }\n        if (error.message.includes(\"Authentication\") || error.message.includes(\"auth\")) {\n          throw new Error(`Authentication error: ${error.message}`);\n        }\n        if (error.message.includes(\"organization\") || error.message.includes(\"wallet\")) {\n          throw new Error(`Wallet creation error: ${error.message}`);\n        }\n        throw error;\n      }\n      throw new Error(`Embedded wallet connection failed: ${String(error)}`);\n    }\n  }\n  async disconnect(shouldClearPreviousSession = true) {\n    const wasConnected = this.client !== null;\n    await this.storage.setShouldClearPreviousSession(shouldClearPreviousSession);\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Set flag to clear previous session on next login\");\n    await this.storage.clearSession();\n    this.client = null;\n    this.walletId = null;\n    this.addresses = [];\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Disconnected from embedded wallet\");\n    if (wasConnected) {\n      this.emit(\"disconnect\", {\n        source: \"manual\"\n      });\n    }\n  }\n  async signMessage(params) {\n    if (!this.client || !this.walletId) {\n      throw new Error(\"Not connected\");\n    }\n    await this.ensureValidAuthenticator();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Signing message\", {\n      walletId: this.walletId,\n      message: params.message\n    });\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    const rawResponse = await this.client.signUtf8Message({\n      walletId: this.walletId,\n      message: params.message,\n      networkId: params.networkId,\n      derivationIndex\n    });\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Message signed successfully\", {\n      walletId: this.walletId,\n      message: params.message\n    });\n    return (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseSignMessageResponse)(rawResponse, params.networkId);\n  }\n  async signEthereumMessage(params) {\n    if (!this.client || !this.walletId) {\n      throw new Error(\"Not connected\");\n    }\n    await this.ensureValidAuthenticator();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Signing message\", {\n      walletId: this.walletId,\n      message: params.message\n    });\n    const looksLikeHex = (str) => /^0x[0-9a-fA-F]+$/.test(str);\n    const normalizedMessage = (() => {\n      if (looksLikeHex(params.message)) {\n        const hexPayload = params.message.slice(2);\n        const normalizedHex = hexPayload.length % 2 === 0 ? hexPayload : `0${hexPayload}`;\n        return buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(normalizedHex, \"hex\").toString(\"utf8\");\n      }\n      return params.message;\n    })();\n    const base64UrlMessage = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.stringToBase64url)(normalizedMessage);\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    const rawResponse = await this.client.ethereumSignMessage({\n      walletId: this.walletId,\n      message: base64UrlMessage,\n      networkId: params.networkId,\n      derivationIndex\n    });\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Message signed successfully\", {\n      walletId: this.walletId,\n      message: params.message\n    });\n    return (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseSignMessageResponse)(rawResponse, params.networkId);\n  }\n  async signTypedDataV4(params) {\n    if (!this.client || !this.walletId) {\n      throw new Error(\"Not connected\");\n    }\n    await this.ensureValidAuthenticator();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Signing typed data\", {\n      walletId: this.walletId,\n      typedData: params.typedData\n    });\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    const rawResponse = await this.client.ethereumSignTypedData({\n      walletId: this.walletId,\n      typedData: params.typedData,\n      networkId: params.networkId,\n      derivationIndex\n    });\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Typed data signed successfully\", {\n      walletId: this.walletId\n    });\n    return (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseSignMessageResponse)(rawResponse, params.networkId);\n  }\n  async signTransaction(params) {\n    if (!this.client || !this.walletId) {\n      throw new Error(\"Not connected\");\n    }\n    await this.ensureValidAuthenticator();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Signing transaction\", {\n      walletId: this.walletId,\n      networkId: params.networkId\n    });\n    const parsedTransaction = await (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseToKmsTransaction)(params.transaction, params.networkId);\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Parsed transaction for signing\", {\n      walletId: this.walletId,\n      transaction: parsedTransaction,\n      derivationIndex\n    });\n    const transactionPayload = parsedTransaction.parsed;\n    if (!transactionPayload) {\n      throw new Error(\"Failed to parse transaction: no valid encoding found\");\n    }\n    const account = this.getAddressForNetwork(params.networkId);\n    if (!account) {\n      throw new Error(`No address found for network ${params.networkId}`);\n    }\n    const rawResponse = await this.client.signTransaction({\n      walletId: this.walletId,\n      transaction: transactionPayload,\n      networkId: params.networkId,\n      derivationIndex,\n      account\n    });\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Transaction signed successfully\", {\n      walletId: this.walletId,\n      networkId: params.networkId,\n      rawTransaction: rawResponse.rawTransaction\n    });\n    return await (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseTransactionResponse)(rawResponse.rawTransaction, params.networkId);\n  }\n  async signAndSendTransaction(params) {\n    if (!this.client || !this.walletId) {\n      throw new Error(\"Not connected\");\n    }\n    await this.ensureValidAuthenticator();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Signing and sending transaction\", {\n      walletId: this.walletId,\n      networkId: params.networkId\n    });\n    const parsedTransaction = await (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseToKmsTransaction)(params.transaction, params.networkId);\n    const session = await this.storage.getSession();\n    const derivationIndex = session?.accountDerivationIndex ?? 0;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Parsed transaction for signing\", {\n      walletId: this.walletId,\n      transaction: parsedTransaction,\n      derivationIndex\n    });\n    const transactionPayload = parsedTransaction.parsed;\n    if (!transactionPayload) {\n      throw new Error(\"Failed to parse transaction: no valid encoding found\");\n    }\n    const account = this.getAddressForNetwork(params.networkId);\n    if (!account) {\n      throw new Error(`No address found for network ${params.networkId}`);\n    }\n    let rawResponse;\n    try {\n      rawResponse = await this.client.signAndSendTransaction({\n        walletId: this.walletId,\n        transaction: transactionPayload,\n        networkId: params.networkId,\n        derivationIndex,\n        account\n      });\n    } catch (error) {\n      if (error instanceof _phantom_client__WEBPACK_IMPORTED_MODULE_1__.SpendingLimitError) {\n        this.emit(\"spending_limit_reached\", { error });\n      }\n      throw error;\n    }\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Transaction signed and sent successfully\", {\n      walletId: this.walletId,\n      networkId: params.networkId,\n      hash: rawResponse.hash,\n      rawTransaction: rawResponse.rawTransaction\n    });\n    return await (0,_phantom_parsers__WEBPACK_IMPORTED_MODULE_2__.parseTransactionResponse)(rawResponse.rawTransaction, params.networkId, rawResponse.hash);\n  }\n  getAddresses() {\n    return this.addresses;\n  }\n  isConnected() {\n    return this.client !== null && this.walletId !== null;\n  }\n  /*\n   * We use this method to route between different authentication flows based on wallet type and auth options.\n   * It handles app-wallet creation directly or routes to JWT/redirect authentication for user-wallets.\n   * Returns null for redirect flows since they don't complete synchronously.\n   */\n  async handleAuthFlow(publicKey, stamperInfo, authOptions, expiresInMs) {\n    if (this.config.embeddedWalletType === \"user-wallet\") {\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Creating user-wallet, routing authentication\", {\n        authProvider: authOptions.provider\n      });\n      if (authOptions.provider === \"phantom\") {\n        return await this.handlePhantomAuth(publicKey, stamperInfo, expiresInMs);\n      } else {\n        this.logger.info(\"EMBEDDED_PROVIDER\", \"Starting redirect-based authentication flow\", {\n          publicKey,\n          provider: authOptions?.provider\n        });\n        return await this.handleRedirectAuth(publicKey, stamperInfo, authOptions);\n      }\n    } else {\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Creating app-wallet\", {\n        publicKey\n      });\n      const organizationId = await this.createOrganizationForAppWallet(stamperInfo, expiresInMs);\n      const tempClient = new _phantom_client__WEBPACK_IMPORTED_MODULE_1__.PhantomClient(\n        {\n          apiBaseUrl: this.config.apiBaseUrl,\n          organizationId,\n          headers: {\n            ...this.platform.analyticsHeaders || {}\n          }\n        },\n        this.stamper\n      );\n      const wallet = await tempClient.createWallet(`Wallet ${Date.now()}`);\n      const walletId = wallet.walletId;\n      const now = Date.now();\n      const session = {\n        sessionId: generateSessionId(),\n        walletId,\n        organizationId,\n        appId: this.config.appId,\n        stamperInfo,\n        authProvider: \"device\",\n        // For now app wallets have no auth provider.\n        accountDerivationIndex: 0,\n        // App wallets default to index 0\n        status: \"completed\",\n        createdAt: now,\n        lastUsed: now,\n        authenticatorCreatedAt: now,\n        authenticatorExpiresAt: Date.now() + expiresInMs,\n        lastRenewalAttempt: void 0\n      };\n      await this.storage.saveSession(session);\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"App-wallet created successfully\", { walletId, organizationId });\n      return session;\n    }\n  }\n  /*\n   * We use this method to handle Phantom app-based authentication for user-wallets.\n   * This method uses the PhantomAppProvider to authenticate via the browser extension or mobile app.\n   *\n   * NOTE: Mobile deeplink support is not yet implemented. If we wanted to support mobile deeplinks,\n   * we would:\n   * 1. Check if the app provider is available using phantomAppProvider.isAvailable()\n   * 2. If not available, generate a deeplink (phantom://auth?...)\n   * 3. Save a pending session before opening the deeplink\n   * 4. Start a polling mechanism to check for auth completion\n   * 5. Update the session when the mobile app completes the auth\n   */\n  async handlePhantomAuth(publicKey, stamperInfo, expiresInMs) {\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Starting Phantom authentication flow\");\n    const isAvailable = this.phantomAppProvider.isAvailable();\n    if (!isAvailable) {\n      this.logger.error(\"EMBEDDED_PROVIDER\", \"Phantom app not available\");\n      throw new Error(\n        \"Phantom app is not available. Please install the Phantom browser extension or mobile app to use this authentication method.\"\n      );\n    }\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Phantom app detected, proceeding with authentication\");\n    const sessionId = generateSessionId();\n    const authResult = await this.phantomAppProvider.authenticate({\n      publicKey,\n      appId: this.config.appId,\n      sessionId\n    });\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Phantom authentication completed\", {\n      walletId: authResult.walletId,\n      organizationId: authResult.organizationId\n    });\n    const effectiveExpiresInMs = authResult.expiresInMs > 0 ? authResult.expiresInMs : expiresInMs;\n    const now = Date.now();\n    const session = {\n      sessionId,\n      walletId: authResult.walletId,\n      organizationId: authResult.organizationId,\n      appId: this.config.appId,\n      stamperInfo,\n      authProvider: \"phantom\",\n      accountDerivationIndex: authResult.accountDerivationIndex,\n      status: \"completed\",\n      createdAt: now,\n      lastUsed: now,\n      authenticatorCreatedAt: now,\n      authenticatorExpiresAt: now + effectiveExpiresInMs,\n      lastRenewalAttempt: void 0,\n      authUserId: authResult.authUserId\n    };\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Saving Phantom session\");\n    await this.storage.saveSession(session);\n    return session;\n  }\n  /*\n   * We use this method to handle redirect-based authentication (Google/Apple OAuth).\n   * It saves a temporary session before redirecting to prevent losing state during the redirect flow.\n   * Session timestamp is updated before redirect to prevent race conditions.\n   */\n  async handleRedirectAuth(publicKey, stamperInfo, authOptions) {\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Using Phantom Connect authentication flow (redirect-based)\", {\n      provider: authOptions.provider,\n      hasRedirectUrl: !!this.config.authOptions.redirectUrl,\n      authUrl: this.config.authOptions.authUrl\n    });\n    const now = Date.now();\n    const sessionId = generateSessionId();\n    const tempSession = {\n      sessionId,\n      walletId: `temp-wallet-${now}`,\n      // Temporary ID, will be updated after redirect\n      organizationId: `temp-org-${now}`,\n      // Temporary ID, will be updated after redirect\n      appId: this.config.appId,\n      stamperInfo,\n      authProvider: authOptions.provider,\n      accountDerivationIndex: void 0,\n      // Will be set when redirect completes\n      status: \"pending\",\n      createdAt: now,\n      lastUsed: now,\n      authenticatorCreatedAt: now,\n      authenticatorExpiresAt: now + AUTHENTICATOR_EXPIRATION_TIME_MS,\n      lastRenewalAttempt: void 0\n    };\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Saving temporary session before redirect\", {\n      sessionId: tempSession.sessionId,\n      tempWalletId: tempSession.walletId\n    });\n    tempSession.lastUsed = Date.now();\n    await this.storage.saveSession(tempSession);\n    const shouldClearPreviousSession = await this.storage.getShouldClearPreviousSession();\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Starting Phantom Connect redirect\", {\n      publicKey,\n      appId: this.config.appId,\n      provider: authOptions?.provider,\n      authUrl: this.config.authOptions.authUrl,\n      clearPreviousSession: shouldClearPreviousSession,\n      allowRefresh: !shouldClearPreviousSession\n    });\n    const authResult = await this.authProvider.authenticate({\n      publicKey,\n      appId: this.config.appId,\n      provider: authOptions?.provider,\n      redirectUrl: this.config.authOptions.redirectUrl,\n      authUrl: this.config.authOptions.authUrl,\n      sessionId,\n      // OAuth session management - defaults to allowing refresh unless user explicitly logged out\n      clearPreviousSession: shouldClearPreviousSession,\n      // true only after logout\n      allowRefresh: !shouldClearPreviousSession\n      // false only after logout\n    });\n    if (authResult && \"walletId\" in authResult) {\n      this.logger.info(\"EMBEDDED_PROVIDER\", \"Authentication completed after redirect\", {\n        walletId: authResult.walletId,\n        organizationId: authResult.organizationId,\n        provider: authResult.provider\n      });\n      tempSession.walletId = authResult.walletId;\n      tempSession.organizationId = authResult.organizationId;\n      tempSession.authProvider = authResult.provider || tempSession.authProvider;\n      tempSession.accountDerivationIndex = authResult.accountDerivationIndex;\n      tempSession.authUserId = authResult.authUserId;\n      tempSession.status = \"completed\";\n      tempSession.lastUsed = Date.now();\n      if (authResult.expiresInMs > 0) {\n        const now2 = Date.now();\n        tempSession.authenticatorCreatedAt = now2;\n        tempSession.authenticatorExpiresAt = now2 + authResult.expiresInMs;\n        this.logger.log(\"EMBEDDED_PROVIDER\", \"Updated authenticator expiration from immediate auth response\", {\n          expiresInMs: authResult.expiresInMs,\n          expiresAt: new Date(tempSession.authenticatorExpiresAt).toISOString()\n        });\n      }\n      await this.storage.saveSession(tempSession);\n      await this.storage.setShouldClearPreviousSession(false);\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Cleared logout flag after successful authentication\");\n      return tempSession;\n    }\n    this.logger.info(\"EMBEDDED_PROVIDER\", \"Redirect authentication initiated, waiting for redirect completion\");\n    return null;\n  }\n  async completeAuthConnection(authResult) {\n    const session = await this.storage.getSession();\n    if (!session) {\n      throw new Error(\"No session found after redirect - session may have expired\");\n    }\n    session.walletId = authResult.walletId;\n    session.authProvider = authResult.provider || session.authProvider;\n    session.organizationId = authResult.organizationId;\n    session.accountDerivationIndex = authResult.accountDerivationIndex;\n    session.authUserId = authResult.authUserId;\n    session.status = \"completed\";\n    session.lastUsed = Date.now();\n    if (authResult.expiresInMs > 0) {\n      const now = Date.now();\n      session.authenticatorCreatedAt = now;\n      session.authenticatorExpiresAt = now + authResult.expiresInMs;\n      this.logger.log(\"EMBEDDED_PROVIDER\", \"Updated authenticator expiration from auth response\", {\n        expiresInMs: authResult.expiresInMs,\n        expiresAt: new Date(session.authenticatorExpiresAt).toISOString()\n      });\n    }\n    await this.storage.saveSession(session);\n    await this.storage.setShouldClearPreviousSession(false);\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Cleared logout flag after successful authentication\");\n    await this.initializeClientFromSession(session);\n    await this.ensureValidAuthenticator();\n    return {\n      walletId: this.walletId,\n      addresses: this.addresses,\n      status: \"completed\",\n      authUserId: session.authUserId,\n      authProvider: session.authProvider\n    };\n  }\n  /*\n   * Ensures the authenticator is valid and performs renewal if needed.\n   * The renewal of the authenticator can only happen meanwhile the previous authenticator is still valid.\n   */\n  async ensureValidAuthenticator() {\n    const session = await this.storage.getSession();\n    if (!session) {\n      throw new Error(\"No active session found\");\n    }\n    const now = Date.now();\n    if (!session.authenticatorExpiresAt) {\n      this.logger.warn(\"EMBEDDED_PROVIDER\", \"Session missing authenticator timing - treating as invalid session\");\n      await this.disconnect(false);\n      throw new Error(\"Invalid session - missing authenticator timing\");\n    }\n    const timeUntilExpiry = session.authenticatorExpiresAt - now;\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Checking authenticator expiration\", {\n      expiresAt: new Date(session.authenticatorExpiresAt).toISOString(),\n      timeUntilExpiry\n    });\n    if (timeUntilExpiry <= 0) {\n      this.logger.error(\"EMBEDDED_PROVIDER\", \"Authenticator has expired, disconnecting\");\n      await this.disconnect(false);\n      throw new Error(\"Authenticator expired\");\n    }\n  }\n  /*\n   * We use this method to initialize the PhantomClient and fetch wallet addresses from a completed session.\n   * This is the final step that sets up the provider's client state and retrieves available addresses.\n   */\n  async initializeClientFromSession(session) {\n    this.logger.log(\"EMBEDDED_PROVIDER\", \"Initializing PhantomClient from session\", {\n      organizationId: session.organizationId,\n      walletId: session.walletId,\n      appId: session.appId\n    });\n    if (!this.stamper.getKeyInfo()) {\n      await this.stamper.init();\n    }\n    this.client = new _phantom_client__WEBPACK_IMPORTED_MODULE_1__.PhantomClient(\n      {\n        apiBaseUrl: this.config.apiBaseUrl,\n        organizationId: session.organizationId,\n        headers: {\n          ...this.platform.analyticsHeaders || {},\n          ...session.authUserId ? { \"x-auth-user-id\": session.authUserId } : {}\n        }\n      },\n      this.stamper\n    );\n    this.walletId = session.walletId;\n    this.addresses = await this.getAndFilterWalletAddresses(session.walletId);\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vZW1iZWRkZWQtcHJvdmlkZXItY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0U7QUFDUztBQUt2RDtBQUNrQjtBQUNaO0FBQ1A7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzZDO0FBQ0U7QUFDdkI7QUFDd0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsdURBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEVBQTRFLDRDQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw4RUFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseURBQVMsa0JBQWtCLHlEQUFTO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUIsWUFBWSx3Q0FBd0M7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usd0JBQXdCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELG9DQUFvQyx1Q0FBdUM7QUFDM0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vZW1iZWRkZWQtcHJvdmlkZXItY29yZS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZW1iZWRkZWQtcHJvdmlkZXIudHNcbmltcG9ydCB7IGJhc2U2NHVybEVuY29kZSwgc3RyaW5nVG9CYXNlNjR1cmwgfSBmcm9tIFwiQHBoYW50b20vYmFzZTY0dXJsXCI7XG5pbXBvcnQgeyBBZGRyZXNzVHlwZSwgUGhhbnRvbUNsaWVudCwgU3BlbmRpbmdMaW1pdEVycm9yIH0gZnJvbSBcIkBwaGFudG9tL2NsaWVudFwiO1xuaW1wb3J0IHtcbiAgcGFyc2VTaWduTWVzc2FnZVJlc3BvbnNlLFxuICBwYXJzZVRyYW5zYWN0aW9uUmVzcG9uc2UsXG4gIHBhcnNlVG9LbXNUcmFuc2FjdGlvblxufSBmcm9tIFwiQHBoYW50b20vcGFyc2Vyc1wiO1xuaW1wb3J0IHsgcmFuZG9tVVVJRCB9IGZyb20gXCJAcGhhbnRvbS91dGlsc1wiO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IGJzNTgyIGZyb20gXCJiczU4XCI7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBBVVRIRU5USUNBVE9SX0VYUElSQVRJT05fVElNRV9NUyA9IDcgKiAyNCAqIDYwICogNjAgKiAxZTM7XG52YXIgQVVUSEVOVElDQVRPUl9SRU5FV0FMX1dJTkRPV19NUyA9IDIgKiAyNCAqIDYwICogNjAgKiAxZTM7XG52YXIgRU1CRURERURfUFJPVklERVJfQVVUSF9UWVBFUyA9IFtcImdvb2dsZVwiLCBcImFwcGxlXCIsIFwicGhhbnRvbVwiXTtcblxuLy8gc3JjL2NoYWlucy9Tb2xhbmFDaGFpbi50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50ZW1pdHRlcjNcIjtcbmltcG9ydCB7IE5ldHdvcmtJZCB9IGZyb20gXCJAcGhhbnRvbS9jb25zdGFudHNcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5pbXBvcnQgeyBwYXJzZVNvbGFuYVNpZ25lZFRyYW5zYWN0aW9uIH0gZnJvbSBcIkBwaGFudG9tL3BhcnNlcnNcIjtcbnZhciBFbWJlZGRlZFNvbGFuYUNoYWluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLmN1cnJlbnROZXR3b3JrSWQgPSBOZXR3b3JrSWQuU09MQU5BX01BSU5ORVQ7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcHVibGljS2V5ID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN5bmNJbml0aWFsU3RhdGUoKTtcbiAgfVxuICAvLyBXYWxsZXQgYWRhcHRlciBjb21wbGlhbnQgcHJvcGVydGllc1xuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5O1xuICB9XG4gIGVuc3VyZUNvbm5lY3RlZCgpIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29sYW5hIGNoYWluIG5vdCBhdmFpbGFibGUuIEVuc3VyZSBTREsgaXMgY29ubmVjdGVkLlwiKTtcbiAgICB9XG4gIH1cbiAgLy8gU3RhbmRhcmQgd2FsbGV0IGFkYXB0ZXIgbWV0aG9kc1xuICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5lbnN1cmVDb25uZWN0ZWQoKTtcbiAgICBjb25zdCBtZXNzYWdlU3RyID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnbk1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZVN0cixcbiAgICAgIG5ldHdvcmtJZDogdGhpcy5jdXJyZW50TmV0d29ya0lkXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdHlwZW9mIHJlc3VsdC5zaWduYXR1cmUgPT09IFwic3RyaW5nXCIgPyBuZXcgVWludDhBcnJheShiczU4LmRlY29kZShyZXN1bHQuc2lnbmF0dXJlKSkgOiByZXN1bHQuc2lnbmF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXk6IHRoaXMuX3B1YmxpY0tleSB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLmVuc3VyZUNvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbmV0d29ya0lkOiB0aGlzLmN1cnJlbnROZXR3b3JrSWRcbiAgICB9KTtcbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IHBhcnNlU29sYW5hU2lnbmVkVHJhbnNhY3Rpb24ocmVzdWx0LnJhd1RyYW5zYWN0aW9uKTtcbiAgICBpZiAoIXNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc2lnbmVkIHRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHRoaXMuZW5zdXJlQ29ubmVjdGVkKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbmV0d29ya0lkOiB0aGlzLmN1cnJlbnROZXR3b3JrSWRcbiAgICB9KTtcbiAgICBpZiAoIXJlc3VsdC5oYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBub3Qgc3VibWl0dGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWduYXR1cmU6IHJlc3VsdC5oYXNoIH07XG4gIH1cbiAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICB0aGlzLmVuc3VyZUNvbm5lY3RlZCgpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4gdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpKSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRBbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHgpKSk7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlczogcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0LnNpZ25hdHVyZSkgfTtcbiAgfVxuICBjb25uZWN0KF9vcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIG5vdCBjb25uZWN0ZWQuIENhbGwgcHJvdmlkZXIgY29ubmVjdCBmaXJzdC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMucHJvdmlkZXIuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3Qgc29sYW5hQWRkciA9IGFkZHJlc3Nlcy5maW5kKChhKSA9PiBhLmFkZHJlc3NUeXBlID09PSBcIlNvbGFuYVwiKTtcbiAgICBpZiAoIXNvbGFuYUFkZHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBTb2xhbmEgYWRkcmVzcyBmb3VuZFwiKTtcbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0ZSh0cnVlLCBzb2xhbmFBZGRyLmFkZHJlc3MpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBwdWJsaWNLZXk6IHNvbGFuYUFkZHIuYWRkcmVzcyB9KTtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBzd2l0Y2hOZXR3b3JrKG5ldHdvcmspIHtcbiAgICB0aGlzLmN1cnJlbnROZXR3b3JrSWQgPSBuZXR3b3JrID09PSBcIm1haW5uZXRcIiA/IE5ldHdvcmtJZC5TT0xBTkFfTUFJTk5FVCA6IE5ldHdvcmtJZC5TT0xBTkFfREVWTkVUO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyLmlzQ29ubmVjdGVkKCkpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMucHJvdmlkZXIuZ2V0QWRkcmVzc2VzKCk7XG4gICAgY29uc3Qgc29sYW5hQWRkciA9IGFkZHJlc3Nlcy5maW5kKChhKSA9PiBhLmFkZHJlc3NUeXBlID09PSBcIlNvbGFuYVwiKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvbGFuYUFkZHI/LmFkZHJlc3MgfHwgbnVsbCk7XG4gIH1cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZCAmJiB0aGlzLnByb3ZpZGVyLmlzQ29ubmVjdGVkKCk7XG4gIH1cbiAgc2V0dXBFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLnByb3ZpZGVyLm9uKFwiY29ubmVjdFwiLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc3Qgc29sYW5hQWRkcmVzcyA9IGRhdGEuYWRkcmVzc2VzPy5maW5kKChhZGRyKSA9PiBhZGRyLmFkZHJlc3NUeXBlID09PSBcIlNvbGFuYVwiKTtcbiAgICAgIGlmIChzb2xhbmFBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRlKHRydWUsIHNvbGFuYUFkZHJlc3MuYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjb25uZWN0XCIsIHNvbGFuYUFkZHJlc3MuYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm92aWRlci5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdGUoZmFsc2UsIG51bGwpO1xuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gICAgfSk7XG4gIH1cbiAgc3luY0luaXRpYWxTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5wcm92aWRlci5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLnByb3ZpZGVyLmdldEFkZHJlc3NlcygpO1xuICAgICAgY29uc3Qgc29sYW5hQWRkcmVzcyA9IGFkZHJlc3Nlcy5maW5kKChhKSA9PiBhLmFkZHJlc3NUeXBlID09PSBcIlNvbGFuYVwiKTtcbiAgICAgIGlmIChzb2xhbmFBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRlKHRydWUsIHNvbGFuYUFkZHJlc3MuYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNvbm5lY3Rpb25TdGF0ZShjb25uZWN0ZWQsIHB1YmxpY0tleSkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGNvbm5lY3RlZDtcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gIH1cbiAgLy8gRXZlbnQgbWV0aG9kcyBmb3IgaW50ZXJmYWNlIGNvbXBsaWFuY2VcbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8vIHNyYy9jaGFpbnMvRXRoZXJldW1DaGFpbi50c1xuaW1wb3J0IHsgTmV0d29ya0lkIGFzIE5ldHdvcmtJZDIsIGNoYWluSWRUb05ldHdvcmtJZCwgbmV0d29ya0lkVG9DaGFpbklkIH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xudmFyIEVtYmVkZGVkRXRoZXJldW1DaGFpbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5jdXJyZW50TmV0d29ya0lkID0gTmV0d29ya0lkMi5FVEhFUkVVTV9NQUlOTkVUO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FjY291bnRzID0gW107XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyMigpO1xuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc3luY0luaXRpYWxTdGF0ZSgpO1xuICB9XG4gIC8vIEVJUC0xMTkzIGNvbXBsaWFudCBwcm9wZXJ0aWVzXG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBnZXQgY2hhaW5JZCgpIHtcbiAgICBjb25zdCBjaGFpbklkID0gbmV0d29ya0lkVG9DaGFpbklkKHRoaXMuY3VycmVudE5ldHdvcmtJZCkgfHwgMTtcbiAgICByZXR1cm4gYDB4JHtjaGFpbklkLnRvU3RyaW5nKDE2KX1gO1xuICB9XG4gIGdldCBhY2NvdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudHM7XG4gIH1cbiAgZW5zdXJlQ29ubmVjdGVkKCkge1xuICAgIGlmICghdGhpcy5wcm92aWRlci5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcmV1bSBjaGFpbiBub3QgYXZhaWxhYmxlLiBFbnN1cmUgU0RLIGlzIGNvbm5lY3RlZC5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgIHRoaXMuZW5zdXJlQ29ubmVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlRW1iZWRkZWRSZXF1ZXN0KGFyZ3MpO1xuICB9XG4gIC8vIENvbm5lY3Rpb24gbWV0aG9kc1xuICBjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5wcm92aWRlci5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgY29ubmVjdGVkLiBDYWxsIHByb3ZpZGVyIGNvbm5lY3QgZmlyc3QuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzZXMgPSB0aGlzLnByb3ZpZGVyLmdldEFkZHJlc3NlcygpO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5maWx0ZXIoKGEpID0+IGEuYWRkcmVzc1R5cGUgPT09IFwiRXRoZXJldW1cIikubWFwKChhKSA9PiBhLmFkZHJlc3MpO1xuICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRlKHRydWUsIGV0aEFkZHJlc3Nlcyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShldGhBZGRyZXNzZXMpO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgYXdhaXQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLy8gU3RhbmRhcmQgY29tcGxpYW50IG1ldGhvZHMgKHJldHVybiByYXcgdmFsdWVzKVxuICBhc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UsIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJwZXJzb25hbF9zaWduXCIsXG4gICAgICBwYXJhbXM6IFttZXNzYWdlLCBhZGRyZXNzXVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNpZ25UeXBlZERhdGEodHlwZWREYXRhLCBhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixcbiAgICAgIHBhcmFtczogW2FkZHJlc3MsIEpTT04uc3RyaW5naWZ5KHR5cGVkRGF0YSldXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IG5ldHdvcmtJZCA9IHRoaXMuY3VycmVudE5ldHdvcmtJZDtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCkge1xuICAgICAgY29uc3QgbnVtZXJpY0NoYWluSWQgPSB0eXBlb2YgdHJhbnNhY3Rpb24uY2hhaW5JZCA9PT0gXCJudW1iZXJcIiA/IHRyYW5zYWN0aW9uLmNoYWluSWQgOiBwYXJzZUludCh0cmFuc2FjdGlvbi5jaGFpbklkLCAxNik7XG4gICAgICBjb25zdCB0eE5ldHdvcmtJZCA9IGNoYWluSWRUb05ldHdvcmtJZChudW1lcmljQ2hhaW5JZCk7XG4gICAgICBpZiAodHhOZXR3b3JrSWQpIHtcbiAgICAgICAgbmV0d29ya0lkID0gdHhOZXR3b3JrSWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbmV0d29ya0lkXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5yYXdUcmFuc2FjdGlvbjtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCkge1xuICAgICAgY29uc3QgbnVtZXJpY0NoYWluSWQgPSB0eXBlb2YgdHJhbnNhY3Rpb24uY2hhaW5JZCA9PT0gXCJudW1iZXJcIiA/IHRyYW5zYWN0aW9uLmNoYWluSWQgOiBwYXJzZUludCh0cmFuc2FjdGlvbi5jaGFpbklkLCAxNik7XG4gICAgICBhd2FpdCB0aGlzLnN3aXRjaENoYWluKG51bWVyaWNDaGFpbklkKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbmV0d29ya0lkOiB0aGlzLmN1cnJlbnROZXR3b3JrSWRcbiAgICB9KTtcbiAgICBpZiAoIXJlc3VsdC5oYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBub3Qgc3VibWl0dGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmhhc2g7XG4gIH1cbiAgc3dpdGNoQ2hhaW4oY2hhaW5JZCkge1xuICAgIGNvbnN0IG51bWVyaWNDaGFpbklkID0gdHlwZW9mIGNoYWluSWQgPT09IFwic3RyaW5nXCIgPyBjaGFpbklkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcIjB4XCIpID8gcGFyc2VJbnQoY2hhaW5JZCwgMTYpIDogcGFyc2VJbnQoY2hhaW5JZCwgMTApIDogY2hhaW5JZDtcbiAgICBjb25zdCBuZXR3b3JrSWQgPSBjaGFpbklkVG9OZXR3b3JrSWQobnVtZXJpY0NoYWluSWQpO1xuICAgIGlmICghbmV0d29ya0lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYWluSWQ6ICR7Y2hhaW5JZH1gKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50TmV0d29ya0lkID0gbmV0d29ya0lkO1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgYDB4JHtudW1lcmljQ2hhaW5JZC50b1N0cmluZygxNil9YCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGdldENoYWluSWQoKSB7XG4gICAgY29uc3QgY2hhaW5JZCA9IG5ldHdvcmtJZFRvQ2hhaW5JZCh0aGlzLmN1cnJlbnROZXR3b3JrSWQpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhaW5JZCB8fCAxKTtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiIH0pO1xuICB9XG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQgJiYgdGhpcy5wcm92aWRlci5pc0Nvbm5lY3RlZCgpO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5wcm92aWRlci5vbihcImNvbm5lY3RcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGV0aEFkZHJlc3NlcyA9IGRhdGEuYWRkcmVzc2VzPy5maWx0ZXIoKGFkZHIpID0+IGFkZHIuYWRkcmVzc1R5cGUgPT09IFwiRXRoZXJldW1cIik/Lm1hcCgoYWRkcikgPT4gYWRkci5hZGRyZXNzKSB8fCBbXTtcbiAgICAgIGlmIChldGhBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0ZSh0cnVlLCBldGhBZGRyZXNzZXMpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiY29ubmVjdFwiLCB7IGNoYWluSWQ6IHRoaXMuY2hhaW5JZCB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBldGhBZGRyZXNzZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRlKGZhbHNlLCBbXSk7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdFwiLCB7IGNvZGU6IDQ5MDAsIG1lc3NhZ2U6IFwiUHJvdmlkZXIgZGlzY29ubmVjdGVkXCIgfSk7XG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFwiYWNjb3VudHNDaGFuZ2VkXCIsIFtdKTtcbiAgICB9KTtcbiAgfVxuICBzeW5jSW5pdGlhbFN0YXRlKCkge1xuICAgIGlmICh0aGlzLnByb3ZpZGVyLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IHRoaXMucHJvdmlkZXIuZ2V0QWRkcmVzc2VzKCk7XG4gICAgICBjb25zdCBldGhBZGRyZXNzZXMgPSBhZGRyZXNzZXMuZmlsdGVyKChhKSA9PiBhLmFkZHJlc3NUeXBlID09PSBcIkV0aGVyZXVtXCIpLm1hcCgoYSkgPT4gYS5hZGRyZXNzKTtcbiAgICAgIGlmIChldGhBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0ZSh0cnVlLCBldGhBZGRyZXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVDb25uZWN0aW9uU3RhdGUoY29ubmVjdGVkLCBhY2NvdW50cykge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGNvbm5lY3RlZDtcbiAgICB0aGlzLl9hY2NvdW50cyA9IGFjY291bnRzO1xuICB9XG4gIGFzeW5jIGhhbmRsZUVtYmVkZGVkUmVxdWVzdChhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLm1ldGhvZCkge1xuICAgICAgY2FzZSBcInBlcnNvbmFsX3NpZ25cIjoge1xuICAgICAgICBjb25zdCBbbWVzc2FnZSwgX2FkZHJlc3NdID0gYXJncy5wYXJhbXM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnbkV0aGVyZXVtTWVzc2FnZSh7XG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBuZXR3b3JrSWQ6IHRoaXMuY3VycmVudE5ldHdvcmtJZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaWduYXR1cmU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIjoge1xuICAgICAgICBjb25zdCBbX3R5cGVkRGF0YUFkZHJlc3MsIHR5cGVkRGF0YVN0cl0gPSBhcmdzLnBhcmFtcztcbiAgICAgICAgY29uc3QgdHlwZWREYXRhID0gSlNPTi5wYXJzZSh0eXBlZERhdGFTdHIpO1xuICAgICAgICBjb25zdCB0eXBlZERhdGFSZXN1bHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnNpZ25UeXBlZERhdGFWNCh7XG4gICAgICAgICAgdHlwZWREYXRhLFxuICAgICAgICAgIG5ldHdvcmtJZDogdGhpcy5jdXJyZW50TmV0d29ya0lkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZWREYXRhUmVzdWx0LnNpZ25hdHVyZTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJldGhfc2lnblRyYW5zYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgW3RyYW5zYWN0aW9uXSA9IGFyZ3MucGFyYW1zO1xuICAgICAgICBjb25zdCBuZXR3b3JrSWRGcm9tVHggPSB0cmFuc2FjdGlvbi5jaGFpbklkID8gY2hhaW5JZFRvTmV0d29ya0lkKFxuICAgICAgICAgIHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkID09PSBcIm51bWJlclwiID8gdHJhbnNhY3Rpb24uY2hhaW5JZCA6IHBhcnNlSW50KHRyYW5zYWN0aW9uLmNoYWluSWQsIDE2KVxuICAgICAgICApIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2lnblJlc3VsdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZEZyb21UeCB8fCB0aGlzLmN1cnJlbnROZXR3b3JrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaWduUmVzdWx0LnJhd1RyYW5zYWN0aW9uO1xuICAgICAgfVxuICAgICAgY2FzZSBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIjoge1xuICAgICAgICBjb25zdCBbdHJhbnNhY3Rpb25dID0gYXJncy5wYXJhbXM7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZEZyb21UeCA9IHRyYW5zYWN0aW9uLmNoYWluSWQgPyBjaGFpbklkVG9OZXR3b3JrSWQoXG4gICAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IFwibnVtYmVyXCIgPyB0cmFuc2FjdGlvbi5jaGFpbklkIDogcGFyc2VJbnQodHJhbnNhY3Rpb24uY2hhaW5JZCwgMTYpXG4gICAgICAgICkgOiBudWxsO1xuICAgICAgICBjb25zdCBzZW5kUmVzdWx0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZEZyb21UeCB8fCB0aGlzLmN1cnJlbnROZXR3b3JrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZW5kUmVzdWx0Lmhhc2g7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZXRoX2FjY291bnRzXCI6IHtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gdGhpcy5wcm92aWRlci5nZXRBZGRyZXNzZXMoKTtcbiAgICAgICAgY29uc3QgZXRoQWRkciA9IGFkZHJlc3Nlcy5maW5kKChhKSA9PiBhLmFkZHJlc3NUeXBlID09PSBcIkV0aGVyZXVtXCIpO1xuICAgICAgICByZXR1cm4gZXRoQWRkciA/IFtldGhBZGRyLmFkZHJlc3NdIDogW107XG4gICAgICB9XG4gICAgICBjYXNlIFwiZXRoX2NoYWluSWRcIjoge1xuICAgICAgICByZXR1cm4gYDB4JHsobmV0d29ya0lkVG9DaGFpbklkKHRoaXMuY3VycmVudE5ldHdvcmtJZCkgfHwgMSkudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIjoge1xuICAgICAgICBjb25zdCBbeyBjaGFpbklkIH1dID0gYXJncy5wYXJhbXM7XG4gICAgICAgIGNvbnN0IG51bWVyaWNDaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICAgICAgICBhd2FpdCB0aGlzLnN3aXRjaENoYWluKG51bWVyaWNDaGFpbklkKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW1iZWRkZWQgcHJvdmlkZXIgZG9lc24ndCBzdXBwb3J0IG1ldGhvZDogJHthcmdzLm1ldGhvZH1gKTtcbiAgICB9XG4gIH1cbiAgLy8gRXZlbnQgbWV0aG9kcyBmb3IgaW50ZXJmYWNlIGNvbXBsaWFuY2VcbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudEVtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXRyeS50c1xuYXN5bmMgZnVuY3Rpb24gcmV0cnlXaXRoQmFja29mZihvcGVyYXRpb24sIG9wZXJhdGlvbk5hbWUsIGxvZ2dlciwgbWF4UmV0cmllcyA9IDMsIGJhc2VEZWxheSA9IDFlMykge1xuICBsZXQgbGFzdEVycm9yO1xuICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIGBBdHRlbXB0aW5nICR7b3BlcmF0aW9uTmFtZX1gLCB7XG4gICAgICAgIGF0dGVtcHQsXG4gICAgICAgIG1heFJldHJpZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IG9wZXJhdGlvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgIGxvZ2dlci53YXJuKFwiRU1CRURERURfUFJPVklERVJcIiwgYCR7b3BlcmF0aW9uTmFtZX0gZmFpbGVkYCwge1xuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBtYXhSZXRyaWVzLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICB9KTtcbiAgICAgIGlmIChhdHRlbXB0ID09PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkVNQkVEREVEX1BST1ZJREVSXCIsIGAke29wZXJhdGlvbk5hbWV9IGZhaWxlZCBhZnRlciAke21heFJldHJpZXN9IGF0dGVtcHRzYCwge1xuICAgICAgICAgIGZpbmFsRXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKTtcbiAgICAgIGxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBgUmV0cnlpbmcgJHtvcGVyYXRpb25OYW1lfSBpbiAke2RlbGF5fW1zYCwge1xuICAgICAgICBhdHRlbXB0OiBhdHRlbXB0ICsgMSxcbiAgICAgICAgZGVsYXlcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbGFzdEVycm9yO1xufVxuXG4vLyBzcmMvdXRpbHMvc2Vzc2lvbi50c1xuZnVuY3Rpb24gZ2VuZXJhdGVTZXNzaW9uSWQoKSB7XG4gIHJldHVybiBcInNlc3Npb25fXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArIFwiX1wiICsgRGF0ZS5ub3coKTtcbn1cblxuLy8gc3JjL2VtYmVkZGVkLXByb3ZpZGVyLnRzXG52YXIgRW1iZWRkZWRQcm92aWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBwbGF0Zm9ybSwgbG9nZ2VyKSB7XG4gICAgdGhpcy5jbGllbnQgPSBudWxsO1xuICAgIHRoaXMud2FsbGV0SWQgPSBudWxsO1xuICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJJbml0aWFsaXppbmcgRW1iZWRkZWRQcm92aWRlclwiLCB7IGNvbmZpZyB9KTtcbiAgICBpZiAoY29uZmlnLmVtYmVkZGVkV2FsbGV0VHlwZSA9PT0gXCJhcHAtd2FsbGV0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFwcC13YWxsZXQgdHlwZSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAndXNlci13YWxsZXQnIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgdGhpcy5zdG9yYWdlID0gcGxhdGZvcm0uc3RvcmFnZTtcbiAgICB0aGlzLmF1dGhQcm92aWRlciA9IHBsYXRmb3JtLmF1dGhQcm92aWRlcjtcbiAgICB0aGlzLnBoYW50b21BcHBQcm92aWRlciA9IHBsYXRmb3JtLnBoYW50b21BcHBQcm92aWRlcjtcbiAgICB0aGlzLnVybFBhcmFtc0FjY2Vzc29yID0gcGxhdGZvcm0udXJsUGFyYW1zQWNjZXNzb3I7XG4gICAgdGhpcy5zdGFtcGVyID0gcGxhdGZvcm0uc3RhbXBlcjtcbiAgICB0aGlzLnNvbGFuYSA9IG5ldyBFbWJlZGRlZFNvbGFuYUNoYWluKHRoaXMpO1xuICAgIHRoaXMuZXRoZXJldW0gPSBuZXcgRW1iZWRkZWRFdGhlcmV1bUNoYWluKHRoaXMpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkVtYmVkZGVkUHJvdmlkZXIgaW5pdGlhbGl6ZWRcIik7XG4gIH1cbiAgLypcbiAgICogRXZlbnQgc3lzdGVtIG1ldGhvZHMgZm9yIGxpc3RlbmluZyB0byBwcm92aWRlciBzdGF0ZSBjaGFuZ2VzXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5zZXQoZXZlbnQsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk/LmFkZChjYWxsYmFjayk7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJFdmVudCBsaXN0ZW5lciBhZGRlZFwiLCB7IGV2ZW50IH0pO1xuICB9XG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkV2ZW50IGxpc3RlbmVyIHJlbW92ZWRcIiwgeyBldmVudCB9KTtcbiAgICB9XG4gIH1cbiAgZW1pdChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJFbWl0dGluZyBldmVudFwiLCB7IGV2ZW50LCBsaXN0ZW5lckNvdW50OiBsaXN0ZW5lcnMuc2l6ZSwgZGF0YSB9KTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJFdmVudCBjYWxsYmFjayBlcnJvclwiLCB7IGV2ZW50LCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gbmV0d29yayBJRCBmcm9tIGF2YWlsYWJsZSBhZGRyZXNzZXNcbiAgICovXG4gIGdldEFkZHJlc3NGb3JOZXR3b3JrKG5ldHdvcmtJZCkge1xuICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrSWQuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHRhcmdldEFkZHJlc3NUeXBlO1xuICAgIHN3aXRjaCAobmV0d29yaykge1xuICAgICAgY2FzZSBcInNvbGFuYVwiOlxuICAgICAgICB0YXJnZXRBZGRyZXNzVHlwZSA9IEFkZHJlc3NUeXBlLnNvbGFuYTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZWlwMTU1XCI6XG4gICAgICAgIHRhcmdldEFkZHJlc3NUeXBlID0gQWRkcmVzc1R5cGUuZXRoZXJldW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpdGNvaW5cIjpcbiAgICAgIGNhc2UgXCJidGNcIjpcbiAgICAgICAgdGFyZ2V0QWRkcmVzc1R5cGUgPSBBZGRyZXNzVHlwZS5iaXRjb2luU2Vnd2l0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdWlcIjpcbiAgICAgICAgdGFyZ2V0QWRkcmVzc1R5cGUgPSBBZGRyZXNzVHlwZS5zdWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGFyZ2V0QWRkcmVzc1R5cGUgPSBBZGRyZXNzVHlwZS5ldGhlcmV1bTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoaW5nQWRkcmVzcyA9IHRoaXMuYWRkcmVzc2VzLmZpbmQoXG4gICAgICAoYWRkcikgPT4gYWRkci5hZGRyZXNzVHlwZS50b0xvd2VyQ2FzZSgpID09PSB0YXJnZXRBZGRyZXNzVHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgKTtcbiAgICByZXR1cm4gbWF0Y2hpbmdBZGRyZXNzPy5hZGRyZXNzO1xuICB9XG4gIGFzeW5jIGdldEFuZEZpbHRlcldhbGxldEFkZHJlc3Nlcyh3YWxsZXRJZCkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHNlc3Npb24/LmFjY291bnREZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKFxuICAgICAgKCkgPT4gdGhpcy5jbGllbnQuZ2V0V2FsbGV0QWRkcmVzc2VzKHdhbGxldElkLCB2b2lkIDAsIGRlcml2YXRpb25JbmRleCksXG4gICAgICBcImdldFdhbGxldEFkZHJlc3Nlc1wiLFxuICAgICAgdGhpcy5sb2dnZXJcbiAgICApLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcImdldFdhbGxldEFkZHJlc3NlcyBmYWlsZWQgYWZ0ZXIgcmV0cmllcywgZGlzY29ubmVjdGluZ1wiLCB7XG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgZGVyaXZhdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5jbGVhclNlc3Npb24oKTtcbiAgICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgICAgIHRoaXMud2FsbGV0SWQgPSBudWxsO1xuICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGRyZXNzZXMuZmlsdGVyKChhZGRyKSA9PiB0aGlzLmNvbmZpZy5hZGRyZXNzVHlwZXMuc29tZSgodHlwZSkgPT4gdHlwZSA9PT0gYWRkci5hZGRyZXNzVHlwZSkpO1xuICB9XG4gIC8qXG4gICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byBtYWtlIHN1cmUgdGhlIHNlc3Npb24gaXMgbm90IGludmFsaWQsIG9yIHRoZXJlJ3MgYSBkaWZmZXJlbnQgc2Vzc2lvbiBpZCBpbiB0aGUgdXJsLlxuICAgKiBJZiB0aGVyZSdzIGEgZGlmZmVyZW50IG9uZSwgd2UgZGVsZXRlIHRoZSBjdXJyZW50IHNlc3Npb24gYW5kIHN0YXJ0IGZyb20gc2NyYXRjaC5cbiAgICogVGhpcyBwcmV2ZW50cyBpc3N1ZXMgd2hlcmUgdXNlcnMgaGF2ZSBzdGFsZSBzZXNzaW9ucyBvciBVUkwgbWlzbWF0Y2hlcyBhZnRlciByZWRpcmVjdHMuXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUFuZENsZWFuU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgaWYgKCFzZXNzaW9uKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJGb3VuZCBleGlzdGluZyBzZXNzaW9uLCB2YWxpZGF0aW5nXCIsIHtcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbi5zZXNzaW9uSWQsXG4gICAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzLFxuICAgICAgd2FsbGV0SWQ6IHNlc3Npb24ud2FsbGV0SWRcbiAgICB9KTtcbiAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgIT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgIGNvbnN0IHVybFNlc3Npb25JZCA9IHRoaXMudXJsUGFyYW1zQWNjZXNzb3IuZ2V0UGFyYW0oXCJzZXNzaW9uX2lkXCIpO1xuICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBcInBlbmRpbmdcIiAmJiAhdXJsU2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNlc3Npb24gbWlzbWF0Y2ggZGV0ZWN0ZWQgLSBwZW5kaW5nIHNlc3Npb24gd2l0aG91dCByZWRpcmVjdCBjb250ZXh0XCIsIHtcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb24uc2Vzc2lvbklkLFxuICAgICAgICAgIHN0YXR1czogc2Vzc2lvbi5zdGF0dXNcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5jbGVhclNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHVybFNlc3Npb25JZCAmJiB1cmxTZXNzaW9uSWQgIT09IHNlc3Npb24uc2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNlc3Npb24gSUQgbWlzbWF0Y2ggZGV0ZWN0ZWRcIiwge1xuICAgICAgICAgIHN0b3JlZFNlc3Npb25JZDogc2Vzc2lvbi5zZXNzaW9uSWQsXG4gICAgICAgICAgdXJsU2Vzc2lvbklkXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3JhZ2UuY2xlYXJTZXNzaW9uKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vzc2lvbi5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIgJiYgIXRoaXMuaXNTZXNzaW9uVmFsaWQoc2Vzc2lvbikpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIFwiRU1CRURERURfUFJPVklERVJcIixcbiAgICAgICAgXCJTZXNzaW9uIGludmFsaWQgZHVlIHRvIGF1dGhlbnRpY2F0b3IgZXhwaXJhdGlvbiwgd2lsbCByZWdlbmVyYXRlIGtleXBhaXJcIixcbiAgICAgICAge1xuICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbi5zZXNzaW9uSWQsXG4gICAgICAgICAgYXV0aGVudGljYXRvckV4cGlyZXNBdDogc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0LFxuICAgICAgICAgIGN1cnJlbnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGV4cGlyZWQ6IHNlc3Npb24uYXV0aGVudGljYXRvckV4cGlyZXNBdCA8IERhdGUubm93KClcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5jbGVhclNlc3Npb24oKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfVxuICAvKlxuICAgKiBTaGFyZWQgY29ubmVjdGlvbiBsb2dpYyBmb3IgYm90aCBjb25uZWN0KCkgYW5kIGF1dG9Db25uZWN0KCkuXG4gICAqIEhhbmRsZXMgZXhpc3Rpbmcgc2Vzc2lvbiB2YWxpZGF0aW9uLCByZWRpcmVjdCByZXN1bWUsIGFuZCBzZXNzaW9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBSZXR1cm5zIENvbm5lY3RSZXN1bHQgaWYgY29ubmVjdGlvbiBzdWNjZWVkcywgbnVsbCBpZiBzaG91bGQgY29udGludWUgd2l0aCBuZXcgYXV0aCBmbG93LlxuICAgKi9cbiAgYXN5bmMgdHJ5RXhpc3RpbmdDb25uZWN0aW9uKGlzQXV0b0Nvbm5lY3QpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkdldHRpbmcgZXhpc3Rpbmcgc2Vzc2lvblwiKTtcbiAgICBsZXQgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgc2Vzc2lvbiA9IGF3YWl0IHRoaXMudmFsaWRhdGVBbmRDbGVhblNlc3Npb24oc2Vzc2lvbik7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIk5vIGV4aXN0aW5nIHNlc3Npb24gZm91bmRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJVc2luZyBleGlzdGluZyBjb21wbGV0ZWQgc2Vzc2lvblwiLCB7XG4gICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbi5zZXNzaW9uSWQsXG4gICAgICAgIHdhbGxldElkOiBzZXNzaW9uLndhbGxldElkXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUNsaWVudEZyb21TZXNzaW9uKHNlc3Npb24pO1xuICAgICAgc2Vzc2lvbi5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJDb25uZWN0aW9uIGZyb20gZXhpc3Rpbmcgc2Vzc2lvbiBzdWNjZXNzZnVsXCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICAgIGFkZHJlc3NDb3VudDogdGhpcy5hZGRyZXNzZXMubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlVmFsaWRBdXRoZW50aWNhdG9yKCk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICBhZGRyZXNzZXM6IHRoaXMuYWRkcmVzc2VzLFxuICAgICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgICAgIGF1dGhVc2VySWQ6IHNlc3Npb24uYXV0aFVzZXJJZCxcbiAgICAgICAgYXV0aFByb3ZpZGVyOiBzZXNzaW9uLmF1dGhQcm92aWRlclxuICAgICAgfTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHNvdXJjZTogXCJleGlzdGluZy1zZXNzaW9uXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJObyBjb21wbGV0ZWQgc2Vzc2lvbiBmb3VuZCwgY2hlY2tpbmcgZm9yIHJlZGlyZWN0IHJlc3VtZVwiKTtcbiAgICBpZiAodGhpcy5hdXRoUHJvdmlkZXIucmVzdW1lQXV0aEZyb21SZWRpcmVjdCkge1xuICAgICAgY29uc3QgYXV0aFJlc3VsdCA9IHRoaXMuYXV0aFByb3ZpZGVyLnJlc3VtZUF1dGhGcm9tUmVkaXJlY3Qoc2Vzc2lvbi5hdXRoUHJvdmlkZXIpO1xuICAgICAgaWYgKGF1dGhSZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiUmVzdW1pbmcgZnJvbSByZWRpcmVjdFwiLCB7XG4gICAgICAgICAgd2FsbGV0SWQ6IGF1dGhSZXN1bHQud2FsbGV0SWQsXG4gICAgICAgICAgcHJvdmlkZXI6IGF1dGhSZXN1bHQucHJvdmlkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tcGxldGVBdXRoQ29ubmVjdGlvbihhdXRoUmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiTm8gc2Vzc2lvbiBmb3VuZCBhZnRlciByZWRpcmVjdFwiKSAmJiAhaXNBdXRvQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICAgICAgXCJFTUJFRERFRF9QUk9WSURFUlwiLFxuICAgICAgICAgICAgICBcIlNlc3Npb24gbWlzc2luZyBkdXJpbmcgcmVkaXJlY3QgcmVzdW1lIC0gd2lsbCBzdGFydCBmcmVzaCBhdXRoIGZsb3dcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHdhbGxldElkOiBhdXRoUmVzdWx0LndhbGxldElkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JhZ2UuY2xlYXJTZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLypcbiAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHRvIHZhbGlkYXRlIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnMgYmVmb3JlIHByb2Nlc3NpbmcgdGhlbS5cbiAgICogVGhpcyBlbnN1cmVzIG9ubHkgc3VwcG9ydGVkIGF1dGggcHJvdmlkZXJzIGFyZSB1c2VkIGFuZCByZXF1aXJlZCB0b2tlbnMgYXJlIHByZXNlbnQuXG4gICAqL1xuICB2YWxpZGF0ZUF1dGhPcHRpb25zKGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKCFFTUJFRERFRF9QUk9WSURFUl9BVVRIX1RZUEVTLmluY2x1ZGVzKGF1dGhPcHRpb25zLnByb3ZpZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBhdXRoIHByb3ZpZGVyOiAke2F1dGhPcHRpb25zLnByb3ZpZGVyfS4gTXVzdCBiZSAke0VNQkVEREVEX1BST1ZJREVSX0FVVEhfVFlQRVMuam9pbihcIiwgXCIpfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byB2YWxpZGF0ZSBpZiBhIHNlc3Npb24gaXMgc3RpbGwgdmFsaWQuXG4gICAqIFRoaXMgY2hlY2tzIHNlc3Npb24gc3RhdHVzLCByZXF1aXJlZCBmaWVsZHMsIGFuZCBhdXRoZW50aWNhdG9yIGV4cGlyYXRpb24uXG4gICAqIFNlc3Npb25zIG5ldmVyIGV4cGlyZSBieSBhZ2UgLSBvbmx5IGF1dGhlbnRpY2F0b3JzIGV4cGlyZS5cbiAgICovXG4gIGlzU2Vzc2lvblZhbGlkKHNlc3Npb24pIHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzZXNzaW9uLndhbGxldElkIHx8ICFzZXNzaW9uLm9yZ2FuaXphdGlvbklkIHx8ICFzZXNzaW9uLnN0YW1wZXJJbmZvKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNlc3Npb24gbWlzc2luZyByZXF1aXJlZCBmaWVsZHNcIiwge1xuICAgICAgICBoYXNXYWxsZXRJZDogISFzZXNzaW9uLndhbGxldElkLFxuICAgICAgICBoYXNPcmdhbml6YXRpb25JZDogISFzZXNzaW9uLm9yZ2FuaXphdGlvbklkLFxuICAgICAgICBoYXNTdGFtcGVySW5mbzogISFzZXNzaW9uLnN0YW1wZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24uc3RhdHVzICE9PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNlc3Npb24gbm90IGNvbXBsZXRlZFwiLCB7IHN0YXR1czogc2Vzc2lvbi5zdGF0dXMgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0KSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNlc3Npb24gaW52YWxpZCAtIG1pc3NpbmcgYXV0aGVudGljYXRvciB0aW1pbmdcIiwge1xuICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb24uc2Vzc2lvbklkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKERhdGUubm93KCkgPj0gc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0KSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkF1dGhlbnRpY2F0b3IgZXhwaXJlZCwgc2Vzc2lvbiBpbnZhbGlkXCIsIHtcbiAgICAgICAgYXV0aGVudGljYXRvckV4cGlyZXNBdDogbmV3IERhdGUoc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBub3c6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2Vzc2lvbiBpcyB2YWxpZFwiLCB7XG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb24uc2Vzc2lvbklkLFxuICAgICAgd2FsbGV0SWQ6IHNlc3Npb24ud2FsbGV0SWQsXG4gICAgICBhdXRoZW50aWNhdG9yRXhwaXJlczogbmV3IERhdGUoc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0KS50b0lTT1N0cmluZygpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLypcbiAgICogUHVibGljIG1ldGhvZCB0byBhdHRlbXB0IGF1dG8tY29ubmVjdGlvbiB1c2luZyBhbiBleGlzdGluZyB2YWxpZCBzZXNzaW9uLlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgc2V0dGluZyB1cCBldmVudCBsaXN0ZW5lcnMgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgKiBTaWxlbnRseSBmYWlscyBpZiBubyB2YWxpZCBzZXNzaW9uIGV4aXN0cywgZW5hYmxpbmcgc2VhbWxlc3MgcmVjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgYXV0b0Nvbm5lY3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU3RhcnRpbmcgYXV0by1jb25uZWN0IGF0dGVtcHRcIik7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0X3N0YXJ0XCIsIHsgc291cmNlOiBcImF1dG8tY29ubmVjdFwiIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy50cnlFeGlzdGluZ0Nvbm5lY3Rpb24odHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkF1dG8tY29ubmVjdCBzdWNjZXNzZnVsXCIsIHtcbiAgICAgICAgICB3YWxsZXRJZDogcmVzdWx0LndhbGxldElkLFxuICAgICAgICAgIGFkZHJlc3NDb3VudDogcmVzdWx0LmFkZHJlc3Nlcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICBzb3VyY2U6IFwiYXV0by1jb25uZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiQXV0by1jb25uZWN0IGZhaWxlZDogbm8gdmFsaWQgc2Vzc2lvbiBmb3VuZFwiKTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RfZXJyb3JcIiwge1xuICAgICAgICBlcnJvcjogXCJObyB2YWxpZCBzZXNzaW9uIGZvdW5kXCIsXG4gICAgICAgIHNvdXJjZTogXCJhdXRvLWNvbm5lY3RcIlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJBdXRvLWNvbm5lY3QgZmFpbGVkXCIsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0X2Vycm9yXCIsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJBdXRvLWNvbm5lY3QgZmFpbGVkXCIsXG4gICAgICAgIHNvdXJjZTogXCJhdXRvLWNvbm5lY3RcIlxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2V0U2hvdWxkQ2xlYXJQcmV2aW91c1Nlc3Npb24odHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byBpbml0aWFsaXplIHRoZSBzdGFtcGVyIGFuZCBjcmVhdGUgYW4gb3JnYW5pemF0aW9uIGZvciBuZXcgc2Vzc2lvbnMuXG4gICAqIFRoaXMgaXMgdGhlIGZpcnN0IHN0ZXAgd2hlbiBubyBleGlzdGluZyBzZXNzaW9uIGlzIGZvdW5kIGFuZCB3ZSBuZWVkIHRvIHNldCB1cCBhIG5ldyB3YWxsZXQuXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplU3RhbXBlcigpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkluaXRpYWxpemluZyBzdGFtcGVyXCIpO1xuICAgIGF3YWl0IHRoaXMuc3RhbXBlci5pbml0KCk7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJSZXNldHRpbmcga2V5cGFpciB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXlwYWlyc1wiKTtcbiAgICBjb25zdCBzdGFtcGVySW5mbyA9IGF3YWl0IHRoaXMuc3RhbXBlci5yZXNldEtleVBhaXIoKTtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlN0YW1wZXIgaW5pdGlhbGl6ZWQgd2l0aCBmcmVzaCBrZXlwYWlyXCIsIHtcbiAgICAgIHB1YmxpY0tleTogc3RhbXBlckluZm8ucHVibGljS2V5LFxuICAgICAga2V5SWQ6IHN0YW1wZXJJbmZvLmtleUlkLFxuICAgICAgYWxnb3JpdGhtOiB0aGlzLnN0YW1wZXIuYWxnb3JpdGhtXG4gICAgfSk7XG4gICAgY29uc3QgZXhwaXJlc0luTXMgPSBBVVRIRU5USUNBVE9SX0VYUElSQVRJT05fVElNRV9NUztcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJTdGFtcGVyIHJlYWR5IGZvciBhdXRoIGZsb3cgd2l0aCBmcmVzaCBrZXlwYWlyXCIsIHtcbiAgICAgIHB1YmxpY0tleTogc3RhbXBlckluZm8ucHVibGljS2V5LFxuICAgICAga2V5SWQ6IHN0YW1wZXJJbmZvLmtleUlkXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3RhbXBlckluZm8sIGV4cGlyZXNJbk1zIH07XG4gIH1cbiAgYXN5bmMgY3JlYXRlT3JnYW5pemF0aW9uRm9yQXBwV2FsbGV0KHN0YW1wZXJJbmZvLCBleHBpcmVzSW5Ncykge1xuICAgIGNvbnN0IHRlbXBDbGllbnQgPSBuZXcgUGhhbnRvbUNsaWVudCh7XG4gICAgICBhcGlCYXNlVXJsOiB0aGlzLmNvbmZpZy5hcGlCYXNlVXJsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLnBsYXRmb3JtLmFuYWx5dGljc0hlYWRlcnMgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwbGF0Zm9ybU5hbWUgPSB0aGlzLnBsYXRmb3JtLm5hbWUgfHwgXCJ1bmtub3duXCI7XG4gICAgY29uc3Qgc2hvcnRQdWJLZXkgPSBzdGFtcGVySW5mby5wdWJsaWNLZXkuc2xpY2UoMCwgOCk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uTmFtZSA9IGAke3RoaXMuY29uZmlnLmFwcElkLnN1YnN0cmluZygwLCA4KX0tJHtwbGF0Zm9ybU5hbWV9LSR7c2hvcnRQdWJLZXl9YDtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkNyZWF0aW5nIG9yZ2FuaXphdGlvbiBmb3IgYXBwLXdhbGxldFwiLCB7XG4gICAgICBvcmdhbml6YXRpb25OYW1lLFxuICAgICAgcHVibGljS2V5OiBzdGFtcGVySW5mby5wdWJsaWNLZXksXG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm1OYW1lXG4gICAgfSk7XG4gICAgY29uc3QgYmFzZTY0dXJsUHVibGljS2V5ID0gYmFzZTY0dXJsRW5jb2RlKGJzNTgyLmRlY29kZShzdGFtcGVySW5mby5wdWJsaWNLZXkpKTtcbiAgICBjb25zdCB1c2VybmFtZSA9IGB1c2VyLSR7cmFuZG9tVVVJRCgpfWA7XG4gICAgY29uc3QgeyBvcmdhbml6YXRpb25JZCB9ID0gYXdhaXQgdGVtcENsaWVudC5jcmVhdGVPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uTmFtZSwgW1xuICAgICAge1xuICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgcm9sZTogXCJBRE1JTlwiLFxuICAgICAgICBhdXRoZW50aWNhdG9yczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JOYW1lOiBgYXV0aC0ke3Nob3J0UHViS2V5fWAsXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yS2luZDogXCJrZXlwYWlyXCIsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGJhc2U2NHVybFB1YmxpY0tleSxcbiAgICAgICAgICAgIGFsZ29yaXRobTogXCJFZDI1NTE5XCIsXG4gICAgICAgICAgICBleHBpcmVzSW5Nc1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIk9yZ2FuaXphdGlvbiBjcmVhdGVkIGZvciBhcHAtd2FsbGV0XCIsIHsgb3JnYW5pemF0aW9uSWQgfSk7XG4gICAgcmV0dXJuIG9yZ2FuaXphdGlvbklkO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoYXV0aE9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU3RhcnRpbmcgZW1iZWRkZWQgcHJvdmlkZXIgY29ubmVjdFwiLCB7XG4gICAgICAgIGF1dGhPcHRpb25zOiB7XG4gICAgICAgICAgcHJvdmlkZXI6IGF1dGhPcHRpb25zLnByb3ZpZGVyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdF9zdGFydFwiLCB7XG4gICAgICAgIHNvdXJjZTogXCJtYW51YWwtY29ubmVjdFwiLFxuICAgICAgICBhdXRoT3B0aW9uczogeyBwcm92aWRlcjogYXV0aE9wdGlvbnMucHJvdmlkZXIgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBleGlzdGluZ1Jlc3VsdCA9IGF3YWl0IHRoaXMudHJ5RXhpc3RpbmdDb25uZWN0aW9uKGZhbHNlKTtcbiAgICAgIGlmIChleGlzdGluZ1Jlc3VsdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJNYW51YWwgY29ubmVjdCB1c2luZyBleGlzdGluZyBjb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICB3YWxsZXRJZDogZXhpc3RpbmdSZXN1bHQud2FsbGV0SWQsXG4gICAgICAgICAgYWRkcmVzc0NvdW50OiBleGlzdGluZ1Jlc3VsdC5hZGRyZXNzZXMubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIsIHtcbiAgICAgICAgICAuLi5leGlzdGluZ1Jlc3VsdCxcbiAgICAgICAgICBzb3VyY2U6IFwibWFudWFsLWV4aXN0aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Jlc3VsdDtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVBdXRoT3B0aW9ucyhhdXRoT3B0aW9ucyk7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICBcIkVNQkVEREVEX1BST1ZJREVSXCIsXG4gICAgICAgIFwiTm8gZXhpc3RpbmcgY29ubmVjdGlvbiBhdmFpbGFibGUsIGNyZWF0aW5nIG5ldyBhdXRoIGZsb3cgd2l0aCBmcmVzaCBrZXlwYWlyXCJcbiAgICAgICk7XG4gICAgICBjb25zdCB7IHN0YW1wZXJJbmZvLCBleHBpcmVzSW5NcyB9ID0gYXdhaXQgdGhpcy5pbml0aWFsaXplU3RhbXBlcigpO1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuaGFuZGxlQXV0aEZsb3coc3RhbXBlckluZm8ucHVibGljS2V5LCBzdGFtcGVySW5mbywgYXV0aE9wdGlvbnMsIGV4cGlyZXNJbk1zKTtcbiAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFkZHJlc3NlczogW10sXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBhdXRoUHJvdmlkZXI6IGF1dGhPcHRpb25zLnByb3ZpZGVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25maWcuZW1iZWRkZWRXYWxsZXRUeXBlID09PSBcImFwcC13YWxsZXRcIikge1xuICAgICAgICBzZXNzaW9uLmxhc3RVc2VkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnNhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ2xpZW50RnJvbVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICBhd2FpdCB0aGlzLmVuc3VyZVZhbGlkQXV0aGVudGljYXRvcigpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgICAgYWRkcmVzc2VzOiB0aGlzLmFkZHJlc3NlcyxcbiAgICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgICBhdXRoVXNlcklkOiBzZXNzaW9uPy5hdXRoVXNlcklkLFxuICAgICAgICBhdXRoUHJvdmlkZXI6IHNlc3Npb24/LmF1dGhQcm92aWRlclxuICAgICAgfTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHNvdXJjZTogXCJtYW51YWxcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiQ29ubmVjdCBmYWlsZWQgd2l0aCBlcnJvclwiLCB7XG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8ge1xuICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgfSA6IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RfZXJyb3JcIiwge1xuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICBzb3VyY2U6IFwibWFudWFsLWNvbm5lY3RcIlxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkluZGV4ZWREQlwiKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwic3RvcmFnZVwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiU3RvcmFnZSBlcnJvcjogVW5hYmxlIHRvIGFjY2VzcyBicm93c2VyIHN0b3JhZ2UuIFBsZWFzZSBlbnN1cmUgc3RvcmFnZSBpcyBhdmFpbGFibGUgYW5kIHRyeSBhZ2Fpbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJuZXR3b3JrXCIpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJmZXRjaFwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIGNvbm5lY3QgdG8gYXV0aGVudGljYXRpb24gc2VydmVyLiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiSldUXCIpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJqd3RcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEpXVCBBdXRoZW50aWNhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiQXV0aGVudGljYXRpb25cIikgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImF1dGhcIikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJvcmdhbml6YXRpb25cIikgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIndhbGxldFwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2FsbGV0IGNyZWF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtYmVkZGVkIHdhbGxldCBjb25uZWN0aW9uIGZhaWxlZDogJHtTdHJpbmcoZXJyb3IpfWApO1xuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KHNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IHRoaXMuY2xpZW50ICE9PSBudWxsO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zZXRTaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbihzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbik7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJTZXQgZmxhZyB0byBjbGVhciBwcmV2aW91cyBzZXNzaW9uIG9uIG5leHQgbG9naW5cIik7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLmNsZWFyU2Vzc2lvbigpO1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgICB0aGlzLndhbGxldElkID0gbnVsbDtcbiAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkRpc2Nvbm5lY3RlZCBmcm9tIGVtYmVkZGVkIHdhbGxldFwiKTtcbiAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIHtcbiAgICAgICAgc291cmNlOiBcIm1hbnVhbFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCB8fCAhdGhpcy53YWxsZXRJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVWYWxpZEF1dGhlbnRpY2F0b3IoKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJTaWduaW5nIG1lc3NhZ2VcIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICBtZXNzYWdlOiBwYXJhbXMubWVzc2FnZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHNlc3Npb24/LmFjY291bnREZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICBjb25zdCByYXdSZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnNpZ25VdGY4TWVzc2FnZSh7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlLFxuICAgICAgbmV0d29ya0lkOiBwYXJhbXMubmV0d29ya0lkLFxuICAgICAgZGVyaXZhdGlvbkluZGV4XG4gICAgfSk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiTWVzc2FnZSBzaWduZWQgc3VjY2Vzc2Z1bGx5XCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VTaWduTWVzc2FnZVJlc3BvbnNlKHJhd1Jlc3BvbnNlLCBwYXJhbXMubmV0d29ya0lkKTtcbiAgfVxuICBhc3luYyBzaWduRXRoZXJldW1NZXNzYWdlKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jbGllbnQgfHwgIXRoaXMud2FsbGV0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlVmFsaWRBdXRoZW50aWNhdG9yKCk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2lnbmluZyBtZXNzYWdlXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2VcbiAgICB9KTtcbiAgICBjb25zdCBsb29rc0xpa2VIZXggPSAoc3RyKSA9PiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChzdHIpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRNZXNzYWdlID0gKCgpID0+IHtcbiAgICAgIGlmIChsb29rc0xpa2VIZXgocGFyYW1zLm1lc3NhZ2UpKSB7XG4gICAgICAgIGNvbnN0IGhleFBheWxvYWQgPSBwYXJhbXMubWVzc2FnZS5zbGljZSgyKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEhleCA9IGhleFBheWxvYWQubGVuZ3RoICUgMiA9PT0gMCA/IGhleFBheWxvYWQgOiBgMCR7aGV4UGF5bG9hZH1gO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20obm9ybWFsaXplZEhleCwgXCJoZXhcIikudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcy5tZXNzYWdlO1xuICAgIH0pKCk7XG4gICAgY29uc3QgYmFzZTY0VXJsTWVzc2FnZSA9IHN0cmluZ1RvQmFzZTY0dXJsKG5vcm1hbGl6ZWRNZXNzYWdlKTtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5zdG9yYWdlLmdldFNlc3Npb24oKTtcbiAgICBjb25zdCBkZXJpdmF0aW9uSW5kZXggPSBzZXNzaW9uPy5hY2NvdW50RGVyaXZhdGlvbkluZGV4ID8/IDA7XG4gICAgY29uc3QgcmF3UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5ldGhlcmV1bVNpZ25NZXNzYWdlKHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgbWVzc2FnZTogYmFzZTY0VXJsTWVzc2FnZSxcbiAgICAgIG5ldHdvcmtJZDogcGFyYW1zLm5ldHdvcmtJZCxcbiAgICAgIGRlcml2YXRpb25JbmRleFxuICAgIH0pO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIk1lc3NhZ2Ugc2lnbmVkIHN1Y2Nlc3NmdWxseVwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIG1lc3NhZ2U6IHBhcmFtcy5tZXNzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlU2lnbk1lc3NhZ2VSZXNwb25zZShyYXdSZXNwb25zZSwgcGFyYW1zLm5ldHdvcmtJZCk7XG4gIH1cbiAgYXN5bmMgc2lnblR5cGVkRGF0YVY0KHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jbGllbnQgfHwgIXRoaXMud2FsbGV0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlVmFsaWRBdXRoZW50aWNhdG9yKCk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2lnbmluZyB0eXBlZCBkYXRhXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgdHlwZWREYXRhOiBwYXJhbXMudHlwZWREYXRhXG4gICAgfSk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgY29uc3QgZGVyaXZhdGlvbkluZGV4ID0gc2Vzc2lvbj8uYWNjb3VudERlcml2YXRpb25JbmRleCA/PyAwO1xuICAgIGNvbnN0IHJhd1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuZXRoZXJldW1TaWduVHlwZWREYXRhKHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgdHlwZWREYXRhOiBwYXJhbXMudHlwZWREYXRhLFxuICAgICAgbmV0d29ya0lkOiBwYXJhbXMubmV0d29ya0lkLFxuICAgICAgZGVyaXZhdGlvbkluZGV4XG4gICAgfSk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiVHlwZWQgZGF0YSBzaWduZWQgc3VjY2Vzc2Z1bGx5XCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlU2lnbk1lc3NhZ2VSZXNwb25zZShyYXdSZXNwb25zZSwgcGFyYW1zLm5ldHdvcmtJZCk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5jbGllbnQgfHwgIXRoaXMud2FsbGV0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlVmFsaWRBdXRoZW50aWNhdG9yKCk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2lnbmluZyB0cmFuc2FjdGlvblwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIG5ldHdvcmtJZDogcGFyYW1zLm5ldHdvcmtJZFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnNlZFRyYW5zYWN0aW9uID0gYXdhaXQgcGFyc2VUb0ttc1RyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgcGFyYW1zLm5ldHdvcmtJZCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgY29uc3QgZGVyaXZhdGlvbkluZGV4ID0gc2Vzc2lvbj8uYWNjb3VudERlcml2YXRpb25JbmRleCA/PyAwO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiUGFyc2VkIHRyYW5zYWN0aW9uIGZvciBzaWduaW5nXCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgdHJhbnNhY3Rpb246IHBhcnNlZFRyYW5zYWN0aW9uLFxuICAgICAgZGVyaXZhdGlvbkluZGV4XG4gICAgfSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25QYXlsb2FkID0gcGFyc2VkVHJhbnNhY3Rpb24ucGFyc2VkO1xuICAgIGlmICghdHJhbnNhY3Rpb25QYXlsb2FkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgdHJhbnNhY3Rpb246IG5vIHZhbGlkIGVuY29kaW5nIGZvdW5kXCIpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0gdGhpcy5nZXRBZGRyZXNzRm9yTmV0d29yayhwYXJhbXMubmV0d29ya0lkKTtcbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYWRkcmVzcyBmb3VuZCBmb3IgbmV0d29yayAke3BhcmFtcy5uZXR3b3JrSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJhd1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uUGF5bG9hZCxcbiAgICAgIG5ldHdvcmtJZDogcGFyYW1zLm5ldHdvcmtJZCxcbiAgICAgIGRlcml2YXRpb25JbmRleCxcbiAgICAgIGFjY291bnRcbiAgICB9KTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJUcmFuc2FjdGlvbiBzaWduZWQgc3VjY2Vzc2Z1bGx5XCIsIHtcbiAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgbmV0d29ya0lkOiBwYXJhbXMubmV0d29ya0lkLFxuICAgICAgcmF3VHJhbnNhY3Rpb246IHJhd1Jlc3BvbnNlLnJhd1RyYW5zYWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHBhcnNlVHJhbnNhY3Rpb25SZXNwb25zZShyYXdSZXNwb25zZS5yYXdUcmFuc2FjdGlvbiwgcGFyYW1zLm5ldHdvcmtJZCk7XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50IHx8ICF0aGlzLndhbGxldElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmVuc3VyZVZhbGlkQXV0aGVudGljYXRvcigpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlNpZ25pbmcgYW5kIHNlbmRpbmcgdHJhbnNhY3Rpb25cIiwge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICBuZXR3b3JrSWQ6IHBhcmFtcy5uZXR3b3JrSWRcbiAgICB9KTtcbiAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHBhcnNlVG9LbXNUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHBhcmFtcy5uZXR3b3JrSWQpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLnN0b3JhZ2UuZ2V0U2Vzc2lvbigpO1xuICAgIGNvbnN0IGRlcml2YXRpb25JbmRleCA9IHNlc3Npb24/LmFjY291bnREZXJpdmF0aW9uSW5kZXggPz8gMDtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlBhcnNlZCB0cmFuc2FjdGlvbiBmb3Igc2lnbmluZ1wiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIHRyYW5zYWN0aW9uOiBwYXJzZWRUcmFuc2FjdGlvbixcbiAgICAgIGRlcml2YXRpb25JbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUGF5bG9hZCA9IHBhcnNlZFRyYW5zYWN0aW9uLnBhcnNlZDtcbiAgICBpZiAoIXRyYW5zYWN0aW9uUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHRyYW5zYWN0aW9uOiBubyB2YWxpZCBlbmNvZGluZyBmb3VuZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IHRoaXMuZ2V0QWRkcmVzc0Zvck5ldHdvcmsocGFyYW1zLm5ldHdvcmtJZCk7XG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFkZHJlc3MgZm91bmQgZm9yIG5ldHdvcmsgJHtwYXJhbXMubmV0d29ya0lkfWApO1xuICAgIH1cbiAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJhd1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25QYXlsb2FkLFxuICAgICAgICBuZXR3b3JrSWQ6IHBhcmFtcy5uZXR3b3JrSWQsXG4gICAgICAgIGRlcml2YXRpb25JbmRleCxcbiAgICAgICAgYWNjb3VudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNwZW5kaW5nTGltaXRFcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoXCJzcGVuZGluZ19saW1pdF9yZWFjaGVkXCIsIHsgZXJyb3IgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiVHJhbnNhY3Rpb24gc2lnbmVkIGFuZCBzZW50IHN1Y2Nlc3NmdWxseVwiLCB7XG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIG5ldHdvcmtJZDogcGFyYW1zLm5ldHdvcmtJZCxcbiAgICAgIGhhc2g6IHJhd1Jlc3BvbnNlLmhhc2gsXG4gICAgICByYXdUcmFuc2FjdGlvbjogcmF3UmVzcG9uc2UucmF3VHJhbnNhY3Rpb25cbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VUcmFuc2FjdGlvblJlc3BvbnNlKHJhd1Jlc3BvbnNlLnJhd1RyYW5zYWN0aW9uLCBwYXJhbXMubmV0d29ya0lkLCByYXdSZXNwb25zZS5oYXNoKTtcbiAgfVxuICBnZXRBZGRyZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkcmVzc2VzO1xuICB9XG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudCAhPT0gbnVsbCAmJiB0aGlzLndhbGxldElkICE9PSBudWxsO1xuICB9XG4gIC8qXG4gICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byByb3V0ZSBiZXR3ZWVuIGRpZmZlcmVudCBhdXRoZW50aWNhdGlvbiBmbG93cyBiYXNlZCBvbiB3YWxsZXQgdHlwZSBhbmQgYXV0aCBvcHRpb25zLlxuICAgKiBJdCBoYW5kbGVzIGFwcC13YWxsZXQgY3JlYXRpb24gZGlyZWN0bHkgb3Igcm91dGVzIHRvIEpXVC9yZWRpcmVjdCBhdXRoZW50aWNhdGlvbiBmb3IgdXNlci13YWxsZXRzLlxuICAgKiBSZXR1cm5zIG51bGwgZm9yIHJlZGlyZWN0IGZsb3dzIHNpbmNlIHRoZXkgZG9uJ3QgY29tcGxldGUgc3luY2hyb25vdXNseS5cbiAgICovXG4gIGFzeW5jIGhhbmRsZUF1dGhGbG93KHB1YmxpY0tleSwgc3RhbXBlckluZm8sIGF1dGhPcHRpb25zLCBleHBpcmVzSW5Ncykge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbWJlZGRlZFdhbGxldFR5cGUgPT09IFwidXNlci13YWxsZXRcIikge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiQ3JlYXRpbmcgdXNlci13YWxsZXQsIHJvdXRpbmcgYXV0aGVudGljYXRpb25cIiwge1xuICAgICAgICBhdXRoUHJvdmlkZXI6IGF1dGhPcHRpb25zLnByb3ZpZGVyXG4gICAgICB9KTtcbiAgICAgIGlmIChhdXRoT3B0aW9ucy5wcm92aWRlciA9PT0gXCJwaGFudG9tXCIpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlUGhhbnRvbUF1dGgocHVibGljS2V5LCBzdGFtcGVySW5mbywgZXhwaXJlc0luTXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU3RhcnRpbmcgcmVkaXJlY3QtYmFzZWQgYXV0aGVudGljYXRpb24gZmxvd1wiLCB7XG4gICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgIHByb3ZpZGVyOiBhdXRoT3B0aW9ucz8ucHJvdmlkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVJlZGlyZWN0QXV0aChwdWJsaWNLZXksIHN0YW1wZXJJbmZvLCBhdXRoT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkNyZWF0aW5nIGFwcC13YWxsZXRcIiwge1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgb3JnYW5pemF0aW9uSWQgPSBhd2FpdCB0aGlzLmNyZWF0ZU9yZ2FuaXphdGlvbkZvckFwcFdhbGxldChzdGFtcGVySW5mbywgZXhwaXJlc0luTXMpO1xuICAgICAgY29uc3QgdGVtcENsaWVudCA9IG5ldyBQaGFudG9tQ2xpZW50KFxuICAgICAgICB7XG4gICAgICAgICAgYXBpQmFzZVVybDogdGhpcy5jb25maWcuYXBpQmFzZVVybCxcbiAgICAgICAgICBvcmdhbml6YXRpb25JZCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi50aGlzLnBsYXRmb3JtLmFuYWx5dGljc0hlYWRlcnMgfHwge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuc3RhbXBlclxuICAgICAgKTtcbiAgICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IHRlbXBDbGllbnQuY3JlYXRlV2FsbGV0KGBXYWxsZXQgJHtEYXRlLm5vdygpfWApO1xuICAgICAgY29uc3Qgd2FsbGV0SWQgPSB3YWxsZXQud2FsbGV0SWQ7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgc2Vzc2lvbklkOiBnZW5lcmF0ZVNlc3Npb25JZCgpLFxuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQsXG4gICAgICAgIGFwcElkOiB0aGlzLmNvbmZpZy5hcHBJZCxcbiAgICAgICAgc3RhbXBlckluZm8sXG4gICAgICAgIGF1dGhQcm92aWRlcjogXCJkZXZpY2VcIixcbiAgICAgICAgLy8gRm9yIG5vdyBhcHAgd2FsbGV0cyBoYXZlIG5vIGF1dGggcHJvdmlkZXIuXG4gICAgICAgIGFjY291bnREZXJpdmF0aW9uSW5kZXg6IDAsXG4gICAgICAgIC8vIEFwcCB3YWxsZXRzIGRlZmF1bHQgdG8gaW5kZXggMFxuICAgICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICBsYXN0VXNlZDogbm93LFxuICAgICAgICBhdXRoZW50aWNhdG9yQ3JlYXRlZEF0OiBub3csXG4gICAgICAgIGF1dGhlbnRpY2F0b3JFeHBpcmVzQXQ6IERhdGUubm93KCkgKyBleHBpcmVzSW5NcyxcbiAgICAgICAgbGFzdFJlbmV3YWxBdHRlbXB0OiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJBcHAtd2FsbGV0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5XCIsIHsgd2FsbGV0SWQsIG9yZ2FuaXphdGlvbklkIH0pO1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFdlIHVzZSB0aGlzIG1ldGhvZCB0byBoYW5kbGUgUGhhbnRvbSBhcHAtYmFzZWQgYXV0aGVudGljYXRpb24gZm9yIHVzZXItd2FsbGV0cy5cbiAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgUGhhbnRvbUFwcFByb3ZpZGVyIHRvIGF1dGhlbnRpY2F0ZSB2aWEgdGhlIGJyb3dzZXIgZXh0ZW5zaW9uIG9yIG1vYmlsZSBhcHAuXG4gICAqXG4gICAqIE5PVEU6IE1vYmlsZSBkZWVwbGluayBzdXBwb3J0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQuIElmIHdlIHdhbnRlZCB0byBzdXBwb3J0IG1vYmlsZSBkZWVwbGlua3MsXG4gICAqIHdlIHdvdWxkOlxuICAgKiAxLiBDaGVjayBpZiB0aGUgYXBwIHByb3ZpZGVyIGlzIGF2YWlsYWJsZSB1c2luZyBwaGFudG9tQXBwUHJvdmlkZXIuaXNBdmFpbGFibGUoKVxuICAgKiAyLiBJZiBub3QgYXZhaWxhYmxlLCBnZW5lcmF0ZSBhIGRlZXBsaW5rIChwaGFudG9tOi8vYXV0aD8uLi4pXG4gICAqIDMuIFNhdmUgYSBwZW5kaW5nIHNlc3Npb24gYmVmb3JlIG9wZW5pbmcgdGhlIGRlZXBsaW5rXG4gICAqIDQuIFN0YXJ0IGEgcG9sbGluZyBtZWNoYW5pc20gdG8gY2hlY2sgZm9yIGF1dGggY29tcGxldGlvblxuICAgKiA1LiBVcGRhdGUgdGhlIHNlc3Npb24gd2hlbiB0aGUgbW9iaWxlIGFwcCBjb21wbGV0ZXMgdGhlIGF1dGhcbiAgICovXG4gIGFzeW5jIGhhbmRsZVBoYW50b21BdXRoKHB1YmxpY0tleSwgc3RhbXBlckluZm8sIGV4cGlyZXNJbk1zKSB7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU3RhcnRpbmcgUGhhbnRvbSBhdXRoZW50aWNhdGlvbiBmbG93XCIpO1xuICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gdGhpcy5waGFudG9tQXBwUHJvdmlkZXIuaXNBdmFpbGFibGUoKTtcbiAgICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiUGhhbnRvbSBhcHAgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJQaGFudG9tIGFwcCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgaW5zdGFsbCB0aGUgUGhhbnRvbSBicm93c2VyIGV4dGVuc2lvbiBvciBtb2JpbGUgYXBwIHRvIHVzZSB0aGlzIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiUGhhbnRvbSBhcHAgZGV0ZWN0ZWQsIHByb2NlZWRpbmcgd2l0aCBhdXRoZW50aWNhdGlvblwiKTtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBnZW5lcmF0ZVNlc3Npb25JZCgpO1xuICAgIGNvbnN0IGF1dGhSZXN1bHQgPSBhd2FpdCB0aGlzLnBoYW50b21BcHBQcm92aWRlci5hdXRoZW50aWNhdGUoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgYXBwSWQ6IHRoaXMuY29uZmlnLmFwcElkLFxuICAgICAgc2Vzc2lvbklkXG4gICAgfSk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiUGhhbnRvbSBhdXRoZW50aWNhdGlvbiBjb21wbGV0ZWRcIiwge1xuICAgICAgd2FsbGV0SWQ6IGF1dGhSZXN1bHQud2FsbGV0SWQsXG4gICAgICBvcmdhbml6YXRpb25JZDogYXV0aFJlc3VsdC5vcmdhbml6YXRpb25JZFxuICAgIH0pO1xuICAgIGNvbnN0IGVmZmVjdGl2ZUV4cGlyZXNJbk1zID0gYXV0aFJlc3VsdC5leHBpcmVzSW5NcyA+IDAgPyBhdXRoUmVzdWx0LmV4cGlyZXNJbk1zIDogZXhwaXJlc0luTXM7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBzZXNzaW9uID0ge1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgd2FsbGV0SWQ6IGF1dGhSZXN1bHQud2FsbGV0SWQsXG4gICAgICBvcmdhbml6YXRpb25JZDogYXV0aFJlc3VsdC5vcmdhbml6YXRpb25JZCxcbiAgICAgIGFwcElkOiB0aGlzLmNvbmZpZy5hcHBJZCxcbiAgICAgIHN0YW1wZXJJbmZvLFxuICAgICAgYXV0aFByb3ZpZGVyOiBcInBoYW50b21cIixcbiAgICAgIGFjY291bnREZXJpdmF0aW9uSW5kZXg6IGF1dGhSZXN1bHQuYWNjb3VudERlcml2YXRpb25JbmRleCxcbiAgICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgbGFzdFVzZWQ6IG5vdyxcbiAgICAgIGF1dGhlbnRpY2F0b3JDcmVhdGVkQXQ6IG5vdyxcbiAgICAgIGF1dGhlbnRpY2F0b3JFeHBpcmVzQXQ6IG5vdyArIGVmZmVjdGl2ZUV4cGlyZXNJbk1zLFxuICAgICAgbGFzdFJlbmV3YWxBdHRlbXB0OiB2b2lkIDAsXG4gICAgICBhdXRoVXNlcklkOiBhdXRoUmVzdWx0LmF1dGhVc2VySWRcbiAgICB9O1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2F2aW5nIFBoYW50b20gc2Vzc2lvblwiKTtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgcmV0dXJuIHNlc3Npb247XG4gIH1cbiAgLypcbiAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSByZWRpcmVjdC1iYXNlZCBhdXRoZW50aWNhdGlvbiAoR29vZ2xlL0FwcGxlIE9BdXRoKS5cbiAgICogSXQgc2F2ZXMgYSB0ZW1wb3Jhcnkgc2Vzc2lvbiBiZWZvcmUgcmVkaXJlY3RpbmcgdG8gcHJldmVudCBsb3Npbmcgc3RhdGUgZHVyaW5nIHRoZSByZWRpcmVjdCBmbG93LlxuICAgKiBTZXNzaW9uIHRpbWVzdGFtcCBpcyB1cGRhdGVkIGJlZm9yZSByZWRpcmVjdCB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucy5cbiAgICovXG4gIGFzeW5jIGhhbmRsZVJlZGlyZWN0QXV0aChwdWJsaWNLZXksIHN0YW1wZXJJbmZvLCBhdXRoT3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlVzaW5nIFBoYW50b20gQ29ubmVjdCBhdXRoZW50aWNhdGlvbiBmbG93IChyZWRpcmVjdC1iYXNlZClcIiwge1xuICAgICAgcHJvdmlkZXI6IGF1dGhPcHRpb25zLnByb3ZpZGVyLFxuICAgICAgaGFzUmVkaXJlY3RVcmw6ICEhdGhpcy5jb25maWcuYXV0aE9wdGlvbnMucmVkaXJlY3RVcmwsXG4gICAgICBhdXRoVXJsOiB0aGlzLmNvbmZpZy5hdXRoT3B0aW9ucy5hdXRoVXJsXG4gICAgfSk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBnZW5lcmF0ZVNlc3Npb25JZCgpO1xuICAgIGNvbnN0IHRlbXBTZXNzaW9uID0ge1xuICAgICAgc2Vzc2lvbklkLFxuICAgICAgd2FsbGV0SWQ6IGB0ZW1wLXdhbGxldC0ke25vd31gLFxuICAgICAgLy8gVGVtcG9yYXJ5IElELCB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgcmVkaXJlY3RcbiAgICAgIG9yZ2FuaXphdGlvbklkOiBgdGVtcC1vcmctJHtub3d9YCxcbiAgICAgIC8vIFRlbXBvcmFyeSBJRCwgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIHJlZGlyZWN0XG4gICAgICBhcHBJZDogdGhpcy5jb25maWcuYXBwSWQsXG4gICAgICBzdGFtcGVySW5mbyxcbiAgICAgIGF1dGhQcm92aWRlcjogYXV0aE9wdGlvbnMucHJvdmlkZXIsXG4gICAgICBhY2NvdW50RGVyaXZhdGlvbkluZGV4OiB2b2lkIDAsXG4gICAgICAvLyBXaWxsIGJlIHNldCB3aGVuIHJlZGlyZWN0IGNvbXBsZXRlc1xuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgbGFzdFVzZWQ6IG5vdyxcbiAgICAgIGF1dGhlbnRpY2F0b3JDcmVhdGVkQXQ6IG5vdyxcbiAgICAgIGF1dGhlbnRpY2F0b3JFeHBpcmVzQXQ6IG5vdyArIEFVVEhFTlRJQ0FUT1JfRVhQSVJBVElPTl9USU1FX01TLFxuICAgICAgbGFzdFJlbmV3YWxBdHRlbXB0OiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2F2aW5nIHRlbXBvcmFyeSBzZXNzaW9uIGJlZm9yZSByZWRpcmVjdFwiLCB7XG4gICAgICBzZXNzaW9uSWQ6IHRlbXBTZXNzaW9uLnNlc3Npb25JZCxcbiAgICAgIHRlbXBXYWxsZXRJZDogdGVtcFNlc3Npb24ud2FsbGV0SWRcbiAgICB9KTtcbiAgICB0ZW1wU2Vzc2lvbi5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnNhdmVTZXNzaW9uKHRlbXBTZXNzaW9uKTtcbiAgICBjb25zdCBzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbigpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIlN0YXJ0aW5nIFBoYW50b20gQ29ubmVjdCByZWRpcmVjdFwiLCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBhcHBJZDogdGhpcy5jb25maWcuYXBwSWQsXG4gICAgICBwcm92aWRlcjogYXV0aE9wdGlvbnM/LnByb3ZpZGVyLFxuICAgICAgYXV0aFVybDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuYXV0aFVybCxcbiAgICAgIGNsZWFyUHJldmlvdXNTZXNzaW9uOiBzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbixcbiAgICAgIGFsbG93UmVmcmVzaDogIXNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uXG4gICAgfSk7XG4gICAgY29uc3QgYXV0aFJlc3VsdCA9IGF3YWl0IHRoaXMuYXV0aFByb3ZpZGVyLmF1dGhlbnRpY2F0ZSh7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBhcHBJZDogdGhpcy5jb25maWcuYXBwSWQsXG4gICAgICBwcm92aWRlcjogYXV0aE9wdGlvbnM/LnByb3ZpZGVyLFxuICAgICAgcmVkaXJlY3RVcmw6IHRoaXMuY29uZmlnLmF1dGhPcHRpb25zLnJlZGlyZWN0VXJsLFxuICAgICAgYXV0aFVybDogdGhpcy5jb25maWcuYXV0aE9wdGlvbnMuYXV0aFVybCxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIC8vIE9BdXRoIHNlc3Npb24gbWFuYWdlbWVudCAtIGRlZmF1bHRzIHRvIGFsbG93aW5nIHJlZnJlc2ggdW5sZXNzIHVzZXIgZXhwbGljaXRseSBsb2dnZWQgb3V0XG4gICAgICBjbGVhclByZXZpb3VzU2Vzc2lvbjogc2hvdWxkQ2xlYXJQcmV2aW91c1Nlc3Npb24sXG4gICAgICAvLyB0cnVlIG9ubHkgYWZ0ZXIgbG9nb3V0XG4gICAgICBhbGxvd1JlZnJlc2g6ICFzaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvblxuICAgICAgLy8gZmFsc2Ugb25seSBhZnRlciBsb2dvdXRcbiAgICB9KTtcbiAgICBpZiAoYXV0aFJlc3VsdCAmJiBcIndhbGxldElkXCIgaW4gYXV0aFJlc3VsdCkge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiQXV0aGVudGljYXRpb24gY29tcGxldGVkIGFmdGVyIHJlZGlyZWN0XCIsIHtcbiAgICAgICAgd2FsbGV0SWQ6IGF1dGhSZXN1bHQud2FsbGV0SWQsXG4gICAgICAgIG9yZ2FuaXphdGlvbklkOiBhdXRoUmVzdWx0Lm9yZ2FuaXphdGlvbklkLFxuICAgICAgICBwcm92aWRlcjogYXV0aFJlc3VsdC5wcm92aWRlclxuICAgICAgfSk7XG4gICAgICB0ZW1wU2Vzc2lvbi53YWxsZXRJZCA9IGF1dGhSZXN1bHQud2FsbGV0SWQ7XG4gICAgICB0ZW1wU2Vzc2lvbi5vcmdhbml6YXRpb25JZCA9IGF1dGhSZXN1bHQub3JnYW5pemF0aW9uSWQ7XG4gICAgICB0ZW1wU2Vzc2lvbi5hdXRoUHJvdmlkZXIgPSBhdXRoUmVzdWx0LnByb3ZpZGVyIHx8IHRlbXBTZXNzaW9uLmF1dGhQcm92aWRlcjtcbiAgICAgIHRlbXBTZXNzaW9uLmFjY291bnREZXJpdmF0aW9uSW5kZXggPSBhdXRoUmVzdWx0LmFjY291bnREZXJpdmF0aW9uSW5kZXg7XG4gICAgICB0ZW1wU2Vzc2lvbi5hdXRoVXNlcklkID0gYXV0aFJlc3VsdC5hdXRoVXNlcklkO1xuICAgICAgdGVtcFNlc3Npb24uc3RhdHVzID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgIHRlbXBTZXNzaW9uLmxhc3RVc2VkID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChhdXRoUmVzdWx0LmV4cGlyZXNJbk1zID4gMCkge1xuICAgICAgICBjb25zdCBub3cyID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGVtcFNlc3Npb24uYXV0aGVudGljYXRvckNyZWF0ZWRBdCA9IG5vdzI7XG4gICAgICAgIHRlbXBTZXNzaW9uLmF1dGhlbnRpY2F0b3JFeHBpcmVzQXQgPSBub3cyICsgYXV0aFJlc3VsdC5leHBpcmVzSW5NcztcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJVcGRhdGVkIGF1dGhlbnRpY2F0b3IgZXhwaXJhdGlvbiBmcm9tIGltbWVkaWF0ZSBhdXRoIHJlc3BvbnNlXCIsIHtcbiAgICAgICAgICBleHBpcmVzSW5NczogYXV0aFJlc3VsdC5leHBpcmVzSW5NcyxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHRlbXBTZXNzaW9uLmF1dGhlbnRpY2F0b3JFeHBpcmVzQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnN0b3JhZ2Uuc2F2ZVNlc3Npb24odGVtcFNlc3Npb24pO1xuICAgICAgYXdhaXQgdGhpcy5zdG9yYWdlLnNldFNob3VsZENsZWFyUHJldmlvdXNTZXNzaW9uKGZhbHNlKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiQ2xlYXJlZCBsb2dvdXQgZmxhZyBhZnRlciBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRlbXBTZXNzaW9uO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5pbmZvKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJSZWRpcmVjdCBhdXRoZW50aWNhdGlvbiBpbml0aWF0ZWQsIHdhaXRpbmcgZm9yIHJlZGlyZWN0IGNvbXBsZXRpb25cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgY29tcGxldGVBdXRoQ29ubmVjdGlvbihhdXRoUmVzdWx0KSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZXNzaW9uIGZvdW5kIGFmdGVyIHJlZGlyZWN0IC0gc2Vzc2lvbiBtYXkgaGF2ZSBleHBpcmVkXCIpO1xuICAgIH1cbiAgICBzZXNzaW9uLndhbGxldElkID0gYXV0aFJlc3VsdC53YWxsZXRJZDtcbiAgICBzZXNzaW9uLmF1dGhQcm92aWRlciA9IGF1dGhSZXN1bHQucHJvdmlkZXIgfHwgc2Vzc2lvbi5hdXRoUHJvdmlkZXI7XG4gICAgc2Vzc2lvbi5vcmdhbml6YXRpb25JZCA9IGF1dGhSZXN1bHQub3JnYW5pemF0aW9uSWQ7XG4gICAgc2Vzc2lvbi5hY2NvdW50RGVyaXZhdGlvbkluZGV4ID0gYXV0aFJlc3VsdC5hY2NvdW50RGVyaXZhdGlvbkluZGV4O1xuICAgIHNlc3Npb24uYXV0aFVzZXJJZCA9IGF1dGhSZXN1bHQuYXV0aFVzZXJJZDtcbiAgICBzZXNzaW9uLnN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgc2Vzc2lvbi5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gICAgaWYgKGF1dGhSZXN1bHQuZXhwaXJlc0luTXMgPiAwKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgc2Vzc2lvbi5hdXRoZW50aWNhdG9yQ3JlYXRlZEF0ID0gbm93O1xuICAgICAgc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0ID0gbm93ICsgYXV0aFJlc3VsdC5leHBpcmVzSW5NcztcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiVXBkYXRlZCBhdXRoZW50aWNhdG9yIGV4cGlyYXRpb24gZnJvbSBhdXRoIHJlc3BvbnNlXCIsIHtcbiAgICAgICAgZXhwaXJlc0luTXM6IGF1dGhSZXN1bHQuZXhwaXJlc0luTXMsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoc2Vzc2lvbi5hdXRoZW50aWNhdG9yRXhwaXJlc0F0KS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlLnNhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZS5zZXRTaG91bGRDbGVhclByZXZpb3VzU2Vzc2lvbihmYWxzZSk7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwiRU1CRURERURfUFJPVklERVJcIiwgXCJDbGVhcmVkIGxvZ291dCBmbGFnIGFmdGVyIHN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cIik7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQ2xpZW50RnJvbVNlc3Npb24oc2Vzc2lvbik7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVWYWxpZEF1dGhlbnRpY2F0b3IoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICBhZGRyZXNzZXM6IHRoaXMuYWRkcmVzc2VzLFxuICAgICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgICAgYXV0aFVzZXJJZDogc2Vzc2lvbi5hdXRoVXNlcklkLFxuICAgICAgYXV0aFByb3ZpZGVyOiBzZXNzaW9uLmF1dGhQcm92aWRlclxuICAgIH07XG4gIH1cbiAgLypcbiAgICogRW5zdXJlcyB0aGUgYXV0aGVudGljYXRvciBpcyB2YWxpZCBhbmQgcGVyZm9ybXMgcmVuZXdhbCBpZiBuZWVkZWQuXG4gICAqIFRoZSByZW5ld2FsIG9mIHRoZSBhdXRoZW50aWNhdG9yIGNhbiBvbmx5IGhhcHBlbiBtZWFud2hpbGUgdGhlIHByZXZpb3VzIGF1dGhlbnRpY2F0b3IgaXMgc3RpbGwgdmFsaWQuXG4gICAqL1xuICBhc3luYyBlbnN1cmVWYWxpZEF1dGhlbnRpY2F0b3IoKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuc3RvcmFnZS5nZXRTZXNzaW9uKCk7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgc2Vzc2lvbiBmb3VuZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXNlc3Npb24uYXV0aGVudGljYXRvckV4cGlyZXNBdCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiU2Vzc2lvbiBtaXNzaW5nIGF1dGhlbnRpY2F0b3IgdGltaW5nIC0gdHJlYXRpbmcgYXMgaW52YWxpZCBzZXNzaW9uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0KGZhbHNlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvbiAtIG1pc3NpbmcgYXV0aGVudGljYXRvciB0aW1pbmdcIik7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVVbnRpbEV4cGlyeSA9IHNlc3Npb24uYXV0aGVudGljYXRvckV4cGlyZXNBdCAtIG5vdztcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkNoZWNraW5nIGF1dGhlbnRpY2F0b3IgZXhwaXJhdGlvblwiLCB7XG4gICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHNlc3Npb24uYXV0aGVudGljYXRvckV4cGlyZXNBdCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHRpbWVVbnRpbEV4cGlyeVxuICAgIH0pO1xuICAgIGlmICh0aW1lVW50aWxFeHBpcnkgPD0gMCkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJFTUJFRERFRF9QUk9WSURFUlwiLCBcIkF1dGhlbnRpY2F0b3IgaGFzIGV4cGlyZWQsIGRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoZmFsc2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRvciBleHBpcmVkXCIpO1xuICAgIH1cbiAgfVxuICAvKlxuICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gaW5pdGlhbGl6ZSB0aGUgUGhhbnRvbUNsaWVudCBhbmQgZmV0Y2ggd2FsbGV0IGFkZHJlc3NlcyBmcm9tIGEgY29tcGxldGVkIHNlc3Npb24uXG4gICAqIFRoaXMgaXMgdGhlIGZpbmFsIHN0ZXAgdGhhdCBzZXRzIHVwIHRoZSBwcm92aWRlcidzIGNsaWVudCBzdGF0ZSBhbmQgcmV0cmlldmVzIGF2YWlsYWJsZSBhZGRyZXNzZXMuXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplQ2xpZW50RnJvbVNlc3Npb24oc2Vzc2lvbikge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcIkVNQkVEREVEX1BST1ZJREVSXCIsIFwiSW5pdGlhbGl6aW5nIFBoYW50b21DbGllbnQgZnJvbSBzZXNzaW9uXCIsIHtcbiAgICAgIG9yZ2FuaXphdGlvbklkOiBzZXNzaW9uLm9yZ2FuaXphdGlvbklkLFxuICAgICAgd2FsbGV0SWQ6IHNlc3Npb24ud2FsbGV0SWQsXG4gICAgICBhcHBJZDogc2Vzc2lvbi5hcHBJZFxuICAgIH0pO1xuICAgIGlmICghdGhpcy5zdGFtcGVyLmdldEtleUluZm8oKSkge1xuICAgICAgYXdhaXQgdGhpcy5zdGFtcGVyLmluaXQoKTtcbiAgICB9XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgUGhhbnRvbUNsaWVudChcbiAgICAgIHtcbiAgICAgICAgYXBpQmFzZVVybDogdGhpcy5jb25maWcuYXBpQmFzZVVybCxcbiAgICAgICAgb3JnYW5pemF0aW9uSWQ6IHNlc3Npb24ub3JnYW5pemF0aW9uSWQsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi50aGlzLnBsYXRmb3JtLmFuYWx5dGljc0hlYWRlcnMgfHwge30sXG4gICAgICAgICAgLi4uc2Vzc2lvbi5hdXRoVXNlcklkID8geyBcIngtYXV0aC11c2VyLWlkXCI6IHNlc3Npb24uYXV0aFVzZXJJZCB9IDoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRoaXMuc3RhbXBlclxuICAgICk7XG4gICAgdGhpcy53YWxsZXRJZCA9IHNlc3Npb24ud2FsbGV0SWQ7XG4gICAgdGhpcy5hZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldEFuZEZpbHRlcldhbGxldEFkZHJlc3NlcyhzZXNzaW9uLndhbGxldElkKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFVVEhFTlRJQ0FUT1JfRVhQSVJBVElPTl9USU1FX01TLFxuICBBVVRIRU5USUNBVE9SX1JFTkVXQUxfV0lORE9XX01TLFxuICBFTUJFRERFRF9QUk9WSURFUl9BVVRIX1RZUEVTLFxuICBFbWJlZGRlZEV0aGVyZXVtQ2hhaW4sXG4gIEVtYmVkZGVkUHJvdmlkZXIsXG4gIEVtYmVkZGVkU29sYW5hQ2hhaW4sXG4gIGdlbmVyYXRlU2Vzc2lvbklkLFxuICByZXRyeVdpdGhCYWNrb2ZmXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/embedded-provider-core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/indexed-db-stamper/dist/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@phantom/indexed-db-stamper/dist/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IndexedDbStamper: () => (/* binding */ IndexedDbStamper)\n/* harmony export */ });\n/* harmony import */ var _phantom_base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @phantom/base64url */ \"(ssr)/./node_modules/@phantom/base64url/dist/index.mjs\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/src/esm/index.js\");\n/* harmony import */ var _phantom_sdk_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/sdk-types */ \"(ssr)/./node_modules/@phantom/sdk-types/dist/index.mjs\");\n// src/index.ts\n\n\n\nvar IndexedDbStamper = class {\n  // Optional for PKI, required for OIDC\n  constructor(config = {}) {\n    this.db = null;\n    this.activeKeyPairRecord = null;\n    this.pendingKeyPairRecord = null;\n    this.algorithm = _phantom_sdk_types__WEBPACK_IMPORTED_MODULE_2__.Algorithm.ed25519;\n    // Use Ed25519 for maximum security and performance\n    // The type of stamper, can be changed at any time\n    this.type = \"PKI\";\n    if (typeof window === \"undefined\" || !window.indexedDB) {\n      throw new Error(\"IndexedDbStamper requires a browser environment with IndexedDB support\");\n    }\n    this.dbName = config.dbName || \"phantom-indexed-db-stamper\";\n    this.storeName = config.storeName || \"crypto-keys\";\n    this.keyName = config.keyName || \"signing-key\";\n    this.type = config.type || \"PKI\";\n    this.idToken = config.idToken;\n    this.salt = config.salt;\n  }\n  /**\n   * Initialize the stamper by opening IndexedDB and retrieving or generating keys\n   */\n  async init() {\n    await this.openDB();\n    this.activeKeyPairRecord = await this.loadActiveKeyPairRecord();\n    if (!this.activeKeyPairRecord) {\n      this.activeKeyPairRecord = await this.generateAndStoreNewKeyPair(\"active\");\n    }\n    this.pendingKeyPairRecord = await this.loadPendingKeyPairRecord();\n    return this.activeKeyPairRecord.keyInfo;\n  }\n  /**\n   * Get the public key information\n   */\n  getKeyInfo() {\n    return this.activeKeyPairRecord?.keyInfo || null;\n  }\n  /**\n   * Reset the key pair by generating a new one\n   */\n  async resetKeyPair() {\n    await this.clearStoredKeys();\n    this.activeKeyPairRecord = await this.generateAndStoreNewKeyPair(\"active\");\n    this.pendingKeyPairRecord = null;\n    return this.activeKeyPairRecord.keyInfo;\n  }\n  /**\n   * Create X-Phantom-Stamp header value using stored private key\n   * @param params - Parameters object with data and optional type/options\n   * @returns Complete X-Phantom-Stamp header value\n   */\n  async stamp(params) {\n    const { data } = params;\n    if (!this.activeKeyPairRecord) {\n      throw new Error(\"Stamper not initialized. Call init() first.\");\n    }\n    const dataBytes = new Uint8Array(data);\n    const signature = await crypto.subtle.sign(\n      {\n        name: this.algorithm,\n        hash: \"SHA-256\"\n      },\n      this.activeKeyPairRecord.keyPair.privateKey,\n      dataBytes\n    );\n    const signatureBase64url = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(new Uint8Array(signature));\n    const stampType = params.type || this.type;\n    const idToken = params.type === \"OIDC\" ? params.idToken : this.idToken;\n    const salt = params.type === \"OIDC\" ? params.salt : this.salt;\n    const stampData = stampType === \"PKI\" ? {\n      // Decode base58 public key to bytes, then encode as base64url (consistent with ApiKeyStamper)\n      publicKey: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(bs58__WEBPACK_IMPORTED_MODULE_1__[\"default\"].decode(this.activeKeyPairRecord.keyInfo.publicKey)),\n      signature: signatureBase64url,\n      kind: \"PKI\",\n      algorithm: this.algorithm\n    } : {\n      kind: \"OIDC\",\n      idToken,\n      publicKey: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(bs58__WEBPACK_IMPORTED_MODULE_1__[\"default\"].decode(this.activeKeyPairRecord.keyInfo.publicKey)),\n      salt,\n      algorithm: this.algorithm,\n      signature: signatureBase64url\n    };\n    const stampJson = JSON.stringify(stampData);\n    return (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(stampJson);\n  }\n  /**\n   * Clear all stored keys\n   */\n  async clear() {\n    await this.clearStoredKeys();\n    this.activeKeyPairRecord = null;\n    this.pendingKeyPairRecord = null;\n  }\n  async clearStoredKeys() {\n    if (!this.db) {\n      await this.openDB();\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const deleteActiveKeyPair = store.delete(`${this.keyName}-active`);\n      const deletePendingKeyPair = store.delete(`${this.keyName}-pending`);\n      let completed = 0;\n      const total = 2;\n      const checkComplete = () => {\n        completed++;\n        if (completed === total) {\n          resolve();\n        }\n      };\n      deleteActiveKeyPair.onsuccess = checkComplete;\n      deletePendingKeyPair.onsuccess = checkComplete;\n      deleteActiveKeyPair.onerror = () => reject(deleteActiveKeyPair.error);\n      deletePendingKeyPair.onerror = () => reject(deletePendingKeyPair.error);\n    });\n  }\n  async openDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n      };\n    });\n  }\n  /**\n   * Generate a new keypair for rotation without making it active\n   */\n  async rotateKeyPair() {\n    if (!this.db) {\n      await this.openDB();\n    }\n    this.pendingKeyPairRecord = await this.generateAndStoreNewKeyPair(\"pending\");\n    return this.pendingKeyPairRecord.keyInfo;\n  }\n  /**\n   * Switch to the pending keypair, making it active and cleaning up the old one\n   */\n  async commitRotation(authenticatorId) {\n    if (!this.pendingKeyPairRecord) {\n      throw new Error(\"No pending keypair to commit\");\n    }\n    if (this.activeKeyPairRecord) {\n      await this.removeKeyPairRecord(\"active\");\n    }\n    this.pendingKeyPairRecord.status = \"active\";\n    this.pendingKeyPairRecord.authenticatorId = authenticatorId;\n    this.pendingKeyPairRecord.keyInfo.authenticatorId = authenticatorId;\n    this.activeKeyPairRecord = this.pendingKeyPairRecord;\n    this.pendingKeyPairRecord = null;\n    await this.storeKeyPairRecord(this.activeKeyPairRecord, \"active\");\n    await this.removeKeyPairRecord(\"pending\");\n  }\n  /**\n   * Discard the pending keypair on rotation failure\n   */\n  async rollbackRotation() {\n    if (!this.pendingKeyPairRecord) {\n      return;\n    }\n    await this.removeKeyPairRecord(\"pending\");\n    this.pendingKeyPairRecord = null;\n  }\n  async generateAndStoreNewKeyPair(type) {\n    const keyPair = await crypto.subtle.generateKey(\n      {\n        name: \"Ed25519\"\n      },\n      false,\n      // non-extractable - private key can never be exported\n      [\"sign\", \"verify\"]\n    );\n    const rawPublicKeyBuffer = await crypto.subtle.exportKey(\"raw\", keyPair.publicKey);\n    const publicKeyBase58 = bs58__WEBPACK_IMPORTED_MODULE_1__[\"default\"].encode(new Uint8Array(rawPublicKeyBuffer));\n    const keyIdBuffer = await crypto.subtle.digest(\"SHA-256\", rawPublicKeyBuffer);\n    const keyId = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(new Uint8Array(keyIdBuffer)).substring(0, 16);\n    const now = Date.now();\n    const keyInfo = {\n      keyId,\n      publicKey: publicKeyBase58,\n      createdAt: now\n    };\n    const record = {\n      keyPair,\n      keyInfo,\n      createdAt: now,\n      expiresAt: 0,\n      // Not used anymore, kept for backward compatibility\n      status: type\n    };\n    await this.storeKeyPairRecord(record, type);\n    return record;\n  }\n  async storeKeyPairRecord(record, type) {\n    if (!this.db) {\n      throw new Error(\"Database not initialized\");\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put(record, `${this.keyName}-${type}`);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async loadActiveKeyPairRecord() {\n    if (!this.db) {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(`${this.keyName}-active`);\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async loadPendingKeyPairRecord() {\n    if (!this.db) {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], \"readonly\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(`${this.keyName}-pending`);\n      request.onsuccess = () => resolve(request.result || null);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  async removeKeyPairRecord(type) {\n    if (!this.db) {\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([this.storeName], \"readwrite\");\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(`${this.keyName}-${type}`);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vaW5kZXhlZC1kYi1zdGFtcGVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNxRDtBQUM3QjtBQUN1QjtBQUMvQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5REFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtRUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFlLENBQUMsNENBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQWUsQ0FBQyw0Q0FBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBSTtBQUNoQztBQUNBLGtCQUFrQixtRUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYSxHQUFHLEtBQUs7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWEsR0FBRyxLQUFLO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUdFIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9pbmRleGVkLWRiLXN0YW1wZXIvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBiYXNlNjR1cmxFbmNvZGUgfSBmcm9tIFwiQHBoYW50b20vYmFzZTY0dXJsXCI7XG5pbXBvcnQgYnM1OCBmcm9tIFwiYnM1OFwiO1xuaW1wb3J0IHsgQWxnb3JpdGhtIH0gZnJvbSBcIkBwaGFudG9tL3Nkay10eXBlc1wiO1xudmFyIEluZGV4ZWREYlN0YW1wZXIgPSBjbGFzcyB7XG4gIC8vIE9wdGlvbmFsIGZvciBQS0ksIHJlcXVpcmVkIGZvciBPSURDXG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5kYiA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVLZXlQYWlyUmVjb3JkID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdLZXlQYWlyUmVjb3JkID0gbnVsbDtcbiAgICB0aGlzLmFsZ29yaXRobSA9IEFsZ29yaXRobS5lZDI1NTE5O1xuICAgIC8vIFVzZSBFZDI1NTE5IGZvciBtYXhpbXVtIHNlY3VyaXR5IGFuZCBwZXJmb3JtYW5jZVxuICAgIC8vIFRoZSB0eXBlIG9mIHN0YW1wZXIsIGNhbiBiZSBjaGFuZ2VkIGF0IGFueSB0aW1lXG4gICAgdGhpcy50eXBlID0gXCJQS0lcIjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhd2luZG93LmluZGV4ZWREQikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXhlZERiU3RhbXBlciByZXF1aXJlcyBhIGJyb3dzZXIgZW52aXJvbm1lbnQgd2l0aCBJbmRleGVkREIgc3VwcG9ydFwiKTtcbiAgICB9XG4gICAgdGhpcy5kYk5hbWUgPSBjb25maWcuZGJOYW1lIHx8IFwicGhhbnRvbS1pbmRleGVkLWRiLXN0YW1wZXJcIjtcbiAgICB0aGlzLnN0b3JlTmFtZSA9IGNvbmZpZy5zdG9yZU5hbWUgfHwgXCJjcnlwdG8ta2V5c1wiO1xuICAgIHRoaXMua2V5TmFtZSA9IGNvbmZpZy5rZXlOYW1lIHx8IFwic2lnbmluZy1rZXlcIjtcbiAgICB0aGlzLnR5cGUgPSBjb25maWcudHlwZSB8fCBcIlBLSVwiO1xuICAgIHRoaXMuaWRUb2tlbiA9IGNvbmZpZy5pZFRva2VuO1xuICAgIHRoaXMuc2FsdCA9IGNvbmZpZy5zYWx0O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzdGFtcGVyIGJ5IG9wZW5pbmcgSW5kZXhlZERCIGFuZCByZXRyaWV2aW5nIG9yIGdlbmVyYXRpbmcga2V5c1xuICAgKi9cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBhd2FpdCB0aGlzLm9wZW5EQigpO1xuICAgIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZCA9IGF3YWl0IHRoaXMubG9hZEFjdGl2ZUtleVBhaXJSZWNvcmQoKTtcbiAgICBpZiAoIXRoaXMuYWN0aXZlS2V5UGFpclJlY29yZCkge1xuICAgICAgdGhpcy5hY3RpdmVLZXlQYWlyUmVjb3JkID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUFuZFN0b3JlTmV3S2V5UGFpcihcImFjdGl2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZCA9IGF3YWl0IHRoaXMubG9hZFBlbmRpbmdLZXlQYWlyUmVjb3JkKCk7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZC5rZXlJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW5mb3JtYXRpb25cbiAgICovXG4gIGdldEtleUluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZD8ua2V5SW5mbyB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUga2V5IHBhaXIgYnkgZ2VuZXJhdGluZyBhIG5ldyBvbmVcbiAgICovXG4gIGFzeW5jIHJlc2V0S2V5UGFpcigpIHtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RvcmVkS2V5cygpO1xuICAgIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVBbmRTdG9yZU5ld0tleVBhaXIoXCJhY3RpdmVcIik7XG4gICAgdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZC5rZXlJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgWC1QaGFudG9tLVN0YW1wIGhlYWRlciB2YWx1ZSB1c2luZyBzdG9yZWQgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgb2JqZWN0IHdpdGggZGF0YSBhbmQgb3B0aW9uYWwgdHlwZS9vcHRpb25zXG4gICAqIEByZXR1cm5zIENvbXBsZXRlIFgtUGhhbnRvbS1TdGFtcCBoZWFkZXIgdmFsdWVcbiAgICovXG4gIGFzeW5jIHN0YW1wKHBhcmFtcykge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGlmICghdGhpcy5hY3RpdmVLZXlQYWlyUmVjb3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFtcGVyIG5vdCBpbml0aWFsaXplZC4gQ2FsbCBpbml0KCkgZmlyc3QuXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHRoaXMuYWxnb3JpdGhtLFxuICAgICAgICBoYXNoOiBcIlNIQS0yNTZcIlxuICAgICAgfSxcbiAgICAgIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZC5rZXlQYWlyLnByaXZhdGVLZXksXG4gICAgICBkYXRhQnl0ZXNcbiAgICApO1xuICAgIGNvbnN0IHNpZ25hdHVyZUJhc2U2NHVybCA9IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShzaWduYXR1cmUpKTtcbiAgICBjb25zdCBzdGFtcFR5cGUgPSBwYXJhbXMudHlwZSB8fCB0aGlzLnR5cGU7XG4gICAgY29uc3QgaWRUb2tlbiA9IHBhcmFtcy50eXBlID09PSBcIk9JRENcIiA/IHBhcmFtcy5pZFRva2VuIDogdGhpcy5pZFRva2VuO1xuICAgIGNvbnN0IHNhbHQgPSBwYXJhbXMudHlwZSA9PT0gXCJPSURDXCIgPyBwYXJhbXMuc2FsdCA6IHRoaXMuc2FsdDtcbiAgICBjb25zdCBzdGFtcERhdGEgPSBzdGFtcFR5cGUgPT09IFwiUEtJXCIgPyB7XG4gICAgICAvLyBEZWNvZGUgYmFzZTU4IHB1YmxpYyBrZXkgdG8gYnl0ZXMsIHRoZW4gZW5jb2RlIGFzIGJhc2U2NHVybCAoY29uc2lzdGVudCB3aXRoIEFwaUtleVN0YW1wZXIpXG4gICAgICBwdWJsaWNLZXk6IGJhc2U2NHVybEVuY29kZShiczU4LmRlY29kZSh0aGlzLmFjdGl2ZUtleVBhaXJSZWNvcmQua2V5SW5mby5wdWJsaWNLZXkpKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlQmFzZTY0dXJsLFxuICAgICAga2luZDogXCJQS0lcIixcbiAgICAgIGFsZ29yaXRobTogdGhpcy5hbGdvcml0aG1cbiAgICB9IDoge1xuICAgICAga2luZDogXCJPSURDXCIsXG4gICAgICBpZFRva2VuLFxuICAgICAgcHVibGljS2V5OiBiYXNlNjR1cmxFbmNvZGUoYnM1OC5kZWNvZGUodGhpcy5hY3RpdmVLZXlQYWlyUmVjb3JkLmtleUluZm8ucHVibGljS2V5KSksXG4gICAgICBzYWx0LFxuICAgICAgYWxnb3JpdGhtOiB0aGlzLmFsZ29yaXRobSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlQmFzZTY0dXJsXG4gICAgfTtcbiAgICBjb25zdCBzdGFtcEpzb24gPSBKU09OLnN0cmluZ2lmeShzdGFtcERhdGEpO1xuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGUoc3RhbXBKc29uKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgYWxsIHN0b3JlZCBrZXlzXG4gICAqL1xuICBhc3luYyBjbGVhcigpIHtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RvcmVkS2V5cygpO1xuICAgIHRoaXMuYWN0aXZlS2V5UGFpclJlY29yZCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgY2xlYXJTdG9yZWRLZXlzKCkge1xuICAgIGlmICghdGhpcy5kYikge1xuICAgICAgYXdhaXQgdGhpcy5vcGVuREIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgZGVsZXRlQWN0aXZlS2V5UGFpciA9IHN0b3JlLmRlbGV0ZShgJHt0aGlzLmtleU5hbWV9LWFjdGl2ZWApO1xuICAgICAgY29uc3QgZGVsZXRlUGVuZGluZ0tleVBhaXIgPSBzdG9yZS5kZWxldGUoYCR7dGhpcy5rZXlOYW1lfS1wZW5kaW5nYCk7XG4gICAgICBsZXQgY29tcGxldGVkID0gMDtcbiAgICAgIGNvbnN0IHRvdGFsID0gMjtcbiAgICAgIGNvbnN0IGNoZWNrQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICBpZiAoY29tcGxldGVkID09PSB0b3RhbCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRlbGV0ZUFjdGl2ZUtleVBhaXIub25zdWNjZXNzID0gY2hlY2tDb21wbGV0ZTtcbiAgICAgIGRlbGV0ZVBlbmRpbmdLZXlQYWlyLm9uc3VjY2VzcyA9IGNoZWNrQ29tcGxldGU7XG4gICAgICBkZWxldGVBY3RpdmVLZXlQYWlyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QoZGVsZXRlQWN0aXZlS2V5UGFpci5lcnJvcik7XG4gICAgICBkZWxldGVQZW5kaW5nS2V5UGFpci5vbmVycm9yID0gKCkgPT4gcmVqZWN0KGRlbGV0ZVBlbmRpbmdLZXlQYWlyLmVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBvcGVuREIoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgMSk7XG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kYiA9IHJlcXVlc3QucmVzdWx0O1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKSB7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBrZXlwYWlyIGZvciByb3RhdGlvbiB3aXRob3V0IG1ha2luZyBpdCBhY3RpdmVcbiAgICovXG4gIGFzeW5jIHJvdGF0ZUtleVBhaXIoKSB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICBhd2FpdCB0aGlzLm9wZW5EQigpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdLZXlQYWlyUmVjb3JkID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUFuZFN0b3JlTmV3S2V5UGFpcihcInBlbmRpbmdcIik7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleVBhaXJSZWNvcmQua2V5SW5mbztcbiAgfVxuICAvKipcbiAgICogU3dpdGNoIHRvIHRoZSBwZW5kaW5nIGtleXBhaXIsIG1ha2luZyBpdCBhY3RpdmUgYW5kIGNsZWFuaW5nIHVwIHRoZSBvbGQgb25lXG4gICAqL1xuICBhc3luYyBjb21taXRSb3RhdGlvbihhdXRoZW50aWNhdG9ySWQpIHtcbiAgICBpZiAoIXRoaXMucGVuZGluZ0tleVBhaXJSZWNvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHBlbmRpbmcga2V5cGFpciB0byBjb21taXRcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZUtleVBhaXJSZWNvcmQpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlS2V5UGFpclJlY29yZChcImFjdGl2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZC5zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgIHRoaXMucGVuZGluZ0tleVBhaXJSZWNvcmQuYXV0aGVudGljYXRvcklkID0gYXV0aGVudGljYXRvcklkO1xuICAgIHRoaXMucGVuZGluZ0tleVBhaXJSZWNvcmQua2V5SW5mby5hdXRoZW50aWNhdG9ySWQgPSBhdXRoZW50aWNhdG9ySWQ7XG4gICAgdGhpcy5hY3RpdmVLZXlQYWlyUmVjb3JkID0gdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZDtcbiAgICB0aGlzLnBlbmRpbmdLZXlQYWlyUmVjb3JkID0gbnVsbDtcbiAgICBhd2FpdCB0aGlzLnN0b3JlS2V5UGFpclJlY29yZCh0aGlzLmFjdGl2ZUtleVBhaXJSZWNvcmQsIFwiYWN0aXZlXCIpO1xuICAgIGF3YWl0IHRoaXMucmVtb3ZlS2V5UGFpclJlY29yZChcInBlbmRpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmQgdGhlIHBlbmRpbmcga2V5cGFpciBvbiByb3RhdGlvbiBmYWlsdXJlXG4gICAqL1xuICBhc3luYyByb2xsYmFja1JvdGF0aW9uKCkge1xuICAgIGlmICghdGhpcy5wZW5kaW5nS2V5UGFpclJlY29yZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlbW92ZUtleVBhaXJSZWNvcmQoXCJwZW5kaW5nXCIpO1xuICAgIHRoaXMucGVuZGluZ0tleVBhaXJSZWNvcmQgPSBudWxsO1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlQW5kU3RvcmVOZXdLZXlQYWlyKHR5cGUpIHtcbiAgICBjb25zdCBrZXlQYWlyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJFZDI1NTE5XCJcbiAgICAgIH0sXG4gICAgICBmYWxzZSxcbiAgICAgIC8vIG5vbi1leHRyYWN0YWJsZSAtIHByaXZhdGUga2V5IGNhbiBuZXZlciBiZSBleHBvcnRlZFxuICAgICAgW1wic2lnblwiLCBcInZlcmlmeVwiXVxuICAgICk7XG4gICAgY29uc3QgcmF3UHVibGljS2V5QnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXCJyYXdcIiwga2V5UGFpci5wdWJsaWNLZXkpO1xuICAgIGNvbnN0IHB1YmxpY0tleUJhc2U1OCA9IGJzNTguZW5jb2RlKG5ldyBVaW50OEFycmF5KHJhd1B1YmxpY0tleUJ1ZmZlcikpO1xuICAgIGNvbnN0IGtleUlkQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIHJhd1B1YmxpY0tleUJ1ZmZlcik7XG4gICAgY29uc3Qga2V5SWQgPSBiYXNlNjR1cmxFbmNvZGUobmV3IFVpbnQ4QXJyYXkoa2V5SWRCdWZmZXIpKS5zdWJzdHJpbmcoMCwgMTYpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3Qga2V5SW5mbyA9IHtcbiAgICAgIGtleUlkLFxuICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXlCYXNlNTgsXG4gICAgICBjcmVhdGVkQXQ6IG5vd1xuICAgIH07XG4gICAgY29uc3QgcmVjb3JkID0ge1xuICAgICAga2V5UGFpcixcbiAgICAgIGtleUluZm8sXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIGV4cGlyZXNBdDogMCxcbiAgICAgIC8vIE5vdCB1c2VkIGFueW1vcmUsIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIHN0YXR1czogdHlwZVxuICAgIH07XG4gICAgYXdhaXQgdGhpcy5zdG9yZUtleVBhaXJSZWNvcmQocmVjb3JkLCB0eXBlKTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIGFzeW5jIHN0b3JlS2V5UGFpclJlY29yZChyZWNvcmQsIHR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLnB1dChyZWNvcmQsIGAke3RoaXMua2V5TmFtZX0tJHt0eXBlfWApO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9hZEFjdGl2ZUtleVBhaXJSZWNvcmQoKSB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWRvbmx5XCIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGAke3RoaXMua2V5TmFtZX0tYWN0aXZlYCk7XG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxdWVzdC5yZXN1bHQgfHwgbnVsbCk7XG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbG9hZFBlbmRpbmdLZXlQYWlyUmVjb3JkKCkge1xuICAgIGlmICghdGhpcy5kYikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgXCJyZWFkb25seVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChgJHt0aGlzLmtleU5hbWV9LXBlbmRpbmdgKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCB8fCBudWxsKTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZW1vdmVLZXlQYWlyUmVjb3JkKHR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmRlbGV0ZShgJHt0aGlzLmtleU5hbWV9LSR7dHlwZX1gKTtcbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZSgpO1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgSW5kZXhlZERiU3RhbXBlclxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/indexed-db-stamper/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/api/kmsrpcapi.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/api/kmsrpcapi.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KMSRPCApi: () => (/* binding */ KMSRPCApi),\n/* harmony export */   KMSRPCApiAxiosParamCreator: () => (/* binding */ KMSRPCApiAxiosParamCreator),\n/* harmony export */   KMSRPCApiFactory: () => (/* binding */ KMSRPCApiFactory),\n/* harmony export */   KMSRPCApiFp: () => (/* binding */ KMSRPCApiFp)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/common.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/base.js\");\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n// Some imports not used depending on template conditions\n// @ts-ignore\n\n// @ts-ignore\n\n/**\n * KMSRPCApi - axios parameter creator\n * @export\n */\nconst KMSRPCApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         *  ### Endpoint This endpoint implements an RPC interface for KMS operations. The request body should be a JSON object with the following fields: - `method`: The RPC method to call. Supported methods:   - `createOrganization`: Creates a new organization with users and authenticators   - `createAuthenticator`: Creates a new authenticator for a user in an organization   - `deleteAuthenticator`: Deletes an authenticator from a user in an organization   - `createWallet`: Creates a new wallet within an organization   - `getOrganizationWallets`: Retrieves all wallets owned by an organization with pagination support   - `grantOrganizationAccess`: Grants wallet access to another organization   - `getOrCreatePhantomOrganization`: Gets or creates a phantom organization with the given public key and algorithm   - `signRawPayload`: Signs raw bytes with a specified wallet and derivation path   - `signTransaction`: Signs a transaction with a specified wallet and derivation path   - `initMnemonicImport`: Initializes a mnemonic import for a user in an organization   - `completeMnemonicImport`: Completes the mnemonic import process for a user in an organization   - `exportWallet`: Exports a wallet\\'s data in an encrypted format - `params`: Parameters for the method, specific to each method type - `timestampMs`: Request timestamp in milliseconds (must be within 5 minutes of current time) ### Response The response body will be a JSON object with the following fields: - `result`: The result of the RPC call. The structure depends on the method:   - For `createOrganization`: Contains organization details   - For `createAuthenticator`: Contains authenticator details   - For `createWallet`: Contains wallet ID and name   - For `getOrganizationWallets`: Contains array of wallets with wallet_id and wallet_name, plus total_count, limit, and offset for pagination   - For `grantOrganizationAccess`: Contains confirmation of access grant with target organization ID and wallet ID   - For `getOrCreatePhantomOrganization`: Contains organization details for the phantom organization   - For `signRawPayload`: Contains signature and public key   - For `signTransaction`: Contains signed transaction and public key   - For `initMnemonicImport`: Contains import envelope and public key   - For `completeMnemonicImport`: Contains wallet ID and name   - For `exportWallet`: Contains encrypted wallet data\n         * @param {KmsRpcRequest} kmsRpcRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        postKmsRpc: (kmsRpcRequest_1, ...args_1) => __awaiter(this, [kmsRpcRequest_1, ...args_1], void 0, function* (kmsRpcRequest, options = {}) {\n            // verify required parameter 'kmsRpcRequest' is not null or undefined\n            (0,_common__WEBPACK_IMPORTED_MODULE_0__.assertParamExists)(\"postKmsRpc\", \"kmsRpcRequest\", kmsRpcRequest);\n            const localVarPath = `/kms/rpc`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, _common__WEBPACK_IMPORTED_MODULE_0__.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = Object.assign(Object.assign({ method: \"POST\" }, baseOptions), options);\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter[\"Content-Type\"] = \"application/json\";\n            (0,_common__WEBPACK_IMPORTED_MODULE_0__.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);\n            localVarRequestOptions.data = (0,_common__WEBPACK_IMPORTED_MODULE_0__.serializeDataIfNeeded)(kmsRpcRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0,_common__WEBPACK_IMPORTED_MODULE_0__.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        }),\n    };\n};\n/**\n * KMSRPCApi - functional programming interface\n * @export\n */\nconst KMSRPCApiFp = function (configuration) {\n    const localVarAxiosParamCreator = KMSRPCApiAxiosParamCreator(configuration);\n    return {\n        /**\n         *  ### Endpoint This endpoint implements an RPC interface for KMS operations. The request body should be a JSON object with the following fields: - `method`: The RPC method to call. Supported methods:   - `createOrganization`: Creates a new organization with users and authenticators   - `createAuthenticator`: Creates a new authenticator for a user in an organization   - `deleteAuthenticator`: Deletes an authenticator from a user in an organization   - `createWallet`: Creates a new wallet within an organization   - `getOrganizationWallets`: Retrieves all wallets owned by an organization with pagination support   - `grantOrganizationAccess`: Grants wallet access to another organization   - `getOrCreatePhantomOrganization`: Gets or creates a phantom organization with the given public key and algorithm   - `signRawPayload`: Signs raw bytes with a specified wallet and derivation path   - `signTransaction`: Signs a transaction with a specified wallet and derivation path   - `initMnemonicImport`: Initializes a mnemonic import for a user in an organization   - `completeMnemonicImport`: Completes the mnemonic import process for a user in an organization   - `exportWallet`: Exports a wallet\\'s data in an encrypted format - `params`: Parameters for the method, specific to each method type - `timestampMs`: Request timestamp in milliseconds (must be within 5 minutes of current time) ### Response The response body will be a JSON object with the following fields: - `result`: The result of the RPC call. The structure depends on the method:   - For `createOrganization`: Contains organization details   - For `createAuthenticator`: Contains authenticator details   - For `createWallet`: Contains wallet ID and name   - For `getOrganizationWallets`: Contains array of wallets with wallet_id and wallet_name, plus total_count, limit, and offset for pagination   - For `grantOrganizationAccess`: Contains confirmation of access grant with target organization ID and wallet ID   - For `getOrCreatePhantomOrganization`: Contains organization details for the phantom organization   - For `signRawPayload`: Contains signature and public key   - For `signTransaction`: Contains signed transaction and public key   - For `initMnemonicImport`: Contains import envelope and public key   - For `completeMnemonicImport`: Contains wallet ID and name   - For `exportWallet`: Contains encrypted wallet data\n         * @param {KmsRpcRequest} kmsRpcRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        postKmsRpc(kmsRpcRequest, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                var _a, _b, _c;\n                const localVarAxiosArgs = yield localVarAxiosParamCreator.postKmsRpc(kmsRpcRequest, options);\n                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;\n                const localVarOperationServerBasePath = (_c = (_b = _base__WEBPACK_IMPORTED_MODULE_1__.operationServerMap[\"KMSRPCApi.postKmsRpc\"]) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;\n                return (axios, basePath) => (0,_common__WEBPACK_IMPORTED_MODULE_0__.createRequestFunction)(localVarAxiosArgs, axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _base__WEBPACK_IMPORTED_MODULE_1__.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n            });\n        },\n    };\n};\n/**\n * KMSRPCApi - factory interface\n * @export\n */\nconst KMSRPCApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = KMSRPCApiFp(configuration);\n    return {\n        /**\n         *  ### Endpoint This endpoint implements an RPC interface for KMS operations. The request body should be a JSON object with the following fields: - `method`: The RPC method to call. Supported methods:   - `createOrganization`: Creates a new organization with users and authenticators   - `createAuthenticator`: Creates a new authenticator for a user in an organization   - `deleteAuthenticator`: Deletes an authenticator from a user in an organization   - `createWallet`: Creates a new wallet within an organization   - `getOrganizationWallets`: Retrieves all wallets owned by an organization with pagination support   - `grantOrganizationAccess`: Grants wallet access to another organization   - `getOrCreatePhantomOrganization`: Gets or creates a phantom organization with the given public key and algorithm   - `signRawPayload`: Signs raw bytes with a specified wallet and derivation path   - `signTransaction`: Signs a transaction with a specified wallet and derivation path   - `initMnemonicImport`: Initializes a mnemonic import for a user in an organization   - `completeMnemonicImport`: Completes the mnemonic import process for a user in an organization   - `exportWallet`: Exports a wallet\\'s data in an encrypted format - `params`: Parameters for the method, specific to each method type - `timestampMs`: Request timestamp in milliseconds (must be within 5 minutes of current time) ### Response The response body will be a JSON object with the following fields: - `result`: The result of the RPC call. The structure depends on the method:   - For `createOrganization`: Contains organization details   - For `createAuthenticator`: Contains authenticator details   - For `createWallet`: Contains wallet ID and name   - For `getOrganizationWallets`: Contains array of wallets with wallet_id and wallet_name, plus total_count, limit, and offset for pagination   - For `grantOrganizationAccess`: Contains confirmation of access grant with target organization ID and wallet ID   - For `getOrCreatePhantomOrganization`: Contains organization details for the phantom organization   - For `signRawPayload`: Contains signature and public key   - For `signTransaction`: Contains signed transaction and public key   - For `initMnemonicImport`: Contains import envelope and public key   - For `completeMnemonicImport`: Contains wallet ID and name   - For `exportWallet`: Contains encrypted wallet data\n         * @param {KmsRpcRequest} kmsRpcRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        postKmsRpc(kmsRpcRequest, options) {\n            return localVarFp.postKmsRpc(kmsRpcRequest, options).then(request => request(axios, basePath));\n        },\n    };\n};\n/**\n * KMSRPCApi - object-oriented interface\n * @export\n * @class KMSRPCApi\n * @extends {BaseAPI}\n */\nclass KMSRPCApi extends _base__WEBPACK_IMPORTED_MODULE_1__.BaseAPI {\n    /**\n     *  ### Endpoint This endpoint implements an RPC interface for KMS operations. The request body should be a JSON object with the following fields: - `method`: The RPC method to call. Supported methods:   - `createOrganization`: Creates a new organization with users and authenticators   - `createAuthenticator`: Creates a new authenticator for a user in an organization   - `deleteAuthenticator`: Deletes an authenticator from a user in an organization   - `createWallet`: Creates a new wallet within an organization   - `getOrganizationWallets`: Retrieves all wallets owned by an organization with pagination support   - `grantOrganizationAccess`: Grants wallet access to another organization   - `getOrCreatePhantomOrganization`: Gets or creates a phantom organization with the given public key and algorithm   - `signRawPayload`: Signs raw bytes with a specified wallet and derivation path   - `signTransaction`: Signs a transaction with a specified wallet and derivation path   - `initMnemonicImport`: Initializes a mnemonic import for a user in an organization   - `completeMnemonicImport`: Completes the mnemonic import process for a user in an organization   - `exportWallet`: Exports a wallet\\'s data in an encrypted format - `params`: Parameters for the method, specific to each method type - `timestampMs`: Request timestamp in milliseconds (must be within 5 minutes of current time) ### Response The response body will be a JSON object with the following fields: - `result`: The result of the RPC call. The structure depends on the method:   - For `createOrganization`: Contains organization details   - For `createAuthenticator`: Contains authenticator details   - For `createWallet`: Contains wallet ID and name   - For `getOrganizationWallets`: Contains array of wallets with wallet_id and wallet_name, plus total_count, limit, and offset for pagination   - For `grantOrganizationAccess`: Contains confirmation of access grant with target organization ID and wallet ID   - For `getOrCreatePhantomOrganization`: Contains organization details for the phantom organization   - For `signRawPayload`: Contains signature and public key   - For `signTransaction`: Contains signed transaction and public key   - For `initMnemonicImport`: Contains import envelope and public key   - For `completeMnemonicImport`: Contains wallet ID and name   - For `exportWallet`: Contains encrypted wallet data\n     * @param {KmsRpcRequest} kmsRpcRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof KMSRPCApi\n     */\n    postKmsRpc(kmsRpcRequest, options) {\n        return KMSRPCApiFp(this.configuration)\n            .postKmsRpc(kmsRpcRequest, options)\n            .then(request => request(this.axios, this.basePath));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9hcGkva21zcnBjYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNnQztBQUNoQztBQUNBO0FBQzRJO0FBQzVJO0FBQ2lFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnSkFBZ0o7QUFDaEo7QUFDQSxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0EseURBQXlELG1EQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFlO0FBQzNCO0FBQ0EseUZBQXlGO0FBQ3pGLDBDQUEwQyw4REFBcUI7QUFDL0Q7QUFDQSxxQkFBcUIscURBQVk7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxxREFBa0I7QUFDdEYsNENBQTRDLDhEQUFxQixvQkFBb0IsNkNBQVcsRUFBRSw0Q0FBUztBQUMzRyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPLHdCQUF3QiwwQ0FBTztBQUN0QztBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9hcGkva21zcnBjYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBrbXMtYXBpXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgZ2xvYmFsQXhpb3MgZnJvbSBcImF4aW9zXCI7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IERVTU1ZX0JBU0VfVVJMLCBhc3NlcnRQYXJhbUV4aXN0cywgc2V0U2VhcmNoUGFyYW1zLCBzZXJpYWxpemVEYXRhSWZOZWVkZWQsIHRvUGF0aFN0cmluZywgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uLCB9IGZyb20gXCIuLi9jb21tb25cIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJBU0VfUEFUSCwgQmFzZUFQSSwgb3BlcmF0aW9uU2VydmVyTWFwIH0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8qKlxuICogS01TUlBDQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IEtNU1JQQ0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogICMjIyBFbmRwb2ludCBUaGlzIGVuZHBvaW50IGltcGxlbWVudHMgYW4gUlBDIGludGVyZmFjZSBmb3IgS01TIG9wZXJhdGlvbnMuIFRoZSByZXF1ZXN0IGJvZHkgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczogLSBgbWV0aG9kYDogVGhlIFJQQyBtZXRob2QgdG8gY2FsbC4gU3VwcG9ydGVkIG1ldGhvZHM6ICAgLSBgY3JlYXRlT3JnYW5pemF0aW9uYDogQ3JlYXRlcyBhIG5ldyBvcmdhbml6YXRpb24gd2l0aCB1c2VycyBhbmQgYXV0aGVudGljYXRvcnMgICAtIGBjcmVhdGVBdXRoZW50aWNhdG9yYDogQ3JlYXRlcyBhIG5ldyBhdXRoZW50aWNhdG9yIGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZGVsZXRlQXV0aGVudGljYXRvcmA6IERlbGV0ZXMgYW4gYXV0aGVudGljYXRvciBmcm9tIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBjcmVhdGVXYWxsZXRgOiBDcmVhdGVzIGEgbmV3IHdhbGxldCB3aXRoaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JnYW5pemF0aW9uV2FsbGV0c2A6IFJldHJpZXZlcyBhbGwgd2FsbGV0cyBvd25lZCBieSBhbiBvcmdhbml6YXRpb24gd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnQgICAtIGBncmFudE9yZ2FuaXphdGlvbkFjY2Vzc2A6IEdyYW50cyB3YWxsZXQgYWNjZXNzIHRvIGFub3RoZXIgb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JDcmVhdGVQaGFudG9tT3JnYW5pemF0aW9uYDogR2V0cyBvciBjcmVhdGVzIGEgcGhhbnRvbSBvcmdhbml6YXRpb24gd2l0aCB0aGUgZ2l2ZW4gcHVibGljIGtleSBhbmQgYWxnb3JpdGhtICAgLSBgc2lnblJhd1BheWxvYWRgOiBTaWducyByYXcgYnl0ZXMgd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYHNpZ25UcmFuc2FjdGlvbmA6IFNpZ25zIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYGluaXRNbmVtb25pY0ltcG9ydGA6IEluaXRpYWxpemVzIGEgbW5lbW9uaWMgaW1wb3J0IGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgY29tcGxldGVNbmVtb25pY0ltcG9ydGA6IENvbXBsZXRlcyB0aGUgbW5lbW9uaWMgaW1wb3J0IHByb2Nlc3MgZm9yIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBleHBvcnRXYWxsZXRgOiBFeHBvcnRzIGEgd2FsbGV0XFwncyBkYXRhIGluIGFuIGVuY3J5cHRlZCBmb3JtYXQgLSBgcGFyYW1zYDogUGFyYW1ldGVycyBmb3IgdGhlIG1ldGhvZCwgc3BlY2lmaWMgdG8gZWFjaCBtZXRob2QgdHlwZSAtIGB0aW1lc3RhbXBNc2A6IFJlcXVlc3QgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyAobXVzdCBiZSB3aXRoaW4gNSBtaW51dGVzIG9mIGN1cnJlbnQgdGltZSkgIyMjIFJlc3BvbnNlIFRoZSByZXNwb25zZSBib2R5IHdpbGwgYmUgYSBKU09OIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOiAtIGByZXN1bHRgOiBUaGUgcmVzdWx0IG9mIHRoZSBSUEMgY2FsbC4gVGhlIHN0cnVjdHVyZSBkZXBlbmRzIG9uIHRoZSBtZXRob2Q6ICAgLSBGb3IgYGNyZWF0ZU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzICAgLSBGb3IgYGNyZWF0ZUF1dGhlbnRpY2F0b3JgOiBDb250YWlucyBhdXRoZW50aWNhdG9yIGRldGFpbHMgICAtIEZvciBgY3JlYXRlV2FsbGV0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGdldE9yZ2FuaXphdGlvbldhbGxldHNgOiBDb250YWlucyBhcnJheSBvZiB3YWxsZXRzIHdpdGggd2FsbGV0X2lkIGFuZCB3YWxsZXRfbmFtZSwgcGx1cyB0b3RhbF9jb3VudCwgbGltaXQsIGFuZCBvZmZzZXQgZm9yIHBhZ2luYXRpb24gICAtIEZvciBgZ3JhbnRPcmdhbml6YXRpb25BY2Nlc3NgOiBDb250YWlucyBjb25maXJtYXRpb24gb2YgYWNjZXNzIGdyYW50IHdpdGggdGFyZ2V0IG9yZ2FuaXphdGlvbiBJRCBhbmQgd2FsbGV0IElEICAgLSBGb3IgYGdldE9yQ3JlYXRlUGhhbnRvbU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzIGZvciB0aGUgcGhhbnRvbSBvcmdhbml6YXRpb24gICAtIEZvciBgc2lnblJhd1BheWxvYWRgOiBDb250YWlucyBzaWduYXR1cmUgYW5kIHB1YmxpYyBrZXkgICAtIEZvciBgc2lnblRyYW5zYWN0aW9uYDogQ29udGFpbnMgc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwdWJsaWMga2V5ICAgLSBGb3IgYGluaXRNbmVtb25pY0ltcG9ydGA6IENvbnRhaW5zIGltcG9ydCBlbnZlbG9wZSBhbmQgcHVibGljIGtleSAgIC0gRm9yIGBjb21wbGV0ZU1uZW1vbmljSW1wb3J0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGV4cG9ydFdhbGxldGA6IENvbnRhaW5zIGVuY3J5cHRlZCB3YWxsZXQgZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0ttc1JwY1JlcXVlc3R9IGttc1JwY1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHBvc3RLbXNScGM6IChrbXNScGNSZXF1ZXN0XzEsIC4uLmFyZ3NfMSkgPT4gX19hd2FpdGVyKHRoaXMsIFtrbXNScGNSZXF1ZXN0XzEsIC4uLmFyZ3NfMV0sIHZvaWQgMCwgZnVuY3Rpb24qIChrbXNScGNSZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ttc1JwY1JlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgYXNzZXJ0UGFyYW1FeGlzdHMoXCJwb3N0S21zUnBjXCIsIFwia21zUnBjUmVxdWVzdFwiLCBrbXNScGNSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAva21zL3JwY2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogXCJQT1NUXCIgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlcltcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciksIGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkKGttc1JwY1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgIH07XG59O1xuLyoqXG4gKiBLTVNSUENBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgS01TUlBDQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSBLTVNSUENBcGlBeGlvc1BhcmFtQ3JlYXRvcihjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogICMjIyBFbmRwb2ludCBUaGlzIGVuZHBvaW50IGltcGxlbWVudHMgYW4gUlBDIGludGVyZmFjZSBmb3IgS01TIG9wZXJhdGlvbnMuIFRoZSByZXF1ZXN0IGJvZHkgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczogLSBgbWV0aG9kYDogVGhlIFJQQyBtZXRob2QgdG8gY2FsbC4gU3VwcG9ydGVkIG1ldGhvZHM6ICAgLSBgY3JlYXRlT3JnYW5pemF0aW9uYDogQ3JlYXRlcyBhIG5ldyBvcmdhbml6YXRpb24gd2l0aCB1c2VycyBhbmQgYXV0aGVudGljYXRvcnMgICAtIGBjcmVhdGVBdXRoZW50aWNhdG9yYDogQ3JlYXRlcyBhIG5ldyBhdXRoZW50aWNhdG9yIGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZGVsZXRlQXV0aGVudGljYXRvcmA6IERlbGV0ZXMgYW4gYXV0aGVudGljYXRvciBmcm9tIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBjcmVhdGVXYWxsZXRgOiBDcmVhdGVzIGEgbmV3IHdhbGxldCB3aXRoaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JnYW5pemF0aW9uV2FsbGV0c2A6IFJldHJpZXZlcyBhbGwgd2FsbGV0cyBvd25lZCBieSBhbiBvcmdhbml6YXRpb24gd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnQgICAtIGBncmFudE9yZ2FuaXphdGlvbkFjY2Vzc2A6IEdyYW50cyB3YWxsZXQgYWNjZXNzIHRvIGFub3RoZXIgb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JDcmVhdGVQaGFudG9tT3JnYW5pemF0aW9uYDogR2V0cyBvciBjcmVhdGVzIGEgcGhhbnRvbSBvcmdhbml6YXRpb24gd2l0aCB0aGUgZ2l2ZW4gcHVibGljIGtleSBhbmQgYWxnb3JpdGhtICAgLSBgc2lnblJhd1BheWxvYWRgOiBTaWducyByYXcgYnl0ZXMgd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYHNpZ25UcmFuc2FjdGlvbmA6IFNpZ25zIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYGluaXRNbmVtb25pY0ltcG9ydGA6IEluaXRpYWxpemVzIGEgbW5lbW9uaWMgaW1wb3J0IGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgY29tcGxldGVNbmVtb25pY0ltcG9ydGA6IENvbXBsZXRlcyB0aGUgbW5lbW9uaWMgaW1wb3J0IHByb2Nlc3MgZm9yIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBleHBvcnRXYWxsZXRgOiBFeHBvcnRzIGEgd2FsbGV0XFwncyBkYXRhIGluIGFuIGVuY3J5cHRlZCBmb3JtYXQgLSBgcGFyYW1zYDogUGFyYW1ldGVycyBmb3IgdGhlIG1ldGhvZCwgc3BlY2lmaWMgdG8gZWFjaCBtZXRob2QgdHlwZSAtIGB0aW1lc3RhbXBNc2A6IFJlcXVlc3QgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyAobXVzdCBiZSB3aXRoaW4gNSBtaW51dGVzIG9mIGN1cnJlbnQgdGltZSkgIyMjIFJlc3BvbnNlIFRoZSByZXNwb25zZSBib2R5IHdpbGwgYmUgYSBKU09OIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOiAtIGByZXN1bHRgOiBUaGUgcmVzdWx0IG9mIHRoZSBSUEMgY2FsbC4gVGhlIHN0cnVjdHVyZSBkZXBlbmRzIG9uIHRoZSBtZXRob2Q6ICAgLSBGb3IgYGNyZWF0ZU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzICAgLSBGb3IgYGNyZWF0ZUF1dGhlbnRpY2F0b3JgOiBDb250YWlucyBhdXRoZW50aWNhdG9yIGRldGFpbHMgICAtIEZvciBgY3JlYXRlV2FsbGV0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGdldE9yZ2FuaXphdGlvbldhbGxldHNgOiBDb250YWlucyBhcnJheSBvZiB3YWxsZXRzIHdpdGggd2FsbGV0X2lkIGFuZCB3YWxsZXRfbmFtZSwgcGx1cyB0b3RhbF9jb3VudCwgbGltaXQsIGFuZCBvZmZzZXQgZm9yIHBhZ2luYXRpb24gICAtIEZvciBgZ3JhbnRPcmdhbml6YXRpb25BY2Nlc3NgOiBDb250YWlucyBjb25maXJtYXRpb24gb2YgYWNjZXNzIGdyYW50IHdpdGggdGFyZ2V0IG9yZ2FuaXphdGlvbiBJRCBhbmQgd2FsbGV0IElEICAgLSBGb3IgYGdldE9yQ3JlYXRlUGhhbnRvbU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzIGZvciB0aGUgcGhhbnRvbSBvcmdhbml6YXRpb24gICAtIEZvciBgc2lnblJhd1BheWxvYWRgOiBDb250YWlucyBzaWduYXR1cmUgYW5kIHB1YmxpYyBrZXkgICAtIEZvciBgc2lnblRyYW5zYWN0aW9uYDogQ29udGFpbnMgc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwdWJsaWMga2V5ICAgLSBGb3IgYGluaXRNbmVtb25pY0ltcG9ydGA6IENvbnRhaW5zIGltcG9ydCBlbnZlbG9wZSBhbmQgcHVibGljIGtleSAgIC0gRm9yIGBjb21wbGV0ZU1uZW1vbmljSW1wb3J0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGV4cG9ydFdhbGxldGA6IENvbnRhaW5zIGVuY3J5cHRlZCB3YWxsZXQgZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0ttc1JwY1JlcXVlc3R9IGttc1JwY1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHBvc3RLbXNScGMoa21zUnBjUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IHlpZWxkIGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucG9zdEttc1JwYyhrbXNScGNSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gKF9hID0gY29uZmlndXJhdGlvbiA9PT0gbnVsbCB8fCBjb25maWd1cmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWd1cmF0aW9uLnNlcnZlckluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSAoX2MgPSAoX2IgPSBvcGVyYXRpb25TZXJ2ZXJNYXBbXCJLTVNSUENBcGkucG9zdEttc1JwY1wiXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsO1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24obG9jYWxWYXJBeGlvc0FyZ3MsIGdsb2JhbEF4aW9zLCBCQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBLTVNSUENBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgS01TUlBDQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gS01TUlBDQXBpRnAoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICAjIyMgRW5kcG9pbnQgVGhpcyBlbmRwb2ludCBpbXBsZW1lbnRzIGFuIFJQQyBpbnRlcmZhY2UgZm9yIEtNUyBvcGVyYXRpb25zLiBUaGUgcmVxdWVzdCBib2R5IHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6IC0gYG1ldGhvZGA6IFRoZSBSUEMgbWV0aG9kIHRvIGNhbGwuIFN1cHBvcnRlZCBtZXRob2RzOiAgIC0gYGNyZWF0ZU9yZ2FuaXphdGlvbmA6IENyZWF0ZXMgYSBuZXcgb3JnYW5pemF0aW9uIHdpdGggdXNlcnMgYW5kIGF1dGhlbnRpY2F0b3JzICAgLSBgY3JlYXRlQXV0aGVudGljYXRvcmA6IENyZWF0ZXMgYSBuZXcgYXV0aGVudGljYXRvciBmb3IgYSB1c2VyIGluIGFuIG9yZ2FuaXphdGlvbiAgIC0gYGRlbGV0ZUF1dGhlbnRpY2F0b3JgOiBEZWxldGVzIGFuIGF1dGhlbnRpY2F0b3IgZnJvbSBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgY3JlYXRlV2FsbGV0YDogQ3JlYXRlcyBhIG5ldyB3YWxsZXQgd2l0aGluIGFuIG9yZ2FuaXphdGlvbiAgIC0gYGdldE9yZ2FuaXphdGlvbldhbGxldHNgOiBSZXRyaWV2ZXMgYWxsIHdhbGxldHMgb3duZWQgYnkgYW4gb3JnYW5pemF0aW9uIHdpdGggcGFnaW5hdGlvbiBzdXBwb3J0ICAgLSBgZ3JhbnRPcmdhbml6YXRpb25BY2Nlc3NgOiBHcmFudHMgd2FsbGV0IGFjY2VzcyB0byBhbm90aGVyIG9yZ2FuaXphdGlvbiAgIC0gYGdldE9yQ3JlYXRlUGhhbnRvbU9yZ2FuaXphdGlvbmA6IEdldHMgb3IgY3JlYXRlcyBhIHBoYW50b20gb3JnYW5pemF0aW9uIHdpdGggdGhlIGdpdmVuIHB1YmxpYyBrZXkgYW5kIGFsZ29yaXRobSAgIC0gYHNpZ25SYXdQYXlsb2FkYDogU2lnbnMgcmF3IGJ5dGVzIHdpdGggYSBzcGVjaWZpZWQgd2FsbGV0IGFuZCBkZXJpdmF0aW9uIHBhdGggICAtIGBzaWduVHJhbnNhY3Rpb25gOiBTaWducyBhIHRyYW5zYWN0aW9uIHdpdGggYSBzcGVjaWZpZWQgd2FsbGV0IGFuZCBkZXJpdmF0aW9uIHBhdGggICAtIGBpbml0TW5lbW9uaWNJbXBvcnRgOiBJbml0aWFsaXplcyBhIG1uZW1vbmljIGltcG9ydCBmb3IgYSB1c2VyIGluIGFuIG9yZ2FuaXphdGlvbiAgIC0gYGNvbXBsZXRlTW5lbW9uaWNJbXBvcnRgOiBDb21wbGV0ZXMgdGhlIG1uZW1vbmljIGltcG9ydCBwcm9jZXNzIGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZXhwb3J0V2FsbGV0YDogRXhwb3J0cyBhIHdhbGxldFxcJ3MgZGF0YSBpbiBhbiBlbmNyeXB0ZWQgZm9ybWF0IC0gYHBhcmFtc2A6IFBhcmFtZXRlcnMgZm9yIHRoZSBtZXRob2QsIHNwZWNpZmljIHRvIGVhY2ggbWV0aG9kIHR5cGUgLSBgdGltZXN0YW1wTXNgOiBSZXF1ZXN0IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgKG11c3QgYmUgd2l0aGluIDUgbWludXRlcyBvZiBjdXJyZW50IHRpbWUpICMjIyBSZXNwb25zZSBUaGUgcmVzcG9uc2UgYm9keSB3aWxsIGJlIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczogLSBgcmVzdWx0YDogVGhlIHJlc3VsdCBvZiB0aGUgUlBDIGNhbGwuIFRoZSBzdHJ1Y3R1cmUgZGVwZW5kcyBvbiB0aGUgbWV0aG9kOiAgIC0gRm9yIGBjcmVhdGVPcmdhbml6YXRpb25gOiBDb250YWlucyBvcmdhbml6YXRpb24gZGV0YWlscyAgIC0gRm9yIGBjcmVhdGVBdXRoZW50aWNhdG9yYDogQ29udGFpbnMgYXV0aGVudGljYXRvciBkZXRhaWxzICAgLSBGb3IgYGNyZWF0ZVdhbGxldGA6IENvbnRhaW5zIHdhbGxldCBJRCBhbmQgbmFtZSAgIC0gRm9yIGBnZXRPcmdhbml6YXRpb25XYWxsZXRzYDogQ29udGFpbnMgYXJyYXkgb2Ygd2FsbGV0cyB3aXRoIHdhbGxldF9pZCBhbmQgd2FsbGV0X25hbWUsIHBsdXMgdG90YWxfY291bnQsIGxpbWl0LCBhbmQgb2Zmc2V0IGZvciBwYWdpbmF0aW9uICAgLSBGb3IgYGdyYW50T3JnYW5pemF0aW9uQWNjZXNzYDogQ29udGFpbnMgY29uZmlybWF0aW9uIG9mIGFjY2VzcyBncmFudCB3aXRoIHRhcmdldCBvcmdhbml6YXRpb24gSUQgYW5kIHdhbGxldCBJRCAgIC0gRm9yIGBnZXRPckNyZWF0ZVBoYW50b21Pcmdhbml6YXRpb25gOiBDb250YWlucyBvcmdhbml6YXRpb24gZGV0YWlscyBmb3IgdGhlIHBoYW50b20gb3JnYW5pemF0aW9uICAgLSBGb3IgYHNpZ25SYXdQYXlsb2FkYDogQ29udGFpbnMgc2lnbmF0dXJlIGFuZCBwdWJsaWMga2V5ICAgLSBGb3IgYHNpZ25UcmFuc2FjdGlvbmA6IENvbnRhaW5zIHNpZ25lZCB0cmFuc2FjdGlvbiBhbmQgcHVibGljIGtleSAgIC0gRm9yIGBpbml0TW5lbW9uaWNJbXBvcnRgOiBDb250YWlucyBpbXBvcnQgZW52ZWxvcGUgYW5kIHB1YmxpYyBrZXkgICAtIEZvciBgY29tcGxldGVNbmVtb25pY0ltcG9ydGA6IENvbnRhaW5zIHdhbGxldCBJRCBhbmQgbmFtZSAgIC0gRm9yIGBleHBvcnRXYWxsZXRgOiBDb250YWlucyBlbmNyeXB0ZWQgd2FsbGV0IGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtLbXNScGNSZXF1ZXN0fSBrbXNScGNSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBwb3N0S21zUnBjKGttc1JwY1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnBvc3RLbXNScGMoa21zUnBjUmVxdWVzdCwgb3B0aW9ucykudGhlbihyZXF1ZXN0ID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4vKipcbiAqIEtNU1JQQ0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBLTVNSUENBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5leHBvcnQgY2xhc3MgS01TUlBDQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogICMjIyBFbmRwb2ludCBUaGlzIGVuZHBvaW50IGltcGxlbWVudHMgYW4gUlBDIGludGVyZmFjZSBmb3IgS01TIG9wZXJhdGlvbnMuIFRoZSByZXF1ZXN0IGJvZHkgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczogLSBgbWV0aG9kYDogVGhlIFJQQyBtZXRob2QgdG8gY2FsbC4gU3VwcG9ydGVkIG1ldGhvZHM6ICAgLSBgY3JlYXRlT3JnYW5pemF0aW9uYDogQ3JlYXRlcyBhIG5ldyBvcmdhbml6YXRpb24gd2l0aCB1c2VycyBhbmQgYXV0aGVudGljYXRvcnMgICAtIGBjcmVhdGVBdXRoZW50aWNhdG9yYDogQ3JlYXRlcyBhIG5ldyBhdXRoZW50aWNhdG9yIGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZGVsZXRlQXV0aGVudGljYXRvcmA6IERlbGV0ZXMgYW4gYXV0aGVudGljYXRvciBmcm9tIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBjcmVhdGVXYWxsZXRgOiBDcmVhdGVzIGEgbmV3IHdhbGxldCB3aXRoaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JnYW5pemF0aW9uV2FsbGV0c2A6IFJldHJpZXZlcyBhbGwgd2FsbGV0cyBvd25lZCBieSBhbiBvcmdhbml6YXRpb24gd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnQgICAtIGBncmFudE9yZ2FuaXphdGlvbkFjY2Vzc2A6IEdyYW50cyB3YWxsZXQgYWNjZXNzIHRvIGFub3RoZXIgb3JnYW5pemF0aW9uICAgLSBgZ2V0T3JDcmVhdGVQaGFudG9tT3JnYW5pemF0aW9uYDogR2V0cyBvciBjcmVhdGVzIGEgcGhhbnRvbSBvcmdhbml6YXRpb24gd2l0aCB0aGUgZ2l2ZW4gcHVibGljIGtleSBhbmQgYWxnb3JpdGhtICAgLSBgc2lnblJhd1BheWxvYWRgOiBTaWducyByYXcgYnl0ZXMgd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYHNpZ25UcmFuc2FjdGlvbmA6IFNpZ25zIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHNwZWNpZmllZCB3YWxsZXQgYW5kIGRlcml2YXRpb24gcGF0aCAgIC0gYGluaXRNbmVtb25pY0ltcG9ydGA6IEluaXRpYWxpemVzIGEgbW5lbW9uaWMgaW1wb3J0IGZvciBhIHVzZXIgaW4gYW4gb3JnYW5pemF0aW9uICAgLSBgY29tcGxldGVNbmVtb25pY0ltcG9ydGA6IENvbXBsZXRlcyB0aGUgbW5lbW9uaWMgaW1wb3J0IHByb2Nlc3MgZm9yIGEgdXNlciBpbiBhbiBvcmdhbml6YXRpb24gICAtIGBleHBvcnRXYWxsZXRgOiBFeHBvcnRzIGEgd2FsbGV0XFwncyBkYXRhIGluIGFuIGVuY3J5cHRlZCBmb3JtYXQgLSBgcGFyYW1zYDogUGFyYW1ldGVycyBmb3IgdGhlIG1ldGhvZCwgc3BlY2lmaWMgdG8gZWFjaCBtZXRob2QgdHlwZSAtIGB0aW1lc3RhbXBNc2A6IFJlcXVlc3QgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyAobXVzdCBiZSB3aXRoaW4gNSBtaW51dGVzIG9mIGN1cnJlbnQgdGltZSkgIyMjIFJlc3BvbnNlIFRoZSByZXNwb25zZSBib2R5IHdpbGwgYmUgYSBKU09OIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOiAtIGByZXN1bHRgOiBUaGUgcmVzdWx0IG9mIHRoZSBSUEMgY2FsbC4gVGhlIHN0cnVjdHVyZSBkZXBlbmRzIG9uIHRoZSBtZXRob2Q6ICAgLSBGb3IgYGNyZWF0ZU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzICAgLSBGb3IgYGNyZWF0ZUF1dGhlbnRpY2F0b3JgOiBDb250YWlucyBhdXRoZW50aWNhdG9yIGRldGFpbHMgICAtIEZvciBgY3JlYXRlV2FsbGV0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGdldE9yZ2FuaXphdGlvbldhbGxldHNgOiBDb250YWlucyBhcnJheSBvZiB3YWxsZXRzIHdpdGggd2FsbGV0X2lkIGFuZCB3YWxsZXRfbmFtZSwgcGx1cyB0b3RhbF9jb3VudCwgbGltaXQsIGFuZCBvZmZzZXQgZm9yIHBhZ2luYXRpb24gICAtIEZvciBgZ3JhbnRPcmdhbml6YXRpb25BY2Nlc3NgOiBDb250YWlucyBjb25maXJtYXRpb24gb2YgYWNjZXNzIGdyYW50IHdpdGggdGFyZ2V0IG9yZ2FuaXphdGlvbiBJRCBhbmQgd2FsbGV0IElEICAgLSBGb3IgYGdldE9yQ3JlYXRlUGhhbnRvbU9yZ2FuaXphdGlvbmA6IENvbnRhaW5zIG9yZ2FuaXphdGlvbiBkZXRhaWxzIGZvciB0aGUgcGhhbnRvbSBvcmdhbml6YXRpb24gICAtIEZvciBgc2lnblJhd1BheWxvYWRgOiBDb250YWlucyBzaWduYXR1cmUgYW5kIHB1YmxpYyBrZXkgICAtIEZvciBgc2lnblRyYW5zYWN0aW9uYDogQ29udGFpbnMgc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwdWJsaWMga2V5ICAgLSBGb3IgYGluaXRNbmVtb25pY0ltcG9ydGA6IENvbnRhaW5zIGltcG9ydCBlbnZlbG9wZSBhbmQgcHVibGljIGtleSAgIC0gRm9yIGBjb21wbGV0ZU1uZW1vbmljSW1wb3J0YDogQ29udGFpbnMgd2FsbGV0IElEIGFuZCBuYW1lICAgLSBGb3IgYGV4cG9ydFdhbGxldGA6IENvbnRhaW5zIGVuY3J5cHRlZCB3YWxsZXQgZGF0YVxuICAgICAqIEBwYXJhbSB7S21zUnBjUmVxdWVzdH0ga21zUnBjUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgS01TUlBDQXBpXG4gICAgICovXG4gICAgcG9zdEttc1JwYyhrbXNScGNSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBLTVNSUENBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICAucG9zdEttc1JwYyhrbXNScGNSZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4ocmVxdWVzdCA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/api/kmsrpcapi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/base.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/base.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_PATH: () => (/* binding */ BASE_PATH),\n/* harmony export */   BaseAPI: () => (/* binding */ BaseAPI),\n/* harmony export */   COLLECTION_FORMATS: () => (/* binding */ COLLECTION_FORMATS),\n/* harmony export */   RequiredError: () => (/* binding */ RequiredError),\n/* harmony export */   operationServerMap: () => (/* binding */ operationServerMap)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nconst BASE_PATH = \"http://localhost:8000\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nconst COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = BASE_PATH, axios = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n        var _a;\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;\n        }\n    }\n}\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\n/**\n *\n * @export\n */\nconst operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dDO0FBQ3pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2REFBNkQsNkNBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL29wZW5hcGktd2FsbGV0LXNlcnZpY2UvZGlzdC9lc20vYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICoga21zLWFwaVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbmltcG9ydCBnbG9iYWxBeGlvcyBmcm9tIFwiYXhpb3NcIjtcbmV4cG9ydCBjb25zdCBCQVNFX1BBVEggPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMFwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBDT0xMRUNUSU9OX0ZPUk1BVFMgPSB7XG4gICAgY3N2OiBcIixcIixcbiAgICBzc3Y6IFwiIFwiLFxuICAgIHRzdjogXCJcXHRcIixcbiAgICBwaXBlczogXCJ8XCIsXG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEJhc2VBUElcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoID0gQkFTRV9QQVRILCBheGlvcyA9IGdsb2JhbEF4aW9zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLmF4aW9zID0gYXhpb3M7XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGF0aCA9IChfYSA9IGNvbmZpZ3VyYXRpb24uYmFzZVBhdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGJhc2VQYXRoO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFJlcXVpcmVkRXJyb3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqL1xuZXhwb3J0IGNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IG9wZXJhdGlvblNlcnZlck1hcCA9IHt9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/common.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DUMMY_BASE_URL: () => (/* binding */ DUMMY_BASE_URL),\n/* harmony export */   assertParamExists: () => (/* binding */ assertParamExists),\n/* harmony export */   createRequestFunction: () => (/* binding */ createRequestFunction),\n/* harmony export */   serializeDataIfNeeded: () => (/* binding */ serializeDataIfNeeded),\n/* harmony export */   setApiKeyToObject: () => (/* binding */ setApiKeyToObject),\n/* harmony export */   setBasicAuthToObject: () => (/* binding */ setBasicAuthToObject),\n/* harmony export */   setBearerAuthToObject: () => (/* binding */ setBearerAuthToObject),\n/* harmony export */   setOAuthToObject: () => (/* binding */ setOAuthToObject),\n/* harmony export */   setSearchParams: () => (/* binding */ setSearchParams),\n/* harmony export */   toPathString: () => (/* binding */ toPathString)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/base.js\");\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n/**\n *\n * @export\n */\nconst DUMMY_BASE_URL = \"https://example.com\";\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new _base__WEBPACK_IMPORTED_MODULE_0__.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\n/**\n *\n * @export\n */\nconst setApiKeyToObject = function (object, keyParamName, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.apiKey) {\n            const localVarApiKeyValue = typeof configuration.apiKey === \"function\"\n                ? yield configuration.apiKey(keyParamName)\n                : yield configuration.apiKey;\n            object[keyParamName] = localVarApiKeyValue;\n        }\n    });\n};\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = function (object, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const accessToken = typeof configuration.accessToken === \"function\"\n                ? yield configuration.accessToken()\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + accessToken;\n        }\n    });\n};\n/**\n *\n * @export\n */\nconst setOAuthToObject = function (object, name, scopes, configuration) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (configuration && configuration.accessToken) {\n            const localVarAccessTokenValue = typeof configuration.accessToken === \"function\"\n                ? yield configuration.accessToken(name, scopes)\n                : yield configuration.accessToken;\n            object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n        }\n    });\n};\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== \"\" ? \".\" : \"\"}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== \"string\";\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers[\"Content-Type\"])\n        : nonString;\n    return needsSerialization ? JSON.stringify(value !== undefined ? value : {}) : value || \"\";\n};\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        var _a;\n        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: (axios.defaults.baseURL ? \"\" : ((_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath)) + axiosArgs.url });\n        return axios.request(axiosRequestArgs);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9jb21tb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUN1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixnREFBYSxrQ0FBa0MsV0FBVyxxQ0FBcUMsYUFBYTtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILElBQUksRUFBRSxzQkFBc0IsRUFBRSxXQUFXO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsK0RBQStELHdCQUF3Qiw4TEFBOEw7QUFDclI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlL2Rpc3QvZXNtL2NvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICoga21zLWFwaVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgUmVxdWlyZWRFcnJvciB9IGZyb20gXCIuL2Jhc2VcIjtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IERVTU1ZX0JBU0VfVVJMID0gXCJodHRwczovL2V4YW1wbGUuY29tXCI7XG4vKipcbiAqXG4gKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgYXNzZXJ0UGFyYW1FeGlzdHMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwYXJhbU5hbWUsIHBhcmFtVmFsdWUpIHtcbiAgICBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCB8fCBwYXJhbVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IocGFyYW1OYW1lLCBgUmVxdWlyZWQgcGFyYW1ldGVyICR7cGFyYW1OYW1lfSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nICR7ZnVuY3Rpb25OYW1lfS5gKTtcbiAgICB9XG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3Qgc2V0QXBpS2V5VG9PYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXlQYXJhbU5hbWUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBcGlLZXlWYWx1ZSA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFwaUtleSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyB5aWVsZCBjb25maWd1cmF0aW9uLmFwaUtleShrZXlQYXJhbU5hbWUpXG4gICAgICAgICAgICAgICAgOiB5aWVsZCBjb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgICAgIG9iamVjdFtrZXlQYXJhbU5hbWVdID0gbG9jYWxWYXJBcGlLZXlWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEJhc2ljQXV0aFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgY29uZmlndXJhdGlvbikge1xuICAgIGlmIChjb25maWd1cmF0aW9uICYmIChjb25maWd1cmF0aW9uLnVzZXJuYW1lIHx8IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQpKSB7XG4gICAgICAgIG9iamVjdFtcImF1dGhcIl0gPSB7IHVzZXJuYW1lOiBjb25maWd1cmF0aW9uLnVzZXJuYW1lLCBwYXNzd29yZDogY29uZmlndXJhdGlvbi5wYXNzd29yZCB9O1xuICAgIH1cbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyB5aWVsZCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKClcbiAgICAgICAgICAgICAgICA6IHlpZWxkIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBhY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNldE9BdXRoVG9PYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBzY29wZXMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckFjY2Vzc1Rva2VuVmFsdWUgPSB0eXBlb2YgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyB5aWVsZCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKG5hbWUsIHNjb3BlcylcbiAgICAgICAgICAgICAgICA6IHlpZWxkIGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBsb2NhbFZhckFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5mdW5jdGlvbiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIHBhcmFtZXRlciwga2V5ID0gXCJcIikge1xuICAgIGlmIChwYXJhbWV0ZXIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlci5mb3JFYWNoKGl0ZW0gPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBpdGVtLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcikuZm9yRWFjaChjdXJyZW50S2V5ID0+IHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyW2N1cnJlbnRLZXldLCBgJHtrZXl9JHtrZXkgIT09IFwiXCIgPyBcIi5cIiA6IFwiXCJ9JHtjdXJyZW50S2V5fWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHVybFNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICh1cmwsIC4uLm9iamVjdHMpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHNlYXJjaFBhcmFtcywgb2JqZWN0cyk7XG4gICAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBub25TdHJpbmcgPSB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCI7XG4gICAgY29uc3QgbmVlZHNTZXJpYWxpemF0aW9uID0gbm9uU3RyaW5nICYmIGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5pc0pzb25NaW1lXG4gICAgICAgID8gY29uZmlndXJhdGlvbi5pc0pzb25NaW1lKHJlcXVlc3RPcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pXG4gICAgICAgIDogbm9uU3RyaW5nO1xuICAgIHJldHVybiBuZWVkc1NlcmlhbGl6YXRpb24gPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSkgOiB2YWx1ZSB8fCBcIlwiO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHRvUGF0aFN0cmluZyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGZ1bmN0aW9uIChheGlvc0FyZ3MsIGdsb2JhbEF4aW9zLCBCQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gKGF4aW9zID0gZ2xvYmFsQXhpb3MsIGJhc2VQYXRoID0gQkFTRV9QQVRIKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYXhpb3NSZXF1ZXN0QXJncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXhpb3NBcmdzLm9wdGlvbnMpLCB7IHVybDogKGF4aW9zLmRlZmF1bHRzLmJhc2VVUkwgPyBcIlwiIDogKChfYSA9IGNvbmZpZ3VyYXRpb24gPT09IG51bGwgfHwgY29uZmlndXJhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlndXJhdGlvbi5iYXNlUGF0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYmFzZVBhdGgpKSArIGF4aW9zQXJncy51cmwgfSk7XG4gICAgICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGF4aW9zUmVxdWVzdEFyZ3MpO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/configuration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/configuration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Configuration: () => (/* binding */ Configuration)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nclass Configuration {\n    constructor(param = {}) {\n        var _a;\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = Object.assign(Object.assign({}, param.baseOptions), { headers: Object.assign({}, (_a = param.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) });\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp(\"^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$\", \"i\");\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === \"application/json-patch+json\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3Qix5QkFBeUIsNkVBQTZFO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxzQkFBc0I7QUFDN0Y7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlL2Rpc3QvZXNtL2NvbmZpZ3VyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5leHBvcnQgY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gcGFyYW0uYXBpS2V5O1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gcGFyYW0udXNlcm5hbWU7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXJhbS5wYXNzd29yZDtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHBhcmFtLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcGFyYW0uYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuc2VydmVySW5kZXggPSBwYXJhbS5zZXJ2ZXJJbmRleDtcbiAgICAgICAgdGhpcy5iYXNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW0uYmFzZU9wdGlvbnMpLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHBhcmFtLmJhc2VPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgfSk7XG4gICAgICAgIHRoaXMuZm9ybURhdGFDdG9yID0gcGFyYW0uZm9ybURhdGFDdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBhIEpTT04gTUlNRS5cbiAgICAgKiBKU09OIE1JTUUgZXhhbXBsZXM6XG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURjhcbiAgICAgKiAgIEFQUExJQ0FUSU9OL0pTT05cbiAgICAgKiAgIGFwcGxpY2F0aW9uL3ZuZC5jb21wYW55K2pzb25cbiAgICAgKiBAcGFyYW0gbWltZSAtIE1JTUUgKE11bHRpcHVycG9zZSBJbnRlcm5ldCBNYWlsIEV4dGVuc2lvbnMpXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBNSU1FIGlzIEpTT04sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0pzb25NaW1lKG1pbWUpIHtcbiAgICAgICAgY29uc3QganNvbk1pbWUgPSBuZXcgUmVnRXhwKFwiXihhcHBsaWNhdGlvblxcL2pzb258W147LyBcXHRdK1xcL1teOy8gXFx0XStbK11qc29uKVsgXFx0XSooOy4qKT8kXCIsIFwiaVwiKTtcbiAgICAgICAgcmV0dXJuIG1pbWUgIT09IG51bGwgJiYgKGpzb25NaW1lLnRlc3QobWltZSkgfHwgbWltZS50b0xvd2VyQ2FzZSgpID09PSBcImFwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvblwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/configuration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/add-user-to-organization.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/add-user-to-organization.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddUserToOrganizationMethodEnum: () => (/* binding */ AddUserToOrganizationMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar AddUserToOrganizationMethodEnum;\n(function (AddUserToOrganizationMethodEnum) {\n    AddUserToOrganizationMethodEnum[\"addUserToOrganization\"] = \"addUserToOrganization\";\n})(AddUserToOrganizationMethodEnum || (AddUserToOrganizationMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9hZGQtdXNlci10by1vcmdhbml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUMsMEVBQTBFIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlL2Rpc3QvZXNtL21vZGVsL2FkZC11c2VyLXRvLW9yZ2FuaXphdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICoga21zLWFwaVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtO1xuKGZ1bmN0aW9uIChBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtKSB7XG4gICAgQWRkVXNlclRvT3JnYW5pemF0aW9uTWV0aG9kRW51bVtcImFkZFVzZXJUb09yZ2FuaXphdGlvblwiXSA9IFwiYWRkVXNlclRvT3JnYW5pemF0aW9uXCI7XG59KShBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtIHx8IChBZGRVc2VyVG9Pcmdhbml6YXRpb25NZXRob2RFbnVtID0ge30pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/add-user-to-organization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/algorithm.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/algorithm.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Algorithm: () => (/* binding */ Algorithm)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n * @export\n * @enum {string}\n */\nvar Algorithm;\n(function (Algorithm) {\n    Algorithm[\"ed25519\"] = \"Ed25519\";\n    Algorithm[\"secp256r1\"] = \"Secp256r1\";\n    Algorithm[\"secp256k1\"] = \"Secp256k1\";\n    Algorithm[\"secp256k1Keccak256\"] = \"Secp256k1Keccak256\";\n    Algorithm[\"secp256k1Schnorr\"] = \"Secp256k1Schnorr\";\n})(Algorithm || (Algorithm = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9hbGdvcml0aG0uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9hbGdvcml0aG0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIEFsZ29yaXRobTtcbihmdW5jdGlvbiAoQWxnb3JpdGhtKSB7XG4gICAgQWxnb3JpdGhtW1wiZWQyNTUxOVwiXSA9IFwiRWQyNTUxOVwiO1xuICAgIEFsZ29yaXRobVtcInNlY3AyNTZyMVwiXSA9IFwiU2VjcDI1NnIxXCI7XG4gICAgQWxnb3JpdGhtW1wic2VjcDI1NmsxXCJdID0gXCJTZWNwMjU2azFcIjtcbiAgICBBbGdvcml0aG1bXCJzZWNwMjU2azFLZWNjYWsyNTZcIl0gPSBcIlNlY3AyNTZrMUtlY2NhazI1NlwiO1xuICAgIEFsZ29yaXRobVtcInNlY3AyNTZrMVNjaG5vcnJcIl0gPSBcIlNlY3AyNTZrMVNjaG5vcnJcIjtcbn0pKEFsZ29yaXRobSB8fCAoQWxnb3JpdGhtID0ge30pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/algorithm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-authenticator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-authenticator.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateAuthenticatorMethodEnum: () => (/* binding */ CreateAuthenticatorMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar CreateAuthenticatorMethodEnum;\n(function (CreateAuthenticatorMethodEnum) {\n    CreateAuthenticatorMethodEnum[\"createAuthenticator\"] = \"createAuthenticator\";\n})(CreateAuthenticatorMethodEnum || (CreateAuthenticatorMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9jcmVhdGUtYXV0aGVudGljYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL29wZW5hcGktd2FsbGV0LXNlcnZpY2UvZGlzdC9lc20vbW9kZWwvY3JlYXRlLWF1dGhlbnRpY2F0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ3JlYXRlQXV0aGVudGljYXRvck1ldGhvZEVudW07XG4oZnVuY3Rpb24gKENyZWF0ZUF1dGhlbnRpY2F0b3JNZXRob2RFbnVtKSB7XG4gICAgQ3JlYXRlQXV0aGVudGljYXRvck1ldGhvZEVudW1bXCJjcmVhdGVBdXRoZW50aWNhdG9yXCJdID0gXCJjcmVhdGVBdXRoZW50aWNhdG9yXCI7XG59KShDcmVhdGVBdXRoZW50aWNhdG9yTWV0aG9kRW51bSB8fCAoQ3JlYXRlQXV0aGVudGljYXRvck1ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-authenticator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-organization.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-organization.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateOrganizationMethodEnum: () => (/* binding */ CreateOrganizationMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar CreateOrganizationMethodEnum;\n(function (CreateOrganizationMethodEnum) {\n    CreateOrganizationMethodEnum[\"createOrganization\"] = \"createOrganization\";\n})(CreateOrganizationMethodEnum || (CreateOrganizationMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9jcmVhdGUtb3JnYW5pemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9jcmVhdGUtb3JnYW5pemF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBrbXMtYXBpXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIENyZWF0ZU9yZ2FuaXphdGlvbk1ldGhvZEVudW07XG4oZnVuY3Rpb24gKENyZWF0ZU9yZ2FuaXphdGlvbk1ldGhvZEVudW0pIHtcbiAgICBDcmVhdGVPcmdhbml6YXRpb25NZXRob2RFbnVtW1wiY3JlYXRlT3JnYW5pemF0aW9uXCJdID0gXCJjcmVhdGVPcmdhbml6YXRpb25cIjtcbn0pKENyZWF0ZU9yZ2FuaXphdGlvbk1ldGhvZEVudW0gfHwgKENyZWF0ZU9yZ2FuaXphdGlvbk1ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-organization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-wallet.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-wallet.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateWalletMethodEnum: () => (/* binding */ CreateWalletMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar CreateWalletMethodEnum;\n(function (CreateWalletMethodEnum) {\n    CreateWalletMethodEnum[\"createWallet\"] = \"createWallet\";\n})(CreateWalletMethodEnum || (CreateWalletMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9jcmVhdGUtd2FsbGV0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9jcmVhdGUtd2FsbGV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBrbXMtYXBpXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIENyZWF0ZVdhbGxldE1ldGhvZEVudW07XG4oZnVuY3Rpb24gKENyZWF0ZVdhbGxldE1ldGhvZEVudW0pIHtcbiAgICBDcmVhdGVXYWxsZXRNZXRob2RFbnVtW1wiY3JlYXRlV2FsbGV0XCJdID0gXCJjcmVhdGVXYWxsZXRcIjtcbn0pKENyZWF0ZVdhbGxldE1ldGhvZEVudW0gfHwgKENyZWF0ZVdhbGxldE1ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/create-wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/delete-authenticator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/delete-authenticator.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeleteAuthenticatorMethodEnum: () => (/* binding */ DeleteAuthenticatorMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar DeleteAuthenticatorMethodEnum;\n(function (DeleteAuthenticatorMethodEnum) {\n    DeleteAuthenticatorMethodEnum[\"deleteAuthenticator\"] = \"deleteAuthenticator\";\n})(DeleteAuthenticatorMethodEnum || (DeleteAuthenticatorMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9kZWxldGUtYXV0aGVudGljYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyxzRUFBc0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL29wZW5hcGktd2FsbGV0LXNlcnZpY2UvZGlzdC9lc20vbW9kZWwvZGVsZXRlLWF1dGhlbnRpY2F0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgRGVsZXRlQXV0aGVudGljYXRvck1ldGhvZEVudW07XG4oZnVuY3Rpb24gKERlbGV0ZUF1dGhlbnRpY2F0b3JNZXRob2RFbnVtKSB7XG4gICAgRGVsZXRlQXV0aGVudGljYXRvck1ldGhvZEVudW1bXCJkZWxldGVBdXRoZW50aWNhdG9yXCJdID0gXCJkZWxldGVBdXRoZW50aWNhdG9yXCI7XG59KShEZWxldGVBdXRoZW50aWNhdG9yTWV0aG9kRW51bSB8fCAoRGVsZXRlQXV0aGVudGljYXRvck1ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/delete-authenticator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/derivation-info.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/derivation-info.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DerivationInfoAddressFormatEnum: () => (/* binding */ DerivationInfoAddressFormatEnum),\n/* harmony export */   DerivationInfoCurveEnum: () => (/* binding */ DerivationInfoCurveEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar DerivationInfoCurveEnum;\n(function (DerivationInfoCurveEnum) {\n    DerivationInfoCurveEnum[\"ed25519\"] = \"Ed25519\";\n    DerivationInfoCurveEnum[\"secp256k1\"] = \"Secp256k1\";\n})(DerivationInfoCurveEnum || (DerivationInfoCurveEnum = {}));\n/**\n * @export\n * @enum {string}\n */\nvar DerivationInfoAddressFormatEnum;\n(function (DerivationInfoAddressFormatEnum) {\n    DerivationInfoAddressFormatEnum[\"ethereum\"] = \"Ethereum\";\n    DerivationInfoAddressFormatEnum[\"solana\"] = \"Solana\";\n    DerivationInfoAddressFormatEnum[\"bitcoinSegwit\"] = \"BitcoinSegwit\";\n    DerivationInfoAddressFormatEnum[\"sui\"] = \"Sui\";\n})(DerivationInfoAddressFormatEnum || (DerivationInfoAddressFormatEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9kZXJpdmF0aW9uLWluZm8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEO0FBQzNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9kZXJpdmF0aW9uLWluZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgRGVyaXZhdGlvbkluZm9DdXJ2ZUVudW07XG4oZnVuY3Rpb24gKERlcml2YXRpb25JbmZvQ3VydmVFbnVtKSB7XG4gICAgRGVyaXZhdGlvbkluZm9DdXJ2ZUVudW1bXCJlZDI1NTE5XCJdID0gXCJFZDI1NTE5XCI7XG4gICAgRGVyaXZhdGlvbkluZm9DdXJ2ZUVudW1bXCJzZWNwMjU2azFcIl0gPSBcIlNlY3AyNTZrMVwiO1xufSkoRGVyaXZhdGlvbkluZm9DdXJ2ZUVudW0gfHwgKERlcml2YXRpb25JbmZvQ3VydmVFbnVtID0ge30pKTtcbi8qKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtO1xuKGZ1bmN0aW9uIChEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtKSB7XG4gICAgRGVyaXZhdGlvbkluZm9BZGRyZXNzRm9ybWF0RW51bVtcImV0aGVyZXVtXCJdID0gXCJFdGhlcmV1bVwiO1xuICAgIERlcml2YXRpb25JbmZvQWRkcmVzc0Zvcm1hdEVudW1bXCJzb2xhbmFcIl0gPSBcIlNvbGFuYVwiO1xuICAgIERlcml2YXRpb25JbmZvQWRkcmVzc0Zvcm1hdEVudW1bXCJiaXRjb2luU2Vnd2l0XCJdID0gXCJCaXRjb2luU2Vnd2l0XCI7XG4gICAgRGVyaXZhdGlvbkluZm9BZGRyZXNzRm9ybWF0RW51bVtcInN1aVwiXSA9IFwiU3VpXCI7XG59KShEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtIHx8IChEZXJpdmF0aW9uSW5mb0FkZHJlc3NGb3JtYXRFbnVtID0ge30pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/derivation-info.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/get-accounts.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/get-accounts.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GetAccountsMethodEnum: () => (/* binding */ GetAccountsMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar GetAccountsMethodEnum;\n(function (GetAccountsMethodEnum) {\n    GetAccountsMethodEnum[\"getAccounts\"] = \"getAccounts\";\n})(GetAccountsMethodEnum || (GetAccountsMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9nZXQtYWNjb3VudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUMsc0RBQXNEIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlL2Rpc3QvZXNtL21vZGVsL2dldC1hY2NvdW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICoga21zLWFwaVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBHZXRBY2NvdW50c01ldGhvZEVudW07XG4oZnVuY3Rpb24gKEdldEFjY291bnRzTWV0aG9kRW51bSkge1xuICAgIEdldEFjY291bnRzTWV0aG9kRW51bVtcImdldEFjY291bnRzXCJdID0gXCJnZXRBY2NvdW50c1wiO1xufSkoR2V0QWNjb3VudHNNZXRob2RFbnVtIHx8IChHZXRBY2NvdW50c01ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/get-accounts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/grant-organization-access.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/grant-organization-access.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GrantOrganizationAccessMethodEnum: () => (/* binding */ GrantOrganizationAccessMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar GrantOrganizationAccessMethodEnum;\n(function (GrantOrganizationAccessMethodEnum) {\n    GrantOrganizationAccessMethodEnum[\"grantOrganizationAccess\"] = \"grantOrganizationAccess\";\n})(GrantOrganizationAccessMethodEnum || (GrantOrganizationAccessMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9ncmFudC1vcmdhbml6YXRpb24tYWNjZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDLDhFQUE4RSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9ncmFudC1vcmdhbml6YXRpb24tYWNjZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBrbXMtYXBpXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIEdyYW50T3JnYW5pemF0aW9uQWNjZXNzTWV0aG9kRW51bTtcbihmdW5jdGlvbiAoR3JhbnRPcmdhbml6YXRpb25BY2Nlc3NNZXRob2RFbnVtKSB7XG4gICAgR3JhbnRPcmdhbml6YXRpb25BY2Nlc3NNZXRob2RFbnVtW1wiZ3JhbnRPcmdhbml6YXRpb25BY2Nlc3NcIl0gPSBcImdyYW50T3JnYW5pemF0aW9uQWNjZXNzXCI7XG59KShHcmFudE9yZ2FuaXphdGlvbkFjY2Vzc01ldGhvZEVudW0gfHwgKEdyYW50T3JnYW5pemF0aW9uQWNjZXNzTWV0aG9kRW51bSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/grant-organization-access.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-transaction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-transaction.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignTransactionMethodEnum: () => (/* binding */ SignTransactionMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar SignTransactionMethodEnum;\n(function (SignTransactionMethodEnum) {\n    SignTransactionMethodEnum[\"signTransaction\"] = \"signTransaction\";\n})(SignTransactionMethodEnum || (SignTransactionMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9zaWduLXRyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDLDhEQUE4RCIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9zaWduLXRyYW5zYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBrbXMtYXBpXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMS4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIFNpZ25UcmFuc2FjdGlvbk1ldGhvZEVudW07XG4oZnVuY3Rpb24gKFNpZ25UcmFuc2FjdGlvbk1ldGhvZEVudW0pIHtcbiAgICBTaWduVHJhbnNhY3Rpb25NZXRob2RFbnVtW1wic2lnblRyYW5zYWN0aW9uXCJdID0gXCJzaWduVHJhbnNhY3Rpb25cIjtcbn0pKFNpZ25UcmFuc2FjdGlvbk1ldGhvZEVudW0gfHwgKFNpZ25UcmFuc2FjdGlvbk1ldGhvZEVudW0gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-utf8-message.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-utf8-message.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignUTF8MessageMethodEnum: () => (/* binding */ SignUTF8MessageMethodEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar SignUTF8MessageMethodEnum;\n(function (SignUTF8MessageMethodEnum) {\n    SignUTF8MessageMethodEnum[\"signUtf8Message\"] = \"signUtf8Message\";\n})(SignUTF8MessageMethodEnum || (SignUTF8MessageMethodEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC9zaWduLXV0ZjgtbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL29wZW5hcGktd2FsbGV0LXNlcnZpY2UvZGlzdC9lc20vbW9kZWwvc2lnbi11dGY4LW1lc3NhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIGttcy1hcGlcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4xLjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgU2lnblVURjhNZXNzYWdlTWV0aG9kRW51bTtcbihmdW5jdGlvbiAoU2lnblVURjhNZXNzYWdlTWV0aG9kRW51bSkge1xuICAgIFNpZ25VVEY4TWVzc2FnZU1ldGhvZEVudW1bXCJzaWduVXRmOE1lc3NhZ2VcIl0gPSBcInNpZ25VdGY4TWVzc2FnZVwiO1xufSkoU2lnblVURjhNZXNzYWdlTWV0aG9kRW51bSB8fCAoU2lnblVURjhNZXNzYWdlTWV0aG9kRW51bSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/sign-utf8-message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/user-policy-one-of.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@phantom/openapi-wallet-service/dist/esm/model/user-policy-one-of.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserPolicyOneOfTypeEnum: () => (/* binding */ UserPolicyOneOfTypeEnum)\n/* harmony export */ });\n/* tslint:disable */\n/* eslint-disable */\n/**\n * kms-api\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 0.1.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n * @export\n * @enum {string}\n */\nvar UserPolicyOneOfTypeEnum;\n(function (UserPolicyOneOfTypeEnum) {\n    UserPolicyOneOfTypeEnum[\"root\"] = \"ROOT\";\n})(UserPolicyOneOfTypeEnum || (UserPolicyOneOfTypeEnum = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vb3BlbmFwaS13YWxsZXQtc2VydmljZS9kaXN0L2VzbS9tb2RlbC91c2VyLXBvbGljeS1vbmUtb2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUMsMERBQTBEIiwic291cmNlcyI6WyIvVXNlcnMvbHVrZS9Eb2N1bWVudHMvZGZsb3cvY29va2Jvb2svc3JjL3Byb29mL25vZGVfbW9kdWxlcy9AcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlL2Rpc3QvZXNtL21vZGVsL3VzZXItcG9saWN5LW9uZS1vZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICoga21zLWFwaVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjEuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBVc2VyUG9saWN5T25lT2ZUeXBlRW51bTtcbihmdW5jdGlvbiAoVXNlclBvbGljeU9uZU9mVHlwZUVudW0pIHtcbiAgICBVc2VyUG9saWN5T25lT2ZUeXBlRW51bVtcInJvb3RcIl0gPSBcIlJPT1RcIjtcbn0pKFVzZXJQb2xpY3lPbmVPZlR5cGVFbnVtIHx8IChVc2VyUG9saWN5T25lT2ZUeXBlRW51bSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/user-policy-one-of.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/parsers/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@phantom/parsers/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deserializeSolanaTransaction: () => (/* binding */ deserializeSolanaTransaction),\n/* harmony export */   parseSignMessageResponse: () => (/* binding */ parseSignMessageResponse),\n/* harmony export */   parseSolanaKitTransactionToSolanaWeb3js: () => (/* binding */ parseSolanaKitTransactionToSolanaWeb3js),\n/* harmony export */   parseSolanaSignedTransaction: () => (/* binding */ parseSolanaSignedTransaction),\n/* harmony export */   parseToKmsTransaction: () => (/* binding */ parseToKmsTransaction),\n/* harmony export */   parseTransactionResponse: () => (/* binding */ parseTransactionResponse)\n/* harmony export */ });\n/* harmony import */ var _phantom_base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @phantom/base64url */ \"(ssr)/./node_modules/@phantom/base64url/dist/index.mjs\");\n/* harmony import */ var _solana_transactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/transactions */ \"(ssr)/./node_modules/@solana/transactions/dist/index.node.mjs\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n/* harmony import */ var _phantom_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @phantom/utils */ \"(ssr)/./node_modules/@phantom/utils/dist/index.mjs\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/src/esm/index.js\");\n// src/index.ts\n\n\n\n\n\n// src/response-parsers.ts\n\n\n\n\n\n\nfunction parseSignMessageResponse(base64Response, networkId) {\n  const networkPrefix = networkId.split(\":\")[0].toLowerCase();\n  switch (networkPrefix) {\n    case \"solana\":\n      return parseSolanaSignatureResponse(base64Response);\n    case \"eip155\":\n    case \"ethereum\":\n      return parseEVMSignatureResponse(base64Response);\n    case \"sui\":\n      return parseSuiSignatureResponse(base64Response);\n    case \"bip122\":\n    case \"bitcoin\":\n      return parseBitcoinSignatureResponse(base64Response);\n    default:\n      return {\n        signature: base64Response,\n        rawSignature: base64Response\n      };\n  }\n}\nfunction parseTransactionResponse(base64RawTransaction, networkId, hash) {\n  let rawTransaction = base64RawTransaction;\n  if ((0,_phantom_utils__WEBPACK_IMPORTED_MODULE_3__.isEthereumChain)(networkId)) {\n    try {\n      const txBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64RawTransaction);\n      rawTransaction = \"0x\" + buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(txBytes).toString(\"hex\");\n    } catch (error) {\n      rawTransaction = base64RawTransaction.startsWith(\"0x\") ? base64RawTransaction : \"0x\" + base64RawTransaction;\n    }\n  }\n  if (hash) {\n    return {\n      hash,\n      rawTransaction,\n      blockExplorer: (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_2__.getExplorerUrl)(networkId, \"transaction\", hash)\n    };\n  } else {\n    return {\n      rawTransaction\n    };\n  }\n}\nfunction parseSolanaSignatureResponse(base64Response) {\n  try {\n    const signatureBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64Response);\n    const signature = bs58__WEBPACK_IMPORTED_MODULE_5__[\"default\"].encode(signatureBytes);\n    return {\n      signature,\n      rawSignature: base64Response\n    };\n  } catch (error) {\n    return {\n      signature: base64Response,\n      rawSignature: base64Response\n    };\n  }\n}\nfunction parseEVMSignatureResponse(base64Response) {\n  const signatureBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64Response);\n  const signature = \"0x\" + buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signatureBytes).toString(\"hex\");\n  return {\n    signature,\n    rawSignature: base64Response\n  };\n}\nfunction parseSuiSignatureResponse(base64Response) {\n  try {\n    const signatureBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64Response);\n    const signature = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signatureBytes).toString(\"base64\");\n    return {\n      signature,\n      rawSignature: base64Response\n    };\n  } catch (error) {\n    return {\n      signature: base64Response,\n      rawSignature: base64Response\n    };\n  }\n}\nfunction parseBitcoinSignatureResponse(base64Response) {\n  try {\n    const signatureBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64Response);\n    const signature = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(signatureBytes).toString(\"hex\");\n    return {\n      signature,\n      rawSignature: base64Response\n    };\n  } catch (error) {\n    return {\n      signature: base64Response,\n      rawSignature: base64Response\n    };\n  }\n}\nfunction parseSolanaSignedTransaction(base64RawTransaction) {\n  try {\n    const transactionBytes = (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlDecode)(base64RawTransaction);\n    return deserializeSolanaTransaction(transactionBytes);\n  } catch (error) {\n    return null;\n  }\n}\nfunction deserializeSolanaTransaction(transactionBytes) {\n  try {\n    const transaction = _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.Transaction.from(transactionBytes);\n    return transaction;\n  } catch (legacyError) {\n    if (legacyError instanceof Error && legacyError.message.includes(\"Versioned messages\")) {\n      const versionedTransaction = _solana_web3_js__WEBPACK_IMPORTED_MODULE_4__.VersionedTransaction.deserialize(transactionBytes);\n      return versionedTransaction;\n    }\n    throw legacyError;\n  }\n}\n\n// src/index.ts\nasync function parseToKmsTransaction(transaction, networkId) {\n  const networkPrefix = networkId.split(\":\")[0].toLowerCase();\n  switch (networkPrefix) {\n    case \"solana\":\n      return parseSolanaTransactionToBase64Url(transaction);\n    case \"ethereum\":\n    case \"eip155\":\n    case \"polygon\":\n    case \"optimism\":\n    case \"arbitrum\":\n    case \"base\":\n      return parseEVMTransactionToHex(transaction);\n    case \"sui\":\n      return await parseSuiTransactionToBase64Url(transaction);\n    case \"bitcoin\":\n      return parseBitcoinTransactionToBase64Url(transaction);\n    default:\n      throw new Error(`Unsupported network: ${networkPrefix}`);\n  }\n}\nfunction parseSolanaTransactionToBase64Url(transaction) {\n  if (transaction?.messageBytes != null) {\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(transaction.messageBytes),\n      originalFormat: \"@solana/kit\"\n    };\n  }\n  if (typeof transaction?.serialize === \"function\") {\n    const serialized = transaction.serialize({\n      requireAllSignatures: false,\n      verifySignatures: false\n    });\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(serialized),\n      originalFormat: \"@solana/web3.js\"\n    };\n  }\n  if (transaction instanceof Uint8Array) {\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(transaction),\n      originalFormat: \"bytes\"\n    };\n  }\n  if (typeof transaction === \"string\") {\n    try {\n      const bytes = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(transaction, \"base64\");\n      return {\n        parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(new Uint8Array(bytes)),\n        originalFormat: \"base64\"\n      };\n    } catch {\n      throw new Error(\"Unsupported Solana transaction format\");\n    }\n  }\n  throw new Error(\"Unsupported Solana transaction format\");\n}\nfunction parseEVMTransactionToHex(transaction) {\n  if (typeof transaction === \"string\" && transaction.startsWith(\"0x\")) {\n    return {\n      parsed: transaction,\n      originalFormat: \"hex\"\n    };\n  }\n  if (transaction?.serialize && typeof transaction.serialize === \"function\") {\n    const serialized = transaction.serialize();\n    const hex = serialized.startsWith(\"0x\") ? serialized : \"0x\" + serialized;\n    return {\n      parsed: hex,\n      originalFormat: \"ethers\"\n    };\n  }\n  if (transaction instanceof Uint8Array) {\n    const hex = \"0x\" + buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(transaction).toString(\"hex\");\n    return {\n      parsed: hex,\n      originalFormat: \"bytes\"\n    };\n  }\n  if (transaction && typeof transaction === \"object\" && (transaction.to || transaction.data || transaction.from)) {\n    try {\n      const { from, gas, ...txForSerialization } = transaction;\n      if (gas) {\n        txForSerialization.gasLimit = gas;\n      }\n      if (!txForSerialization.gasLimit) {\n        if (txForSerialization.to && txForSerialization.value && !txForSerialization.data) {\n          txForSerialization.gasLimit = \"0x5208\";\n        }\n      }\n      if (txForSerialization.to && typeof txForSerialization.to === \"string\") {\n        try {\n          txForSerialization.to = (0,ethers__WEBPACK_IMPORTED_MODULE_6__.getAddress)(txForSerialization.to);\n        } catch {\n          txForSerialization.to = txForSerialization.to.toLowerCase();\n        }\n      }\n      const serialized = ethers__WEBPACK_IMPORTED_MODULE_7__.Transaction.from(txForSerialization).unsignedSerialized;\n      const hex = serialized.startsWith(\"0x\") ? serialized : \"0x\" + serialized;\n      return {\n        parsed: hex,\n        originalFormat: \"json\"\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : \"Unknown error\";\n      const txKeys = transaction ? Object.keys(transaction).join(\", \") : \"N/A\";\n      const txValues = transaction ? JSON.stringify(transaction, null, 2) : \"N/A\";\n      throw new Error(\n        `Failed to RLP encode EVM transaction: ${errorMessage}.\nTransaction keys: [${txKeys}].\nTransaction: ${txValues}\nPlease ensure the transaction object includes required fields (to, value, chainId, gasLimit or gasPrice, etc.)`\n      );\n    }\n  }\n  throw new Error(\n    \"Unsupported EVM transaction format. Expected hex string, bytes, or transaction object with 'to', 'data', or 'from' fields.\"\n  );\n}\nasync function parseSuiTransactionToBase64Url(transaction) {\n  if (transaction?.serialize && typeof transaction.serialize === \"function\") {\n    const serialized = transaction.serialize();\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(serialized),\n      originalFormat: \"sui-sdk\"\n    };\n  }\n  if (transaction instanceof Uint8Array) {\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(transaction),\n      originalFormat: \"bytes\"\n    };\n  }\n  if (transaction?.build && typeof transaction.build === \"function\") {\n    const built = await transaction.build();\n    if (built?.serialize && typeof built.serialize === \"function\") {\n      const serialized = built.serialize();\n      return {\n        parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(serialized),\n        originalFormat: \"transaction-block\"\n      };\n    }\n  }\n  throw new Error(\"Unsupported Sui transaction format\");\n}\nfunction parseBitcoinTransactionToBase64Url(transaction) {\n  if (transaction?.toBuffer && typeof transaction.toBuffer === \"function\") {\n    const buffer = transaction.toBuffer();\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(new Uint8Array(buffer)),\n      originalFormat: \"bitcoinjs-lib\"\n    };\n  }\n  if (transaction instanceof Uint8Array) {\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(transaction),\n      originalFormat: \"bytes\"\n    };\n  }\n  if (typeof transaction === \"string\") {\n    const bytes = new Uint8Array(buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(transaction, \"hex\"));\n    return {\n      parsed: (0,_phantom_base64url__WEBPACK_IMPORTED_MODULE_0__.base64urlEncode)(bytes),\n      originalFormat: \"hex\"\n    };\n  }\n  throw new Error(\"Unsupported Bitcoin transaction format\");\n}\nfunction parseSolanaKitTransactionToSolanaWeb3js(transaction) {\n  const serialized = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_8__.getTransactionEncoder)().encode(transaction);\n  const fakeVersioned = {\n    serialize() {\n      return new Uint8Array(serialized);\n    }\n  };\n  return fakeVersioned;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vcGFyc2Vycy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxRDtBQUNRO0FBQ2xCO0FBQzJCOztBQUV0RTtBQUNxRDtBQUNEO0FBQ0g7QUFDbUI7QUFDNUM7QUFDUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQWU7QUFDckI7QUFDQSxzQkFBc0IsbUVBQWU7QUFDckMsOEJBQThCLDBDQUFNO0FBQ3BDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBYztBQUNuQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBZTtBQUMxQyxzQkFBc0IsNENBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQWU7QUFDeEMsMkJBQTJCLDBDQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUFlO0FBQzFDLHNCQUFzQiwwQ0FBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUFlO0FBQzFDLHNCQUFzQiwwQ0FBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUFlO0FBQzVDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVc7QUFDbkM7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQ0FBbUMsaUVBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLG1FQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1FQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQU87QUFDM0I7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBVTtBQUM1QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQscUJBQXFCLE9BQU87QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQU87QUFDeEM7QUFDQSxjQUFjLG1FQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyRUFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vcGFyc2Vycy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGJhc2U2NHVybEVuY29kZSB9IGZyb20gXCJAcGhhbnRvbS9iYXNlNjR1cmxcIjtcbmltcG9ydCB7IGdldFRyYW5zYWN0aW9uRW5jb2RlciB9IGZyb20gXCJAc29sYW5hL3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgQnVmZmVyIGFzIEJ1ZmZlcjIgfSBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiBhcyBFdGhlcnNUcmFuc2FjdGlvbiwgZ2V0QWRkcmVzcyB9IGZyb20gXCJldGhlcnNcIjtcblxuLy8gc3JjL3Jlc3BvbnNlLXBhcnNlcnMudHNcbmltcG9ydCB7IGJhc2U2NHVybERlY29kZSB9IGZyb20gXCJAcGhhbnRvbS9iYXNlNjR1cmxcIjtcbmltcG9ydCB7IGdldEV4cGxvcmVyVXJsIH0gZnJvbSBcIkBwaGFudG9tL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgaXNFdGhlcmV1bUNoYWluIH0gZnJvbSBcIkBwaGFudG9tL3V0aWxzXCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVmVyc2lvbmVkVHJhbnNhY3Rpb24gfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgYnM1OCBmcm9tIFwiYnM1OFwiO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSBcImJ1ZmZlclwiO1xuZnVuY3Rpb24gcGFyc2VTaWduTWVzc2FnZVJlc3BvbnNlKGJhc2U2NFJlc3BvbnNlLCBuZXR3b3JrSWQpIHtcbiAgY29uc3QgbmV0d29ya1ByZWZpeCA9IG5ldHdvcmtJZC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoIChuZXR3b3JrUHJlZml4KSB7XG4gICAgY2FzZSBcInNvbGFuYVwiOlxuICAgICAgcmV0dXJuIHBhcnNlU29sYW5hU2lnbmF0dXJlUmVzcG9uc2UoYmFzZTY0UmVzcG9uc2UpO1xuICAgIGNhc2UgXCJlaXAxNTVcIjpcbiAgICBjYXNlIFwiZXRoZXJldW1cIjpcbiAgICAgIHJldHVybiBwYXJzZUVWTVNpZ25hdHVyZVJlc3BvbnNlKGJhc2U2NFJlc3BvbnNlKTtcbiAgICBjYXNlIFwic3VpXCI6XG4gICAgICByZXR1cm4gcGFyc2VTdWlTaWduYXR1cmVSZXNwb25zZShiYXNlNjRSZXNwb25zZSk7XG4gICAgY2FzZSBcImJpcDEyMlwiOlxuICAgIGNhc2UgXCJiaXRjb2luXCI6XG4gICAgICByZXR1cm4gcGFyc2VCaXRjb2luU2lnbmF0dXJlUmVzcG9uc2UoYmFzZTY0UmVzcG9uc2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlLFxuICAgICAgICByYXdTaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlXG4gICAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uUmVzcG9uc2UoYmFzZTY0UmF3VHJhbnNhY3Rpb24sIG5ldHdvcmtJZCwgaGFzaCkge1xuICBsZXQgcmF3VHJhbnNhY3Rpb24gPSBiYXNlNjRSYXdUcmFuc2FjdGlvbjtcbiAgaWYgKGlzRXRoZXJldW1DaGFpbihuZXR3b3JrSWQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR4Qnl0ZXMgPSBiYXNlNjR1cmxEZWNvZGUoYmFzZTY0UmF3VHJhbnNhY3Rpb24pO1xuICAgICAgcmF3VHJhbnNhY3Rpb24gPSBcIjB4XCIgKyBCdWZmZXIuZnJvbSh0eEJ5dGVzKS50b1N0cmluZyhcImhleFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmF3VHJhbnNhY3Rpb24gPSBiYXNlNjRSYXdUcmFuc2FjdGlvbi5zdGFydHNXaXRoKFwiMHhcIikgPyBiYXNlNjRSYXdUcmFuc2FjdGlvbiA6IFwiMHhcIiArIGJhc2U2NFJhd1RyYW5zYWN0aW9uO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYXNoLFxuICAgICAgcmF3VHJhbnNhY3Rpb24sXG4gICAgICBibG9ja0V4cGxvcmVyOiBnZXRFeHBsb3JlclVybChuZXR3b3JrSWQsIFwidHJhbnNhY3Rpb25cIiwgaGFzaClcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByYXdUcmFuc2FjdGlvblxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU29sYW5hU2lnbmF0dXJlUmVzcG9uc2UoYmFzZTY0UmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCeXRlcyA9IGJhc2U2NHVybERlY29kZShiYXNlNjRSZXNwb25zZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnM1OC5lbmNvZGUoc2lnbmF0dXJlQnl0ZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICByYXdTaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiBiYXNlNjRSZXNwb25zZSxcbiAgICAgIHJhd1NpZ25hdHVyZTogYmFzZTY0UmVzcG9uc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUVWTVNpZ25hdHVyZVJlc3BvbnNlKGJhc2U2NFJlc3BvbnNlKSB7XG4gIGNvbnN0IHNpZ25hdHVyZUJ5dGVzID0gYmFzZTY0dXJsRGVjb2RlKGJhc2U2NFJlc3BvbnNlKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCIweFwiICsgQnVmZmVyLmZyb20oc2lnbmF0dXJlQnl0ZXMpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZSxcbiAgICByYXdTaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVN1aVNpZ25hdHVyZVJlc3BvbnNlKGJhc2U2NFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnl0ZXMgPSBiYXNlNjR1cmxEZWNvZGUoYmFzZTY0UmVzcG9uc2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZUJ5dGVzKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmF3U2lnbmF0dXJlOiBiYXNlNjRSZXNwb25zZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hdHVyZTogYmFzZTY0UmVzcG9uc2UsXG4gICAgICByYXdTaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VCaXRjb2luU2lnbmF0dXJlUmVzcG9uc2UoYmFzZTY0UmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCeXRlcyA9IGJhc2U2NHVybERlY29kZShiYXNlNjRSZXNwb25zZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlQnl0ZXMpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICByYXdTaWduYXR1cmU6IGJhc2U2NFJlc3BvbnNlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiBiYXNlNjRSZXNwb25zZSxcbiAgICAgIHJhd1NpZ25hdHVyZTogYmFzZTY0UmVzcG9uc2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNvbGFuYVNpZ25lZFRyYW5zYWN0aW9uKGJhc2U2NFJhd1RyYW5zYWN0aW9uKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25CeXRlcyA9IGJhc2U2NHVybERlY29kZShiYXNlNjRSYXdUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplU29sYW5hVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25CeXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU29sYW5hVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25CeXRlcykge1xuICB0cnkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24uZnJvbSh0cmFuc2FjdGlvbkJ5dGVzKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH0gY2F0Y2ggKGxlZ2FjeUVycm9yKSB7XG4gICAgaWYgKGxlZ2FjeUVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgbGVnYWN5RXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIlZlcnNpb25lZCBtZXNzYWdlc1wiKSkge1xuICAgICAgY29uc3QgdmVyc2lvbmVkVHJhbnNhY3Rpb24gPSBWZXJzaW9uZWRUcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZSh0cmFuc2FjdGlvbkJ5dGVzKTtcbiAgICAgIHJldHVybiB2ZXJzaW9uZWRUcmFuc2FjdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgbGVnYWN5RXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL2luZGV4LnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVRvS21zVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG5ldHdvcmtJZCkge1xuICBjb25zdCBuZXR3b3JrUHJlZml4ID0gbmV0d29ya0lkLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKG5ldHdvcmtQcmVmaXgpIHtcbiAgICBjYXNlIFwic29sYW5hXCI6XG4gICAgICByZXR1cm4gcGFyc2VTb2xhbmFUcmFuc2FjdGlvblRvQmFzZTY0VXJsKHRyYW5zYWN0aW9uKTtcbiAgICBjYXNlIFwiZXRoZXJldW1cIjpcbiAgICBjYXNlIFwiZWlwMTU1XCI6XG4gICAgY2FzZSBcInBvbHlnb25cIjpcbiAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICBjYXNlIFwiYmFzZVwiOlxuICAgICAgcmV0dXJuIHBhcnNlRVZNVHJhbnNhY3Rpb25Ub0hleCh0cmFuc2FjdGlvbik7XG4gICAgY2FzZSBcInN1aVwiOlxuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlU3VpVHJhbnNhY3Rpb25Ub0Jhc2U2NFVybCh0cmFuc2FjdGlvbik7XG4gICAgY2FzZSBcImJpdGNvaW5cIjpcbiAgICAgIHJldHVybiBwYXJzZUJpdGNvaW5UcmFuc2FjdGlvblRvQmFzZTY0VXJsKHRyYW5zYWN0aW9uKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBuZXR3b3JrOiAke25ldHdvcmtQcmVmaXh9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU29sYW5hVHJhbnNhY3Rpb25Ub0Jhc2U2NFVybCh0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24/Lm1lc3NhZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnNlZDogYmFzZTY0dXJsRW5jb2RlKHRyYW5zYWN0aW9uLm1lc3NhZ2VCeXRlcyksXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJAc29sYW5hL2tpdFwiXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uPy5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2VkOiBiYXNlNjR1cmxFbmNvZGUoc2VyaWFsaXplZCksXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJAc29sYW5hL3dlYjMuanNcIlxuICAgIH07XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGJhc2U2NHVybEVuY29kZSh0cmFuc2FjdGlvbiksXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJieXRlc1wiXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyMi5mcm9tKHRyYW5zYWN0aW9uLCBcImJhc2U2NFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlZDogYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSksXG4gICAgICAgIG9yaWdpbmFsRm9ybWF0OiBcImJhc2U2NFwiXG4gICAgICB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgU29sYW5hIHRyYW5zYWN0aW9uIGZvcm1hdFwiKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgU29sYW5hIHRyYW5zYWN0aW9uIGZvcm1hdFwiKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRVZNVHJhbnNhY3Rpb25Ub0hleCh0cmFuc2FjdGlvbikge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uID09PSBcInN0cmluZ1wiICYmIHRyYW5zYWN0aW9uLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IHRyYW5zYWN0aW9uLFxuICAgICAgb3JpZ2luYWxGb3JtYXQ6IFwiaGV4XCJcbiAgICB9O1xuICB9XG4gIGlmICh0cmFuc2FjdGlvbj8uc2VyaWFsaXplICYmIHR5cGVvZiB0cmFuc2FjdGlvbi5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBoZXggPSBzZXJpYWxpemVkLnN0YXJ0c1dpdGgoXCIweFwiKSA/IHNlcmlhbGl6ZWQgOiBcIjB4XCIgKyBzZXJpYWxpemVkO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGhleCxcbiAgICAgIG9yaWdpbmFsRm9ybWF0OiBcImV0aGVyc1wiXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgaGV4ID0gXCIweFwiICsgQnVmZmVyMi5mcm9tKHRyYW5zYWN0aW9uKS50b1N0cmluZyhcImhleFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2VkOiBoZXgsXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJieXRlc1wiXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb24gJiYgdHlwZW9mIHRyYW5zYWN0aW9uID09PSBcIm9iamVjdFwiICYmICh0cmFuc2FjdGlvbi50byB8fCB0cmFuc2FjdGlvbi5kYXRhIHx8IHRyYW5zYWN0aW9uLmZyb20pKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgZ2FzLCAuLi50eEZvclNlcmlhbGl6YXRpb24gfSA9IHRyYW5zYWN0aW9uO1xuICAgICAgaWYgKGdhcykge1xuICAgICAgICB0eEZvclNlcmlhbGl6YXRpb24uZ2FzTGltaXQgPSBnYXM7XG4gICAgICB9XG4gICAgICBpZiAoIXR4Rm9yU2VyaWFsaXphdGlvbi5nYXNMaW1pdCkge1xuICAgICAgICBpZiAodHhGb3JTZXJpYWxpemF0aW9uLnRvICYmIHR4Rm9yU2VyaWFsaXphdGlvbi52YWx1ZSAmJiAhdHhGb3JTZXJpYWxpemF0aW9uLmRhdGEpIHtcbiAgICAgICAgICB0eEZvclNlcmlhbGl6YXRpb24uZ2FzTGltaXQgPSBcIjB4NTIwOFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHhGb3JTZXJpYWxpemF0aW9uLnRvICYmIHR5cGVvZiB0eEZvclNlcmlhbGl6YXRpb24udG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0eEZvclNlcmlhbGl6YXRpb24udG8gPSBnZXRBZGRyZXNzKHR4Rm9yU2VyaWFsaXphdGlvbi50byk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHR4Rm9yU2VyaWFsaXphdGlvbi50byA9IHR4Rm9yU2VyaWFsaXphdGlvbi50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gRXRoZXJzVHJhbnNhY3Rpb24uZnJvbSh0eEZvclNlcmlhbGl6YXRpb24pLnVuc2lnbmVkU2VyaWFsaXplZDtcbiAgICAgIGNvbnN0IGhleCA9IHNlcmlhbGl6ZWQuc3RhcnRzV2l0aChcIjB4XCIpID8gc2VyaWFsaXplZCA6IFwiMHhcIiArIHNlcmlhbGl6ZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJzZWQ6IGhleCxcbiAgICAgICAgb3JpZ2luYWxGb3JtYXQ6IFwianNvblwiXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgY29uc3QgdHhLZXlzID0gdHJhbnNhY3Rpb24gPyBPYmplY3Qua2V5cyh0cmFuc2FjdGlvbikuam9pbihcIiwgXCIpIDogXCJOL0FcIjtcbiAgICAgIGNvbnN0IHR4VmFsdWVzID0gdHJhbnNhY3Rpb24gPyBKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbiwgbnVsbCwgMikgOiBcIk4vQVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIFJMUCBlbmNvZGUgRVZNIHRyYW5zYWN0aW9uOiAke2Vycm9yTWVzc2FnZX0uXG5UcmFuc2FjdGlvbiBrZXlzOiBbJHt0eEtleXN9XS5cblRyYW5zYWN0aW9uOiAke3R4VmFsdWVzfVxuUGxlYXNlIGVuc3VyZSB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0IGluY2x1ZGVzIHJlcXVpcmVkIGZpZWxkcyAodG8sIHZhbHVlLCBjaGFpbklkLCBnYXNMaW1pdCBvciBnYXNQcmljZSwgZXRjLilgXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJVbnN1cHBvcnRlZCBFVk0gdHJhbnNhY3Rpb24gZm9ybWF0LiBFeHBlY3RlZCBoZXggc3RyaW5nLCBieXRlcywgb3IgdHJhbnNhY3Rpb24gb2JqZWN0IHdpdGggJ3RvJywgJ2RhdGEnLCBvciAnZnJvbScgZmllbGRzLlwiXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZVN1aVRyYW5zYWN0aW9uVG9CYXNlNjRVcmwodHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uPy5zZXJpYWxpemUgJiYgdHlwZW9mIHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGJhc2U2NHVybEVuY29kZShzZXJpYWxpemVkKSxcbiAgICAgIG9yaWdpbmFsRm9ybWF0OiBcInN1aS1zZGtcIlxuICAgIH07XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGJhc2U2NHVybEVuY29kZSh0cmFuc2FjdGlvbiksXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJieXRlc1wiXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb24/LmJ1aWxkICYmIHR5cGVvZiB0cmFuc2FjdGlvbi5idWlsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgYnVpbHQgPSBhd2FpdCB0cmFuc2FjdGlvbi5idWlsZCgpO1xuICAgIGlmIChidWlsdD8uc2VyaWFsaXplICYmIHR5cGVvZiBidWlsdC5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGJ1aWx0LnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2VkOiBiYXNlNjR1cmxFbmNvZGUoc2VyaWFsaXplZCksXG4gICAgICAgIG9yaWdpbmFsRm9ybWF0OiBcInRyYW5zYWN0aW9uLWJsb2NrXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFN1aSB0cmFuc2FjdGlvbiBmb3JtYXRcIik7XG59XG5mdW5jdGlvbiBwYXJzZUJpdGNvaW5UcmFuc2FjdGlvblRvQmFzZTY0VXJsKHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0cmFuc2FjdGlvbj8udG9CdWZmZXIgJiYgdHlwZW9mIHRyYW5zYWN0aW9uLnRvQnVmZmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0cmFuc2FjdGlvbi50b0J1ZmZlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKSxcbiAgICAgIG9yaWdpbmFsRm9ybWF0OiBcImJpdGNvaW5qcy1saWJcIlxuICAgIH07XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IGJhc2U2NHVybEVuY29kZSh0cmFuc2FjdGlvbiksXG4gICAgICBvcmlnaW5hbEZvcm1hdDogXCJieXRlc1wiXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShCdWZmZXIyLmZyb20odHJhbnNhY3Rpb24sIFwiaGV4XCIpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2VkOiBiYXNlNjR1cmxFbmNvZGUoYnl0ZXMpLFxuICAgICAgb3JpZ2luYWxGb3JtYXQ6IFwiaGV4XCJcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEJpdGNvaW4gdHJhbnNhY3Rpb24gZm9ybWF0XCIpO1xufVxuZnVuY3Rpb24gcGFyc2VTb2xhbmFLaXRUcmFuc2FjdGlvblRvU29sYW5hV2ViM2pzKHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBnZXRUcmFuc2FjdGlvbkVuY29kZXIoKS5lbmNvZGUodHJhbnNhY3Rpb24pO1xuICBjb25zdCBmYWtlVmVyc2lvbmVkID0ge1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzZXJpYWxpemVkKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmYWtlVmVyc2lvbmVkO1xufVxuZXhwb3J0IHtcbiAgZGVzZXJpYWxpemVTb2xhbmFUcmFuc2FjdGlvbixcbiAgcGFyc2VTaWduTWVzc2FnZVJlc3BvbnNlLFxuICBwYXJzZVNvbGFuYUtpdFRyYW5zYWN0aW9uVG9Tb2xhbmFXZWIzanMsXG4gIHBhcnNlU29sYW5hU2lnbmVkVHJhbnNhY3Rpb24sXG4gIHBhcnNlVG9LbXNUcmFuc2FjdGlvbixcbiAgcGFyc2VUcmFuc2FjdGlvblJlc3BvbnNlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/parsers/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/react-sdk/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@phantom/react-sdk/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressType: () => (/* reexport safe */ _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.AddressType),\n/* harmony export */   ConnectBox: () => (/* binding */ ConnectBox),\n/* harmony export */   ConnectButton: () => (/* binding */ ConnectButton),\n/* harmony export */   DebugLevel: () => (/* reexport safe */ _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.DebugLevel),\n/* harmony export */   NetworkId: () => (/* reexport safe */ _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.NetworkId),\n/* harmony export */   PhantomProvider: () => (/* binding */ PhantomProvider),\n/* harmony export */   darkTheme: () => (/* reexport safe */ _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.darkTheme),\n/* harmony export */   debug: () => (/* reexport safe */ _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.debug),\n/* harmony export */   isMobileDevice: () => (/* reexport safe */ _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.isMobileDevice),\n/* harmony export */   lightTheme: () => (/* reexport safe */ _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.lightTheme),\n/* harmony export */   mergeTheme: () => (/* reexport safe */ _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.mergeTheme),\n/* harmony export */   useAccounts: () => (/* binding */ useAccounts),\n/* harmony export */   useAutoConfirm: () => (/* binding */ useAutoConfirm),\n/* harmony export */   useConnect: () => (/* binding */ useConnect),\n/* harmony export */   useDisconnect: () => (/* binding */ useDisconnect),\n/* harmony export */   useDiscoveredWallets: () => (/* binding */ useDiscoveredWallets),\n/* harmony export */   useEthereum: () => (/* binding */ useEthereum),\n/* harmony export */   useIsExtensionInstalled: () => (/* binding */ useIsExtensionInstalled),\n/* harmony export */   useIsPhantomLoginAvailable: () => (/* binding */ useIsPhantomLoginAvailable),\n/* harmony export */   useModal: () => (/* binding */ useModal),\n/* harmony export */   usePhantom: () => (/* binding */ usePhantom),\n/* harmony export */   useSolana: () => (/* binding */ useSolana),\n/* harmony export */   useTheme: () => (/* reexport safe */ _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @phantom/browser-sdk */ \"(ssr)/./node_modules/@phantom/browser-sdk/dist/index.mjs\");\n/* harmony import */ var _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @phantom/wallet-sdk-ui */ \"(ssr)/./node_modules/@phantom/wallet-sdk-ui/dist/index.mjs\");\n/* harmony import */ var _phantom_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @phantom/constants */ \"(ssr)/./node_modules/@phantom/constants/dist/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/PhantomProvider.tsx\n\n\n\n\n// src/PhantomContext.ts\n\nvar PhantomContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction usePhantom() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PhantomContext);\n  if (!context) {\n    throw new Error(\"usePhantom must be used within a PhantomProvider\");\n  }\n  return context;\n}\n\n// src/ModalProvider.tsx\n\n\n// src/ModalContext.ts\n\nvar ModalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction useModal() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ModalContext);\n  if (!context) {\n    throw new Error(\"useModal must be used within a ModalProvider\");\n  }\n  return {\n    open: context.openModal,\n    close: context.closeModal,\n    isOpened: context.isModalOpen\n  };\n}\n\n// src/ModalProvider.tsx\n\n\n\n// src/components/ConnectModalContent.tsx\n\n\n\n\n\n// src/hooks/useIsExtensionInstalled.ts\n\n\nfunction useIsExtensionInstalled() {\n  const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n  const [isInstalled, setIsInstalled] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let isMounted = true;\n    const checkExtension = async () => {\n      try {\n        setIsLoading(true);\n        const result = await (0,_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.waitForPhantomExtension)(3e3);\n        if (isMounted) {\n          setIsInstalled(result);\n        }\n      } catch (error) {\n        if (isMounted) {\n          setIsInstalled(false);\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n    checkExtension();\n    return () => {\n      isMounted = false;\n    };\n  }, []);\n  return { isLoading, isInstalled };\n}\n\n// src/hooks/useIsPhantomLoginAvailable.ts\n\n\nfunction useIsPhantomLoginAvailable() {\n  const [isLoading, setIsLoading] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n  const [isAvailable, setIsAvailable] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let isMounted = true;\n    const checkPhantomLogin = async () => {\n      try {\n        setIsLoading(true);\n        const result = await (0,_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.isPhantomLoginAvailable)(3e3);\n        if (isMounted) {\n          setIsAvailable(result);\n        }\n      } catch (error) {\n        if (isMounted) {\n          setIsAvailable(false);\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n    checkPhantomLogin();\n    return () => {\n      isMounted = false;\n    };\n  }, []);\n  return { isLoading, isAvailable };\n}\n\n// src/hooks/useConnect.ts\n\nfunction useConnect() {\n  const { sdk, isConnecting, isLoading, errors } = usePhantom();\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (options) => {\n      if (!sdk) {\n        throw new Error(\"SDK not initialized\");\n      }\n      try {\n        const result = await sdk.connect(options);\n        return result;\n      } catch (err) {\n        console.error(\"Error connecting to Phantom:\", err);\n        throw err;\n      }\n    },\n    [sdk]\n  );\n  return {\n    connect,\n    isConnecting,\n    isLoading,\n    error: errors.connect\n  };\n}\n\n// src/hooks/useDiscoveredWallets.ts\n\nfunction useDiscoveredWallets() {\n  const { sdk } = usePhantom();\n  const [wallets, setWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!sdk) {\n      setWallets([]);\n      setError(null);\n      setIsLoading(false);\n      return;\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      const initialWallets = sdk.getDiscoveredWallets();\n      if (initialWallets.length > 0) {\n        setWallets(initialWallets);\n        setIsLoading(false);\n      } else {\n        await sdk.discoverWallets();\n        const discoveredWallets = sdk.getDiscoveredWallets();\n        setWallets(discoveredWallets);\n        setIsLoading(false);\n      }\n    } catch (err) {\n      const error2 = err instanceof Error ? err : new Error(\"Failed to fetch discovered wallets\");\n      setError(error2);\n      setWallets([]);\n      setIsLoading(false);\n    }\n  }, [sdk]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    refetch();\n  }, [refetch]);\n  return {\n    wallets,\n    isLoading,\n    error,\n    refetch\n  };\n}\n\n// src/components/ChainIcon.tsx\n\n\nvar IconWrapper = ({ children }) => {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n    \"span\",\n    {\n      style: {\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        borderRadius: \"4px\",\n        backgroundColor: theme.aux,\n        color: theme.text,\n        padding: \"2px\"\n      },\n      children\n    }\n  );\n};\nfunction ChainIcon({ addressType, size = 8 }) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const type = addressType.toLowerCase();\n  if (type.includes(\"solana\")) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(IconWrapper, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"solana\", size, color: theme.text }) });\n  }\n  if (type.includes(\"ethereum\") || type.includes(\"evm\")) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(IconWrapper, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"ethereum\", size, color: theme.text }) });\n  }\n  if (type.includes(\"bitcoin\")) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(IconWrapper, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"bitcoin\", size, color: theme.text }) });\n  }\n  if (type.includes(\"sui\")) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(IconWrapper, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"sui\", size, color: theme.text }) });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n    \"span\",\n    {\n      style: {\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        borderRadius: \"4px\",\n        backgroundColor: theme.aux,\n        color: theme.text,\n        fontSize: \"6px\",\n        fontWeight: \"bold\",\n        lineHeight: \"1\",\n        padding: \"2px\"\n      },\n      title: addressType,\n      children: addressType.charAt(0).toUpperCase()\n    }\n  );\n}\n\n// src/components/ConnectModalContent.tsx\n\nfunction ConnectModalContent({\n  appIcon,\n  appName = \"App Name\",\n  onClose,\n  hideCloseButton = false\n}) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const { isLoading, allowedProviders } = usePhantom();\n  const baseConnect = useConnect();\n  const isExtensionInstalled = useIsExtensionInstalled();\n  const isPhantomLoginAvailable2 = useIsPhantomLoginAvailable();\n  const isMobile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.isMobileDevice)(), []);\n  const { wallets: discoveredWallets } = useDiscoveredWallets();\n  const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [providerType, setProviderType] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [showOtherWallets, setShowOtherWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [selectedWalletId, setSelectedWalletId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const isConnectingState = baseConnect.isConnecting || isConnecting;\n  const errorState = baseConnect.error ? baseConnect.error.message : error;\n  const showDivider = !(allowedProviders.length === 1 && allowedProviders.includes(\"injected\"));\n  const isInjectedOnly = allowedProviders.length === 1 && allowedProviders.includes(\"injected\");\n  const shouldShowOtherWalletsButton = !isInjectedOnly && discoveredWallets.length > 2;\n  const walletsToShowInline = shouldShowOtherWalletsButton ? [] : discoveredWallets;\n  const connectWithAuthProvider = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (provider, walletId) => {\n      try {\n        setIsConnecting(true);\n        setError(null);\n        setProviderType(provider);\n        setSelectedWalletId(walletId || null);\n        await baseConnect.connect({ provider, walletId });\n        onClose();\n      } catch {\n        const wallet = discoveredWallets.find((w) => w.id === walletId);\n        const providerName = wallet?.name || (0,_phantom_constants__WEBPACK_IMPORTED_MODULE_3__.getProviderName)(provider);\n        setError(`Failed to connect to ${providerName}`);\n      } finally {\n        setIsConnecting(false);\n        setProviderType(null);\n        setSelectedWalletId(null);\n      }\n    },\n    [baseConnect, discoveredWallets, onClose]\n  );\n  const connectWithWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (wallet) => {\n      await connectWithAuthProvider(\"injected\", wallet.id);\n    },\n    [connectWithAuthProvider]\n  );\n  const connectWithDeeplink = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    try {\n      setIsConnecting(true);\n      setError(null);\n      setProviderType(\"deeplink\");\n      await baseConnect.connect({ provider: \"deeplink\" });\n      onClose();\n    } catch (error2) {\n      const errorMessage = error2 instanceof Error ? error2.message : \"Failed to open deeplink\";\n      setError(errorMessage);\n    } finally {\n      setIsConnecting(false);\n      setProviderType(null);\n    }\n  }, [baseConnect, onClose]);\n  const appIconStyle = {\n    width: \"56px\",\n    height: \"56px\",\n    borderRadius: \"50%\",\n    display: \"block\",\n    objectFit: \"cover\",\n    marginBottom: \"12px\"\n  };\n  const connectContentContainerStyle = {\n    transition: \"opacity 0.15s ease-in-out, transform 0.15s ease-in-out\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    gap: \"12px\",\n    padding: \"0 32px\"\n  };\n  const otherWalletsContainerStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    gap: \"12px\",\n    maxHeight: \"480px\",\n    overflowY: \"auto\",\n    padding: \"0 32px 32px 32px\",\n    transition: \"opacity 0.15s ease-in-out, transform 0.15s ease-in-out\"\n  };\n  const dividerStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    width: \"100%\",\n    margin: \"12px 0\",\n    ...theme.typography.caption,\n    color: theme.secondary,\n    textTransform: \"uppercase\"\n  };\n  const dividerLineStyle = {\n    flex: 1,\n    height: \"1px\",\n    backgroundColor: (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.hexToRgba)(theme.secondary, 0.1)\n  };\n  const dividerTextStyle = {\n    padding: \"0 12px\"\n  };\n  const errorStyle = {\n    backgroundColor: \"rgba(220, 53, 69, 0.1)\",\n    color: \"#ff6b6b\",\n    border: \"1px solid rgba(220, 53, 69, 0.3)\",\n    borderRadius: theme.borderRadius,\n    boxSizing: \"border-box\",\n    padding: \"12px\",\n    width: \"100%\",\n    fontSize: \"14px\"\n  };\n  const loadingContainerStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    padding: \"24px\",\n    gap: \"12px\"\n  };\n  const spinnerStyle = {\n    width: \"40px\",\n    height: \"40px\",\n    border: `3px solid ${theme.secondary}`,\n    borderTop: `3px solid ${theme.brand}`,\n    borderRadius: \"50%\",\n    animation: \"spin 1s linear infinite\"\n  };\n  const walletIconStyle = {\n    width: \"32px\",\n    height: \"32px\",\n    borderRadius: \"8px\",\n    objectFit: \"cover\"\n  };\n  const walletButtonContentStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    gap: \"8px\",\n    width: \"100%\"\n  };\n  const walletButtonLeftStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    gap: \"8px\",\n    flex: 1\n  };\n  const walletNameContainerStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: \"4px\",\n    alignItems: \"flex-start\"\n  };\n  const chainIndicatorsStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    gap: \"4px\"\n  };\n  const walletButtonRightStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    gap: \"8px\",\n    color: theme.secondary\n  };\n  const footerStyle = {\n    display: \"flex\",\n    padding: \"16px\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    gap: \"4px\",\n    borderTop: \"1px solid rgba(152, 151, 156, 0.10)\",\n    ...theme.typography.caption,\n    color: theme.secondary\n  };\n  const contentWrapperStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    justifyContent: \"space-between\",\n    gap: \"24px\"\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: contentWrapperStyle, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"style\", { children: `\n          @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n          }\n        ` }),\n    isLoading || baseConnect.isConnecting ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: loadingContainerStyle, children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: spinnerStyle }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"label\", color: theme.secondary, children: \"Loading...\" })\n    ] }) : showOtherWallets ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n        _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.ModalHeader,\n        {\n          goBack: true,\n          onGoBack: () => {\n            setError(null);\n            setShowOtherWallets(false);\n          },\n          title: \"Other Wallets\",\n          onClose,\n          hideCloseButton\n        }\n      ),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: otherWalletsContainerStyle, children: [\n        errorState && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: errorStyle, children: errorState }),\n        discoveredWallets.map((wallet) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n          _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button,\n          {\n            onClick: () => connectWithWallet(wallet),\n            disabled: isConnectingState,\n            isLoading: isConnectingState && providerType === \"injected\" && selectedWalletId === wallet.id,\n            fullWidth: true,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonContentStyle, children: [\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonLeftStyle, children: [\n                wallet.id === \"phantom\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.BoundedIcon, { type: \"phantom\", size: 20, background: \"#aba0f2\", color: \"white\" }) : wallet.icon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"img\", { src: wallet.icon, alt: wallet.name, style: walletIconStyle }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.BoundedIcon, { type: \"wallet\", size: 20, background: theme.aux, color: theme.text }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: walletNameContainerStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: wallet.name }) })\n              ] }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonRightStyle, children: [\n                wallet.addressTypes && wallet.addressTypes.length > 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: chainIndicatorsStyle, children: wallet.addressTypes.map((addressType) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ChainIcon, { addressType, size: 8 }) }, `${wallet.id}-chain-${addressType}`)) }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"chevron-right\", size: 16, color: theme.secondary })\n              ] })\n            ] })\n          },\n          wallet.id\n        ))\n      ] })\n    ] }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.ModalHeader, { title: \"Login or Sign Up\", onClose, hideCloseButton }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: connectContentContainerStyle, children: [\n        appIcon && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"img\", { src: appIcon, alt: appName, style: appIconStyle }),\n        errorState && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: errorStyle, children: errorState }),\n        isMobile && !isExtensionInstalled.isInstalled && allowedProviders.includes(\"deeplink\") && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n          _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.LoginWithPhantomButton,\n          {\n            testId: \"deeplink-button\",\n            onClick: connectWithDeeplink,\n            disabled: isConnectingState,\n            isLoading: isConnectingState && providerType === \"deeplink\",\n            fullWidth: true,\n            children: isConnecting && providerType === \"deeplink\" ? \"Opening Phantom...\" : \"Open in Phantom App\"\n          }\n        ),\n        !isMobile && allowedProviders.includes(\"phantom\") && isPhantomLoginAvailable2.isAvailable && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n          _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.LoginWithPhantomButton,\n          {\n            testId: \"login-with-phantom-button\",\n            onClick: () => connectWithAuthProvider(\"phantom\"),\n            disabled: isConnectingState,\n            isLoading: isConnectingState && providerType === \"phantom\"\n          }\n        ),\n        allowedProviders.includes(\"google\") && !(isMobile && isExtensionInstalled.isInstalled) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n          _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button,\n          {\n            onClick: () => connectWithAuthProvider(\"google\"),\n            disabled: isConnectingState,\n            isLoading: isConnectingState && providerType === \"google\",\n            fullWidth: true,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonContentStyle, children: [\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonLeftStyle, children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"google\", size: 20 }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: \"Continue with Google\" })\n              ] }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: walletButtonRightStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"chevron-right\", size: 16, color: theme.secondary }) })\n            ] })\n          }\n        ),\n        allowedProviders.includes(\"apple\") && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n          _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button,\n          {\n            onClick: () => connectWithAuthProvider(\"apple\"),\n            disabled: isConnectingState,\n            isLoading: isConnectingState && providerType === \"apple\",\n            fullWidth: true,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonContentStyle, children: [\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonLeftStyle, children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"apple\", size: 20 }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: \"Continue with Apple\" })\n              ] }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: walletButtonRightStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"chevron-right\", size: 16, color: theme.secondary }) })\n            ] })\n          }\n        ),\n        allowedProviders.includes(\"injected\") && (isExtensionInstalled.isInstalled || discoveredWallets.length > 0) && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, { children: [\n          showDivider && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: dividerStyle, children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: dividerLineStyle }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: dividerTextStyle, children: \"OR\" }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: dividerLineStyle })\n          ] }),\n          walletsToShowInline.map((wallet) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n            _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button,\n            {\n              onClick: () => connectWithWallet(wallet),\n              disabled: isConnectingState,\n              isLoading: isConnectingState && providerType === \"injected\" && selectedWalletId === wallet.id,\n              fullWidth: true,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonContentStyle, children: [\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonLeftStyle, children: [\n                  wallet.id === \"phantom\" ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.BoundedIcon, { type: \"phantom\", size: 20, background: \"#aba0f2\", color: \"white\" }) : wallet.icon ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"img\", { src: wallet.icon, alt: wallet.name, style: walletIconStyle }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.BoundedIcon, { type: \"wallet\", size: 10, background: theme.aux, color: theme.text }),\n                  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: walletNameContainerStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: wallet.name }) })\n                ] }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonRightStyle, children: [\n                  wallet.addressTypes && wallet.addressTypes.length > 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: chainIndicatorsStyle, children: wallet.addressTypes.map((addressType) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ChainIcon, { addressType, size: 8 }) }, `${wallet.id}-chain-${addressType}`)) }),\n                  /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"chevron-right\", size: 16, color: theme.secondary })\n                ] })\n              ] })\n            },\n            wallet.id\n          )),\n          shouldShowOtherWalletsButton && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button, { onClick: () => setShowOtherWallets(true), disabled: isConnectingState, fullWidth: true, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonContentStyle, children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"span\", { style: walletButtonLeftStyle, children: [\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.BoundedIcon, { type: \"wallet\", size: 20, background: theme.aux, color: theme.text }),\n              /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: \"Other Wallets\" })\n            ] }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: walletButtonRightStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"chevron-right\", size: 16, color: theme.secondary }) })\n          ] }) })\n        ] })\n      ] }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: footerStyle, children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"label\", color: theme.secondary, children: \"Powered by\" }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Icon, { type: \"phantom\", size: 16 }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"label\", color: theme.secondary, children: \"Phantom\" })\n      ] })\n    ] })\n  ] });\n}\n\n// src/components/ConnectedModalContent.tsx\n\n\n\n// src/hooks/useDisconnect.ts\n\nfunction useDisconnect() {\n  const { sdk } = usePhantom();\n  const [isDisconnecting, setIsDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!sdk) {\n      throw new Error(\"SDK not initialized\");\n    }\n    setIsDisconnecting(true);\n    setError(null);\n    try {\n      await sdk.disconnect();\n    } catch (err) {\n      const error2 = err instanceof Error ? err : new Error(String(err));\n      setError(error2);\n      throw err;\n    } finally {\n      setIsDisconnecting(false);\n    }\n  }, [sdk]);\n  return {\n    disconnect,\n    isDisconnecting,\n    error\n  };\n}\n\n// src/components/ConnectedModalContent.tsx\n\nfunction ConnectedModalContent({ onClose, hideCloseButton = false }) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const { addresses } = usePhantom();\n  const { disconnect } = useDisconnect();\n  const [isDisconnecting, setIsDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [disconnectError, setDisconnectError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setDisconnectError(null);\n  }, []);\n  const handleDisconnect = async () => {\n    try {\n      setIsDisconnecting(true);\n      setDisconnectError(null);\n      await disconnect();\n      onClose();\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setDisconnectError(error);\n    } finally {\n      setIsDisconnecting(false);\n    }\n  };\n  const accountListStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: \"16px\",\n    width: \"100%\",\n    minWidth: 0,\n    boxSizing: \"border-box\"\n  };\n  const accountItemStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: \"8px\",\n    width: \"100%\",\n    minWidth: 0,\n    boxSizing: \"border-box\"\n  };\n  const addressTextStyle = {\n    fontFamily: \"monospace\",\n    wordBreak: \"break-all\",\n    overflowWrap: \"break-word\",\n    minWidth: 0\n  };\n  const errorContainerStyle = {\n    padding: \"12px\",\n    backgroundColor: \"rgba(220, 53, 69, 0.1)\",\n    borderRadius: theme.borderRadius,\n    border: \"1px solid rgba(220, 53, 69, 0.3)\",\n    width: \"100%\",\n    boxSizing: \"border-box\",\n    minWidth: 0\n  };\n  const contentWrapperStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    gap: \"24px\"\n  };\n  const accountListContainerStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    gap: \"12px\",\n    padding: \"0 32px 24px 32px\",\n    boxSizing: \"border-box\",\n    width: \"100%\",\n    minWidth: 0\n  };\n  const disconnectButtonContainerStyle = {\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    gap: \"12px\",\n    padding: \"0 32px 24px 32px\",\n    boxSizing: \"border-box\",\n    width: \"100%\",\n    minWidth: 0\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: contentWrapperStyle, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.ModalHeader, { title: \"Wallet\", onClose, hideCloseButton }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: accountListContainerStyle, children: [\n      disconnectError && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: errorContainerStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"caption\", color: theme.error, children: \"Failed to disconnect\" }) }),\n      addresses && addresses.length > 0 && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: accountListStyle, children: addresses.map((account, index) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: accountItemStyle, children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"label\", color: theme.secondary, style: { textTransform: \"uppercase\" }, children: account.addressType }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: addressTextStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"caption\", children: account.address }) })\n      ] }, index)) })\n    ] }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: disconnectButtonContainerStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button, { onClick: handleDisconnect, disabled: isDisconnecting, isLoading: isDisconnecting, fullWidth: true, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: isDisconnecting ? \"Disconnecting...\" : \"Disconnect\" }) }) })\n  ] });\n}\n\n// src/components/SpendingLimitModalContent.tsx\n\n\nfunction SpendingLimitModalContent({ onClose }) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(\"div\", { style: { display: \"flex\", flexDirection: \"column\", gap: 16, padding: 32 }, children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"caption\", color: theme.secondary, children: \"You've reached the maximum daily limit allowed to spend by this application.\" }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Button, { fullWidth: true, onClick: onClose, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Text, { variant: \"captionBold\", children: \"Close\" }) })\n  ] });\n}\n\n// src/ModalProvider.tsx\n\nfunction ModalProvider({ children, appIcon, appName }) {\n  const { isConnected, errors, clearError } = usePhantom();\n  const [isModalOpen, setIsModalOpen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const isMobile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.isMobileDevice)(), []);\n  const openModal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    setIsModalOpen(true);\n  }, []);\n  const closeModal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    setIsModalOpen(false);\n    clearError(\"spendingLimit\");\n  }, [clearError]);\n  const isSpendingLimitOpen = !!errors.spendingLimit;\n  const modalContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      isModalOpen,\n      openModal,\n      closeModal\n    }),\n    [isModalOpen, openModal, closeModal]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(ModalContext.Provider, { value: modalContextValue, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\n      _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.Modal,\n      {\n        isVisible: isModalOpen || isSpendingLimitOpen,\n        onClose: closeModal,\n        appIcon,\n        appName,\n        isMobile,\n        children: isSpendingLimitOpen ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(SpendingLimitModalContent, { onClose: closeModal }) : isConnected ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ConnectedModalContent, { onClose: closeModal }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ConnectModalContent, { appIcon, appName, onClose: closeModal })\n      }\n    )\n  ] });\n}\n\n// src/PhantomProvider.tsx\n\nfunction PhantomProvider({ children, config, debugConfig, theme, appIcon, appName }) {\n  const memoizedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => config, [config]);\n  const resolvedTheme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.mergeTheme)(theme || _phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.darkTheme), [theme]);\n  const [sdk, setSdk] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [isClient, setIsClient] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n  const [errors, setErrors] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const [addresses, setAddresses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setIsClient(true);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isClient)\n      return;\n    const sdkInstance = new _phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.BrowserSDK(memoizedConfig);\n    setSdk(sdkInstance);\n  }, [isClient, memoizedConfig]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!sdk)\n      return;\n    const handleConnectStart = () => {\n      setIsConnecting(true);\n      setErrors((prev) => ({ ...prev, connect: void 0 }));\n    };\n    const handleConnect = async (data) => {\n      try {\n        setIsConnected(true);\n        setIsConnecting(false);\n        setUser(data);\n        const addrs = await sdk.getAddresses();\n        setAddresses(addrs);\n      } catch (err) {\n        console.error(\"Error connecting:\", err);\n        try {\n          await sdk.disconnect();\n        } catch (err2) {\n          console.error(\"Error disconnecting:\", err2);\n        }\n      }\n    };\n    const handleConnectError = (errorData) => {\n      setIsConnecting(false);\n      setIsConnected(false);\n      const isAutoConnectNoSession = errorData.source === \"auto-connect\" && (errorData.error === \"No valid session found\" || errorData.error === \"No trusted connections available\");\n      if (isAutoConnectNoSession) {\n        setErrors((prev) => ({ ...prev, connect: void 0 }));\n      } else {\n        setErrors((prev) => ({ ...prev, connect: new Error(errorData.error || \"Connection failed\") }));\n      }\n      setAddresses([]);\n    };\n    const handleDisconnect = () => {\n      setIsConnected(false);\n      setIsConnecting(false);\n      setErrors({});\n      setAddresses([]);\n      setUser(null);\n    };\n    const handleSpendingLimitReached = () => {\n      setErrors((prev) => ({ ...prev, spendingLimit: true }));\n    };\n    sdk.on(\"connect_start\", handleConnectStart);\n    sdk.on(\"connect\", handleConnect);\n    sdk.on(\"connect_error\", handleConnectError);\n    sdk.on(\"disconnect\", handleDisconnect);\n    sdk.on(\"spending_limit_reached\", handleSpendingLimitReached);\n    return () => {\n      sdk.off(\"connect_start\", handleConnectStart);\n      sdk.off(\"connect\", handleConnect);\n      sdk.off(\"connect_error\", handleConnectError);\n      sdk.off(\"disconnect\", handleDisconnect);\n      sdk.off(\"spending_limit_reached\", handleSpendingLimitReached);\n    };\n  }, [sdk]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!debugConfig || !sdk)\n      return;\n    sdk.configureDebug(debugConfig);\n  }, [sdk, debugConfig]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isClient || !sdk)\n      return;\n    const initialize = async () => {\n      try {\n        await sdk.autoConnect();\n      } catch (error) {\n        console.error(\"Auto-connect error:\", error);\n      }\n      setIsLoading(false);\n    };\n    initialize();\n  }, [sdk, isClient]);\n  const clearError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((key) => {\n    setErrors((prev) => {\n      const next = { ...prev };\n      delete next[key];\n      return next;\n    });\n  }, []);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      sdk,\n      isConnected,\n      isConnecting,\n      isLoading,\n      errors,\n      addresses,\n      isClient,\n      user,\n      theme: resolvedTheme,\n      allowedProviders: memoizedConfig.providers,\n      clearError\n    }),\n    [\n      sdk,\n      isConnected,\n      isConnecting,\n      isLoading,\n      errors,\n      addresses,\n      isClient,\n      user,\n      resolvedTheme,\n      memoizedConfig.providers,\n      clearError\n    ]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.ThemeProvider, { theme: resolvedTheme, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(PhantomContext.Provider, { value, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ModalProvider, { appIcon, appName, children }) }) });\n}\n\n// src/hooks/useAccounts.ts\nfunction useAccounts() {\n  const { addresses, isConnected } = usePhantom();\n  return isConnected ? addresses : null;\n}\n\n// src/hooks/useAutoConfirm.ts\n\nfunction useAutoConfirm() {\n  const { sdk, user } = usePhantom();\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [supportedChains, setSupportedChains] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const isInjected = user?.authProvider === \"injected\";\n  const enable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (params) => {\n      if (!sdk) {\n        throw new Error(\"SDK not initialized\");\n      }\n      if (!isInjected) {\n        throw new Error(\"Auto-confirm is only available for injected (extension) providers\");\n      }\n      try {\n        setIsLoading(true);\n        setError(null);\n        const result = await sdk.enableAutoConfirm(params);\n        setStatus(result);\n        return result;\n      } catch (err) {\n        const error2 = err instanceof Error ? err : new Error(\"Unknown error occurred\");\n        setError(error2);\n        throw error2;\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [sdk, isInjected]\n  );\n  const disable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!sdk) {\n      throw new Error(\"SDK not initialized\");\n    }\n    if (!isInjected) {\n      throw new Error(\"Auto-confirm is only available for injected (extension) providers\");\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      await sdk.disableAutoConfirm();\n      const newStatus = await sdk.getAutoConfirmStatus();\n      setStatus(newStatus);\n    } catch (err) {\n      const error2 = err instanceof Error ? err : new Error(\"Unknown error occurred\");\n      setError(error2);\n      throw error2;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sdk, isInjected]);\n  const refetch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!sdk || !isInjected) {\n      return;\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      const [statusResult, supportedResult] = await Promise.all([\n        sdk.getAutoConfirmStatus(),\n        sdk.getSupportedAutoConfirmChains()\n      ]);\n      setStatus(statusResult);\n      setSupportedChains(supportedResult);\n    } catch (err) {\n      const error2 = err instanceof Error ? err : new Error(\"Failed to fetch auto-confirm data\");\n      setError(error2);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [sdk, isInjected]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (sdk && isInjected) {\n      refetch();\n    } else {\n      setStatus(null);\n      setSupportedChains(null);\n      setError(null);\n    }\n  }, [sdk, isInjected, refetch]);\n  return {\n    enable,\n    disable,\n    status,\n    supportedChains,\n    isLoading,\n    error,\n    refetch\n  };\n}\n\n// src/hooks/useSolana.ts\n\nfunction useSolana() {\n  const { sdk, isClient, isLoading } = usePhantom();\n  if (!isClient || !sdk || isLoading) {\n    return {\n      solana: {},\n      isAvailable: false\n    };\n  }\n  const enabledAddressTypes = sdk.getEnabledAddressTypes();\n  const isAvailable = enabledAddressTypes.includes(_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.AddressType.solana);\n  if (!isAvailable) {\n    return {\n      solana: {},\n      isAvailable: false\n    };\n  }\n  try {\n    return {\n      solana: sdk.solana,\n      isAvailable: true\n    };\n  } catch (error) {\n    return {\n      solana: {},\n      isAvailable: false\n    };\n  }\n}\n\n// src/hooks/useEthereum.ts\n\nfunction useEthereum() {\n  const { sdk, isClient, isLoading } = usePhantom();\n  if (!isClient || !sdk || isLoading) {\n    return {\n      ethereum: {},\n      isAvailable: false\n    };\n  }\n  const enabledAddressTypes = sdk.getEnabledAddressTypes();\n  const isAvailable = enabledAddressTypes.includes(_phantom_browser_sdk__WEBPACK_IMPORTED_MODULE_1__.AddressType.ethereum);\n  if (!isAvailable) {\n    return {\n      ethereum: {},\n      isAvailable: false\n    };\n  }\n  try {\n    return {\n      ethereum: sdk.ethereum,\n      isAvailable: true\n    };\n  } catch (error) {\n    return {\n      ethereum: {},\n      isAvailable: false\n    };\n  }\n}\n\n// src/hooks/index.ts\n\n\n// src/components/ConnectButton.tsx\n\n\n\nfunction ConnectButton({ addressType, fullWidth = false }) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const { open } = useModal();\n  const { isConnected, addresses } = usePhantom();\n  const displayAddress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!addresses || addresses.length === 0)\n      return null;\n    if (addressType) {\n      return addresses.find((addr) => addr.addressType === addressType);\n    }\n    return addresses[0];\n  }, [addresses, addressType]);\n  const truncatedAddress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!displayAddress)\n      return \"\";\n    const addr = displayAddress.address;\n    if (addr.length <= 12)\n      return addr;\n    return `${addr.slice(0, 6)}...${addr.slice(-4)}`;\n  }, [displayAddress]);\n  const buttonStyle = {\n    width: fullWidth ? \"100%\" : \"auto\",\n    padding: \"12px 16px\",\n    border: \"none\",\n    borderRadius: theme.borderRadius,\n    fontFamily: theme.typography.captionBold.fontFamily,\n    fontSize: theme.typography.captionBold.fontSize,\n    fontStyle: theme.typography.captionBold.fontStyle,\n    fontWeight: theme.typography.captionBold.fontWeight,\n    lineHeight: theme.typography.captionBold.lineHeight,\n    letterSpacing: theme.typography.captionBold.letterSpacing,\n    cursor: \"pointer\",\n    transition: \"background-color 0.2s\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: \"8px\",\n    background: theme.aux,\n    color: theme.text\n  };\n  const connectedButtonStyle = {\n    ...buttonStyle,\n    background: theme.aux,\n    cursor: \"pointer\"\n  };\n  if (isConnected && displayAddress) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"button\", { style: connectedButtonStyle, onClick: open, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"span\", { style: { fontFamily: \"monospace\" }, children: truncatedAddress }) });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"button\", { style: buttonStyle, onClick: open, children: \"Connect Wallet\" });\n}\n\n// src/components/ConnectBox.tsx\n\n\n\nfunction ConnectBox({ maxWidth = \"350px\", transparent = false, appIcon, appName }) {\n  const theme = (0,_phantom_wallet_sdk_ui__WEBPACK_IMPORTED_MODULE_2__.useTheme)();\n  const { isConnected } = usePhantom();\n  const boxStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const style = {\n      width: \"100%\",\n      maxWidth: typeof maxWidth === \"number\" ? `${maxWidth}px` : maxWidth,\n      position: \"relative\",\n      overflow: \"hidden\"\n    };\n    if (!transparent) {\n      style.backgroundColor = theme.background;\n      style.borderRadius = theme.borderRadius;\n    }\n    return style;\n  }, [maxWidth, transparent, theme.background, theme.borderRadius]);\n  const noOp = () => {\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { style: boxStyle, children: isConnected ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ConnectedModalContent, { onClose: noOp, hideCloseButton: true }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ConnectModalContent, { appIcon, appName, onClose: noOp, hideCloseButton: true }) });\n}\n\n// src/index.ts\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vcmVhY3Qtc2RrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5SDtBQUN2RTtBQUM0Qjs7QUFFOUU7QUFDa0Q7QUFDbEQscUJBQXFCLG9EQUFhO0FBQ2xDO0FBQ0Esa0JBQWtCLGlEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0c7O0FBRWhHO0FBQ21GO0FBQ25GLG1CQUFtQixvREFBYztBQUNqQztBQUNBLGtCQUFrQixpREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUU7QUFDMUI7O0FBRS9DO0FBQ29GO0FBQzlCO0FBVXRCO0FBQ3FCOztBQUVyRDtBQUMrQjtBQUNnQztBQUMvRDtBQUNBLG9DQUFvQywyQ0FBYztBQUNsRCx3Q0FBd0MsMkNBQWM7QUFDdEQsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2RUFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ2dDO0FBQytCO0FBQy9EO0FBQ0Esb0NBQW9DLDJDQUFlO0FBQ25ELHdDQUF3QywyQ0FBZTtBQUN2RCxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2RUFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ29DO0FBQ3BDO0FBQ0EsVUFBVSx1Q0FB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QUFDbUI7QUFDZjtBQUNoRCxzQkFBc0IsMkRBQTJEO0FBQ2pGLGdCQUFnQixnRUFBUztBQUN6QixVQUFVLGNBQWM7QUFDeEIsbUJBQW1CLDhDQUFRO0FBQzNCO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUksVUFBVSx5REFBeUQsc0RBQUksMEJBQTBCLHNDQUFzQyxvQkFBb0Isc0RBQUksd0JBQXdCLHdEQUF3RCxHQUFHO0FBQy9ROztBQUVBO0FBQ3dHO0FBQzRCO0FBeUJsSSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vcmVhY3Qtc2RrL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9QaGFudG9tUHJvdmlkZXIudHN4XG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTgsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1LCB1c2VNZW1vIGFzIHVzZU1lbW8zLCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEJyb3dzZXJTREsgfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1zZGtcIjtcbmltcG9ydCB7IG1lcmdlVGhlbWUsIGRhcmtUaGVtZSwgVGhlbWVQcm92aWRlciB9IGZyb20gXCJAcGhhbnRvbS93YWxsZXQtc2RrLXVpXCI7XG5cbi8vIHNyYy9QaGFudG9tQ29udGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFBoYW50b21Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gdXNlUGhhbnRvbSgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUGhhbnRvbUNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VQaGFudG9tIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBQaGFudG9tUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8vIHNyYy9Nb2RhbFByb3ZpZGVyLnRzeFxuaW1wb3J0IHsgdXNlU3RhdGUgYXMgdXNlU3RhdGU3LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazUsIHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL01vZGFsQ29udGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE1vZGFsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQyKHZvaWQgMCk7XG5mdW5jdGlvbiB1c2VNb2RhbCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQyKE1vZGFsQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU1vZGFsIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBNb2RhbFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3BlbjogY29udGV4dC5vcGVuTW9kYWwsXG4gICAgY2xvc2U6IGNvbnRleHQuY2xvc2VNb2RhbCxcbiAgICBpc09wZW5lZDogY29udGV4dC5pc01vZGFsT3BlblxuICB9O1xufVxuXG4vLyBzcmMvTW9kYWxQcm92aWRlci50c3hcbmltcG9ydCB7IGlzTW9iaWxlRGV2aWNlIGFzIGlzTW9iaWxlRGV2aWNlMiB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLXNka1wiO1xuaW1wb3J0IHsgTW9kYWwgfSBmcm9tIFwiQHBoYW50b20vd2FsbGV0LXNkay11aVwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9Db25uZWN0TW9kYWxDb250ZW50LnRzeFxuaW1wb3J0IHsgdXNlU3RhdGUgYXMgdXNlU3RhdGU0LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGlzTW9iaWxlRGV2aWNlIH0gZnJvbSBcIkBwaGFudG9tL2Jyb3dzZXItc2RrXCI7XG5pbXBvcnQge1xuICBCdXR0b24sXG4gIExvZ2luV2l0aFBoYW50b21CdXR0b24sXG4gIEljb24gYXMgSWNvbjIsXG4gIEJvdW5kZWRJY29uLFxuICBUZXh0LFxuICBoZXhUb1JnYmEsXG4gIHVzZVRoZW1lIGFzIHVzZVRoZW1lMixcbiAgTW9kYWxIZWFkZXJcbn0gZnJvbSBcIkBwaGFudG9tL3dhbGxldC1zZGstdWlcIjtcbmltcG9ydCB7IGdldFByb3ZpZGVyTmFtZSB9IGZyb20gXCJAcGhhbnRvbS9jb25zdGFudHNcIjtcblxuLy8gc3JjL2hvb2tzL3VzZUlzRXh0ZW5zaW9uSW5zdGFsbGVkLnRzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHdhaXRGb3JQaGFudG9tRXh0ZW5zaW9uIH0gZnJvbSBcIkBwaGFudG9tL2Jyb3dzZXItc2RrXCI7XG5mdW5jdGlvbiB1c2VJc0V4dGVuc2lvbkluc3RhbGxlZCgpIHtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaXNJbnN0YWxsZWQsIHNldElzSW5zdGFsbGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCBjaGVja0V4dGVuc2lvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2FpdEZvclBoYW50b21FeHRlbnNpb24oM2UzKTtcbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgIHNldElzSW5zdGFsbGVkKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJc0luc3RhbGxlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjaGVja0V4dGVuc2lvbigpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB7IGlzTG9hZGluZywgaXNJbnN0YWxsZWQgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZUlzUGhhbnRvbUxvZ2luQXZhaWxhYmxlLnRzXG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBpc1BoYW50b21Mb2dpbkF2YWlsYWJsZSB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLXNka1wiO1xuZnVuY3Rpb24gdXNlSXNQaGFudG9tTG9naW5BdmFpbGFibGUoKSB7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSBSZWFjdDIudXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0F2YWlsYWJsZSwgc2V0SXNBdmFpbGFibGVdID0gUmVhY3QyLnVzZVN0YXRlKGZhbHNlKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgY29uc3QgY2hlY2tQaGFudG9tTG9naW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzUGhhbnRvbUxvZ2luQXZhaWxhYmxlKDNlMyk7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRJc0F2YWlsYWJsZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0SXNBdmFpbGFibGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tQaGFudG9tTG9naW4oKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4geyBpc0xvYWRpbmcsIGlzQXZhaWxhYmxlIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2VDb25uZWN0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ29ubmVjdCgpIHtcbiAgY29uc3QgeyBzZGssIGlzQ29ubmVjdGluZywgaXNMb2FkaW5nLCBlcnJvcnMgfSA9IHVzZVBoYW50b20oKTtcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIXNkaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTREsgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2RrLmNvbm5lY3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbm5lY3RpbmcgdG8gUGhhbnRvbTpcIiwgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3Nka11cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0LFxuICAgIGlzQ29ubmVjdGluZyxcbiAgICBpc0xvYWRpbmcsXG4gICAgZXJyb3I6IGVycm9ycy5jb25uZWN0XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2VEaXNjb3ZlcmVkV2FsbGV0cy50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VEaXNjb3ZlcmVkV2FsbGV0cygpIHtcbiAgY29uc3QgeyBzZGsgfSA9IHVzZVBoYW50b20oKTtcbiAgY29uc3QgW3dhbGxldHMsIHNldFdhbGxldHNdID0gdXNlU3RhdGUzKFtdKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlMyh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTMobnVsbCk7XG4gIGNvbnN0IHJlZmV0Y2ggPSB1c2VDYWxsYmFjazIoYXN5bmMgKCkgPT4ge1xuICAgIGlmICghc2RrKSB7XG4gICAgICBzZXRXYWxsZXRzKFtdKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgY29uc3QgaW5pdGlhbFdhbGxldHMgPSBzZGsuZ2V0RGlzY292ZXJlZFdhbGxldHMoKTtcbiAgICAgIGlmIChpbml0aWFsV2FsbGV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFdhbGxldHMoaW5pdGlhbFdhbGxldHMpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgc2RrLmRpc2NvdmVyV2FsbGV0cygpO1xuICAgICAgICBjb25zdCBkaXNjb3ZlcmVkV2FsbGV0cyA9IHNkay5nZXREaXNjb3ZlcmVkV2FsbGV0cygpO1xuICAgICAgICBzZXRXYWxsZXRzKGRpc2NvdmVyZWRXYWxsZXRzKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yMiA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGRpc2NvdmVyZWQgd2FsbGV0c1wiKTtcbiAgICAgIHNldEVycm9yKGVycm9yMik7XG4gICAgICBzZXRXYWxsZXRzKFtdKTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbc2RrXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHJlZmV0Y2goKTtcbiAgfSwgW3JlZmV0Y2hdKTtcbiAgcmV0dXJuIHtcbiAgICB3YWxsZXRzLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZldGNoXG4gIH07XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0NoYWluSWNvbi50c3hcbmltcG9ydCB7IEljb24sIHVzZVRoZW1lIH0gZnJvbSBcIkBwaGFudG9tL3dhbGxldC1zZGstdWlcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEljb25XcmFwcGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwic3BhblwiLFxuICAgIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWZsZXhcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5hdXgsXG4gICAgICAgIGNvbG9yOiB0aGVtZS50ZXh0LFxuICAgICAgICBwYWRkaW5nOiBcIjJweFwiXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW5cbiAgICB9XG4gICk7XG59O1xuZnVuY3Rpb24gQ2hhaW5JY29uKHsgYWRkcmVzc1R5cGUsIHNpemUgPSA4IH0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCB0eXBlID0gYWRkcmVzc1R5cGUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHR5cGUuaW5jbHVkZXMoXCJzb2xhbmFcIikpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uV3JhcHBlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7IHR5cGU6IFwic29sYW5hXCIsIHNpemUsIGNvbG9yOiB0aGVtZS50ZXh0IH0pIH0pO1xuICB9XG4gIGlmICh0eXBlLmluY2x1ZGVzKFwiZXRoZXJldW1cIikgfHwgdHlwZS5pbmNsdWRlcyhcImV2bVwiKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEljb25XcmFwcGVyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEljb24sIHsgdHlwZTogXCJldGhlcmV1bVwiLCBzaXplLCBjb2xvcjogdGhlbWUudGV4dCB9KSB9KTtcbiAgfVxuICBpZiAodHlwZS5pbmNsdWRlcyhcImJpdGNvaW5cIikpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJY29uV3JhcHBlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChJY29uLCB7IHR5cGU6IFwiYml0Y29pblwiLCBzaXplLCBjb2xvcjogdGhlbWUudGV4dCB9KSB9KTtcbiAgfVxuICBpZiAodHlwZS5pbmNsdWRlcyhcInN1aVwiKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEljb25XcmFwcGVyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEljb24sIHsgdHlwZTogXCJzdWlcIiwgc2l6ZSwgY29sb3I6IHRoZW1lLnRleHQgfSkgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJzcGFuXCIsXG4gICAge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtZmxleFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmF1eCxcbiAgICAgICAgY29sb3I6IHRoZW1lLnRleHQsXG4gICAgICAgIGZvbnRTaXplOiBcIjZweFwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgbGluZUhlaWdodDogXCIxXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4XCJcbiAgICAgIH0sXG4gICAgICB0aXRsZTogYWRkcmVzc1R5cGUsXG4gICAgICBjaGlsZHJlbjogYWRkcmVzc1R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKClcbiAgICB9XG4gICk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0Nvbm5lY3RNb2RhbENvbnRlbnQudHN4XG5pbXBvcnQgeyBGcmFnbWVudCwganN4IGFzIGpzeDIsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIENvbm5lY3RNb2RhbENvbnRlbnQoe1xuICBhcHBJY29uLFxuICBhcHBOYW1lID0gXCJBcHAgTmFtZVwiLFxuICBvbkNsb3NlLFxuICBoaWRlQ2xvc2VCdXR0b24gPSBmYWxzZVxufSkge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lMigpO1xuICBjb25zdCB7IGlzTG9hZGluZywgYWxsb3dlZFByb3ZpZGVycyB9ID0gdXNlUGhhbnRvbSgpO1xuICBjb25zdCBiYXNlQ29ubmVjdCA9IHVzZUNvbm5lY3QoKTtcbiAgY29uc3QgaXNFeHRlbnNpb25JbnN0YWxsZWQgPSB1c2VJc0V4dGVuc2lvbkluc3RhbGxlZCgpO1xuICBjb25zdCBpc1BoYW50b21Mb2dpbkF2YWlsYWJsZTIgPSB1c2VJc1BoYW50b21Mb2dpbkF2YWlsYWJsZSgpO1xuICBjb25zdCBpc01vYmlsZSA9IHVzZU1lbW8oKCkgPT4gaXNNb2JpbGVEZXZpY2UoKSwgW10pO1xuICBjb25zdCB7IHdhbGxldHM6IGRpc2NvdmVyZWRXYWxsZXRzIH0gPSB1c2VEaXNjb3ZlcmVkV2FsbGV0cygpO1xuICBjb25zdCBbaXNDb25uZWN0aW5nLCBzZXRJc0Nvbm5lY3RpbmddID0gdXNlU3RhdGU0KGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTQobnVsbCk7XG4gIGNvbnN0IFtwcm92aWRlclR5cGUsIHNldFByb3ZpZGVyVHlwZV0gPSB1c2VTdGF0ZTQobnVsbCk7XG4gIGNvbnN0IFtzaG93T3RoZXJXYWxsZXRzLCBzZXRTaG93T3RoZXJXYWxsZXRzXSA9IHVzZVN0YXRlNChmYWxzZSk7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldElkLCBzZXRTZWxlY3RlZFdhbGxldElkXSA9IHVzZVN0YXRlNChudWxsKTtcbiAgY29uc3QgaXNDb25uZWN0aW5nU3RhdGUgPSBiYXNlQ29ubmVjdC5pc0Nvbm5lY3RpbmcgfHwgaXNDb25uZWN0aW5nO1xuICBjb25zdCBlcnJvclN0YXRlID0gYmFzZUNvbm5lY3QuZXJyb3IgPyBiYXNlQ29ubmVjdC5lcnJvci5tZXNzYWdlIDogZXJyb3I7XG4gIGNvbnN0IHNob3dEaXZpZGVyID0gIShhbGxvd2VkUHJvdmlkZXJzLmxlbmd0aCA9PT0gMSAmJiBhbGxvd2VkUHJvdmlkZXJzLmluY2x1ZGVzKFwiaW5qZWN0ZWRcIikpO1xuICBjb25zdCBpc0luamVjdGVkT25seSA9IGFsbG93ZWRQcm92aWRlcnMubGVuZ3RoID09PSAxICYmIGFsbG93ZWRQcm92aWRlcnMuaW5jbHVkZXMoXCJpbmplY3RlZFwiKTtcbiAgY29uc3Qgc2hvdWxkU2hvd090aGVyV2FsbGV0c0J1dHRvbiA9ICFpc0luamVjdGVkT25seSAmJiBkaXNjb3ZlcmVkV2FsbGV0cy5sZW5ndGggPiAyO1xuICBjb25zdCB3YWxsZXRzVG9TaG93SW5saW5lID0gc2hvdWxkU2hvd090aGVyV2FsbGV0c0J1dHRvbiA/IFtdIDogZGlzY292ZXJlZFdhbGxldHM7XG4gIGNvbnN0IGNvbm5lY3RXaXRoQXV0aFByb3ZpZGVyID0gdXNlQ2FsbGJhY2szKFxuICAgIGFzeW5jIChwcm92aWRlciwgd2FsbGV0SWQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzQ29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHNldFByb3ZpZGVyVHlwZShwcm92aWRlcik7XG4gICAgICAgIHNldFNlbGVjdGVkV2FsbGV0SWQod2FsbGV0SWQgfHwgbnVsbCk7XG4gICAgICAgIGF3YWl0IGJhc2VDb25uZWN0LmNvbm5lY3QoeyBwcm92aWRlciwgd2FsbGV0SWQgfSk7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBkaXNjb3ZlcmVkV2FsbGV0cy5maW5kKCh3KSA9PiB3LmlkID09PSB3YWxsZXRJZCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHdhbGxldD8ubmFtZSB8fCBnZXRQcm92aWRlck5hbWUocHJvdmlkZXIpO1xuICAgICAgICBzZXRFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgdG8gJHtwcm92aWRlck5hbWV9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICBzZXRQcm92aWRlclR5cGUobnVsbCk7XG4gICAgICAgIHNldFNlbGVjdGVkV2FsbGV0SWQobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYmFzZUNvbm5lY3QsIGRpc2NvdmVyZWRXYWxsZXRzLCBvbkNsb3NlXVxuICApO1xuICBjb25zdCBjb25uZWN0V2l0aFdhbGxldCA9IHVzZUNhbGxiYWNrMyhcbiAgICBhc3luYyAod2FsbGV0KSA9PiB7XG4gICAgICBhd2FpdCBjb25uZWN0V2l0aEF1dGhQcm92aWRlcihcImluamVjdGVkXCIsIHdhbGxldC5pZCk7XG4gICAgfSxcbiAgICBbY29ubmVjdFdpdGhBdXRoUHJvdmlkZXJdXG4gICk7XG4gIGNvbnN0IGNvbm5lY3RXaXRoRGVlcGxpbmsgPSB1c2VDYWxsYmFjazMoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRJc0Nvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIHNldFByb3ZpZGVyVHlwZShcImRlZXBsaW5rXCIpO1xuICAgICAgYXdhaXQgYmFzZUNvbm5lY3QuY29ubmVjdCh7IHByb3ZpZGVyOiBcImRlZXBsaW5rXCIgfSk7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvcjIgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yMi5tZXNzYWdlIDogXCJGYWlsZWQgdG8gb3BlbiBkZWVwbGlua1wiO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgIHNldFByb3ZpZGVyVHlwZShudWxsKTtcbiAgICB9XG4gIH0sIFtiYXNlQ29ubmVjdCwgb25DbG9zZV0pO1xuICBjb25zdCBhcHBJY29uU3R5bGUgPSB7XG4gICAgd2lkdGg6IFwiNTZweFwiLFxuICAgIGhlaWdodDogXCI1NnB4XCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICBvYmplY3RGaXQ6IFwiY292ZXJcIixcbiAgICBtYXJnaW5Cb3R0b206IFwiMTJweFwiXG4gIH07XG4gIGNvbnN0IGNvbm5lY3RDb250ZW50Q29udGFpbmVyU3R5bGUgPSB7XG4gICAgdHJhbnNpdGlvbjogXCJvcGFjaXR5IDAuMTVzIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMC4xNXMgZWFzZS1pbi1vdXRcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgZ2FwOiBcIjEycHhcIixcbiAgICBwYWRkaW5nOiBcIjAgMzJweFwiXG4gIH07XG4gIGNvbnN0IG90aGVyV2FsbGV0c0NvbnRhaW5lclN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBnYXA6IFwiMTJweFwiLFxuICAgIG1heEhlaWdodDogXCI0ODBweFwiLFxuICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgcGFkZGluZzogXCIwIDMycHggMzJweCAzMnB4XCIsXG4gICAgdHJhbnNpdGlvbjogXCJvcGFjaXR5IDAuMTVzIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMC4xNXMgZWFzZS1pbi1vdXRcIlxuICB9O1xuICBjb25zdCBkaXZpZGVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgbWFyZ2luOiBcIjEycHggMFwiLFxuICAgIC4uLnRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbixcbiAgICBjb2xvcjogdGhlbWUuc2Vjb25kYXJ5LFxuICAgIHRleHRUcmFuc2Zvcm06IFwidXBwZXJjYXNlXCJcbiAgfTtcbiAgY29uc3QgZGl2aWRlckxpbmVTdHlsZSA9IHtcbiAgICBmbGV4OiAxLFxuICAgIGhlaWdodDogXCIxcHhcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGhleFRvUmdiYSh0aGVtZS5zZWNvbmRhcnksIDAuMSlcbiAgfTtcbiAgY29uc3QgZGl2aWRlclRleHRTdHlsZSA9IHtcbiAgICBwYWRkaW5nOiBcIjAgMTJweFwiXG4gIH07XG4gIGNvbnN0IGVycm9yU3R5bGUgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMjIwLCA1MywgNjksIDAuMSlcIixcbiAgICBjb2xvcjogXCIjZmY2YjZiXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZ2JhKDIyMCwgNTMsIDY5LCAwLjMpXCIsXG4gICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5ib3JkZXJSYWRpdXMsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBwYWRkaW5nOiBcIjEycHhcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgZm9udFNpemU6IFwiMTRweFwiXG4gIH07XG4gIGNvbnN0IGxvYWRpbmdDb250YWluZXJTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgcGFkZGluZzogXCIyNHB4XCIsXG4gICAgZ2FwOiBcIjEycHhcIlxuICB9O1xuICBjb25zdCBzcGlubmVyU3R5bGUgPSB7XG4gICAgd2lkdGg6IFwiNDBweFwiLFxuICAgIGhlaWdodDogXCI0MHB4XCIsXG4gICAgYm9yZGVyOiBgM3B4IHNvbGlkICR7dGhlbWUuc2Vjb25kYXJ5fWAsXG4gICAgYm9yZGVyVG9wOiBgM3B4IHNvbGlkICR7dGhlbWUuYnJhbmR9YCxcbiAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCIsXG4gICAgYW5pbWF0aW9uOiBcInNwaW4gMXMgbGluZWFyIGluZmluaXRlXCJcbiAgfTtcbiAgY29uc3Qgd2FsbGV0SWNvblN0eWxlID0ge1xuICAgIHdpZHRoOiBcIjMycHhcIixcbiAgICBoZWlnaHQ6IFwiMzJweFwiLFxuICAgIGJvcmRlclJhZGl1czogXCI4cHhcIixcbiAgICBvYmplY3RGaXQ6IFwiY292ZXJcIlxuICB9O1xuICBjb25zdCB3YWxsZXRCdXR0b25Db250ZW50U3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgZ2FwOiBcIjhweFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIlxuICB9O1xuICBjb25zdCB3YWxsZXRCdXR0b25MZWZ0U3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBnYXA6IFwiOHB4XCIsXG4gICAgZmxleDogMVxuICB9O1xuICBjb25zdCB3YWxsZXROYW1lQ29udGFpbmVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBnYXA6IFwiNHB4XCIsXG4gICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0XCJcbiAgfTtcbiAgY29uc3QgY2hhaW5JbmRpY2F0b3JzU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBnYXA6IFwiNHB4XCJcbiAgfTtcbiAgY29uc3Qgd2FsbGV0QnV0dG9uUmlnaHRTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGdhcDogXCI4cHhcIixcbiAgICBjb2xvcjogdGhlbWUuc2Vjb25kYXJ5XG4gIH07XG4gIGNvbnN0IGZvb3RlclN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIHBhZGRpbmc6IFwiMTZweFwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgZ2FwOiBcIjRweFwiLFxuICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgcmdiYSgxNTIsIDE1MSwgMTU2LCAwLjEwKVwiLFxuICAgIC4uLnRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbixcbiAgICBjb2xvcjogdGhlbWUuc2Vjb25kYXJ5XG4gIH07XG4gIGNvbnN0IGNvbnRlbnRXcmFwcGVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgZ2FwOiBcIjI0cHhcIlxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBzdHlsZTogY29udGVudFdyYXBwZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInN0eWxlXCIsIHsgY2hpbGRyZW46IGBcbiAgICAgICAgICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAgICAgICAgICAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIGAgfSksXG4gICAgaXNMb2FkaW5nIHx8IGJhc2VDb25uZWN0LmlzQ29ubmVjdGluZyA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgc3R5bGU6IGxvYWRpbmdDb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHsgc3R5bGU6IHNwaW5uZXJTdHlsZSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFRleHQsIHsgdmFyaWFudDogXCJsYWJlbFwiLCBjb2xvcjogdGhlbWUuc2Vjb25kYXJ5LCBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCIgfSlcbiAgICBdIH0pIDogc2hvd090aGVyV2FsbGV0cyA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgICAgTW9kYWxIZWFkZXIsXG4gICAgICAgIHtcbiAgICAgICAgICBnb0JhY2s6IHRydWUsXG4gICAgICAgICAgb25Hb0JhY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICAgICAgc2V0U2hvd090aGVyV2FsbGV0cyhmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZTogXCJPdGhlciBXYWxsZXRzXCIsXG4gICAgICAgICAgb25DbG9zZSxcbiAgICAgICAgICBoaWRlQ2xvc2VCdXR0b25cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgc3R5bGU6IG90aGVyV2FsbGV0c0NvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICBlcnJvclN0YXRlICYmIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHsgc3R5bGU6IGVycm9yU3R5bGUsIGNoaWxkcmVuOiBlcnJvclN0YXRlIH0pLFxuICAgICAgICBkaXNjb3ZlcmVkV2FsbGV0cy5tYXAoKHdhbGxldCkgPT4gLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGNvbm5lY3RXaXRoV2FsbGV0KHdhbGxldCksXG4gICAgICAgICAgICBkaXNhYmxlZDogaXNDb25uZWN0aW5nU3RhdGUsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGlzQ29ubmVjdGluZ1N0YXRlICYmIHByb3ZpZGVyVHlwZSA9PT0gXCJpbmplY3RlZFwiICYmIHNlbGVjdGVkV2FsbGV0SWQgPT09IHdhbGxldC5pZCxcbiAgICAgICAgICAgIGZ1bGxXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uQ29udGVudFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uTGVmdFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIHdhbGxldC5pZCA9PT0gXCJwaGFudG9tXCIgPyAvKiBAX19QVVJFX18gKi8ganN4MihCb3VuZGVkSWNvbiwgeyB0eXBlOiBcInBoYW50b21cIiwgc2l6ZTogMjAsIGJhY2tncm91bmQ6IFwiI2FiYTBmMlwiLCBjb2xvcjogXCJ3aGl0ZVwiIH0pIDogd2FsbGV0Lmljb24gPyAvKiBAX19QVVJFX18gKi8ganN4MihcImltZ1wiLCB7IHNyYzogd2FsbGV0Lmljb24sIGFsdDogd2FsbGV0Lm5hbWUsIHN0eWxlOiB3YWxsZXRJY29uU3R5bGUgfSkgOiAvKiBAX19QVVJFX18gKi8ganN4MihCb3VuZGVkSWNvbiwgeyB0eXBlOiBcIndhbGxldFwiLCBzaXplOiAyMCwgYmFja2dyb3VuZDogdGhlbWUuYXV4LCBjb2xvcjogdGhlbWUudGV4dCB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0TmFtZUNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoVGV4dCwgeyB2YXJpYW50OiBcImNhcHRpb25Cb2xkXCIsIGNoaWxkcmVuOiB3YWxsZXQubmFtZSB9KSB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uUmlnaHRTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICB3YWxsZXQuYWRkcmVzc1R5cGVzICYmIHdhbGxldC5hZGRyZXNzVHlwZXMubGVuZ3RoID4gMCAmJiAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogY2hhaW5JbmRpY2F0b3JzU3R5bGUsIGNoaWxkcmVuOiB3YWxsZXQuYWRkcmVzc1R5cGVzLm1hcCgoYWRkcmVzc1R5cGUpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwic3BhblwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihDaGFpbkljb24sIHsgYWRkcmVzc1R5cGUsIHNpemU6IDggfSkgfSwgYCR7d2FsbGV0LmlkfS1jaGFpbi0ke2FkZHJlc3NUeXBlfWApKSB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihJY29uMiwgeyB0eXBlOiBcImNoZXZyb24tcmlnaHRcIiwgc2l6ZTogMTYsIGNvbG9yOiB0aGVtZS5zZWNvbmRhcnkgfSlcbiAgICAgICAgICAgICAgXSB9KVxuICAgICAgICAgICAgXSB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2FsbGV0LmlkXG4gICAgICAgICkpXG4gICAgICBdIH0pXG4gICAgXSB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MihNb2RhbEhlYWRlciwgeyB0aXRsZTogXCJMb2dpbiBvciBTaWduIFVwXCIsIG9uQ2xvc2UsIGhpZGVDbG9zZUJ1dHRvbiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgc3R5bGU6IGNvbm5lY3RDb250ZW50Q29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgICAgIGFwcEljb24gJiYgLyogQF9fUFVSRV9fICovIGpzeDIoXCJpbWdcIiwgeyBzcmM6IGFwcEljb24sIGFsdDogYXBwTmFtZSwgc3R5bGU6IGFwcEljb25TdHlsZSB9KSxcbiAgICAgICAgZXJyb3JTdGF0ZSAmJiAvKiBAX19QVVJFX18gKi8ganN4MihcImRpdlwiLCB7IHN0eWxlOiBlcnJvclN0eWxlLCBjaGlsZHJlbjogZXJyb3JTdGF0ZSB9KSxcbiAgICAgICAgaXNNb2JpbGUgJiYgIWlzRXh0ZW5zaW9uSW5zdGFsbGVkLmlzSW5zdGFsbGVkICYmIGFsbG93ZWRQcm92aWRlcnMuaW5jbHVkZXMoXCJkZWVwbGlua1wiKSAmJiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgICAgICBMb2dpbldpdGhQaGFudG9tQnV0dG9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRlc3RJZDogXCJkZWVwbGluay1idXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGNvbm5lY3RXaXRoRGVlcGxpbmssXG4gICAgICAgICAgICBkaXNhYmxlZDogaXNDb25uZWN0aW5nU3RhdGUsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGlzQ29ubmVjdGluZ1N0YXRlICYmIHByb3ZpZGVyVHlwZSA9PT0gXCJkZWVwbGlua1wiLFxuICAgICAgICAgICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IGlzQ29ubmVjdGluZyAmJiBwcm92aWRlclR5cGUgPT09IFwiZGVlcGxpbmtcIiA/IFwiT3BlbmluZyBQaGFudG9tLi4uXCIgOiBcIk9wZW4gaW4gUGhhbnRvbSBBcHBcIlxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgIWlzTW9iaWxlICYmIGFsbG93ZWRQcm92aWRlcnMuaW5jbHVkZXMoXCJwaGFudG9tXCIpICYmIGlzUGhhbnRvbUxvZ2luQXZhaWxhYmxlMi5pc0F2YWlsYWJsZSAmJiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgICAgICBMb2dpbldpdGhQaGFudG9tQnV0dG9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRlc3RJZDogXCJsb2dpbi13aXRoLXBoYW50b20tYnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBjb25uZWN0V2l0aEF1dGhQcm92aWRlcihcInBoYW50b21cIiksXG4gICAgICAgICAgICBkaXNhYmxlZDogaXNDb25uZWN0aW5nU3RhdGUsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IGlzQ29ubmVjdGluZ1N0YXRlICYmIHByb3ZpZGVyVHlwZSA9PT0gXCJwaGFudG9tXCJcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIGFsbG93ZWRQcm92aWRlcnMuaW5jbHVkZXMoXCJnb29nbGVcIikgJiYgIShpc01vYmlsZSAmJiBpc0V4dGVuc2lvbkluc3RhbGxlZC5pc0luc3RhbGxlZCkgJiYgLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IGNvbm5lY3RXaXRoQXV0aFByb3ZpZGVyKFwiZ29vZ2xlXCIpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGlzQ29ubmVjdGluZ1N0YXRlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBpc0Nvbm5lY3RpbmdTdGF0ZSAmJiBwcm92aWRlclR5cGUgPT09IFwiZ29vZ2xlXCIsXG4gICAgICAgICAgICBmdWxsV2lkdGg6IHRydWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHdhbGxldEJ1dHRvbkNvbnRlbnRTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHdhbGxldEJ1dHRvbkxlZnRTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihJY29uMiwgeyB0eXBlOiBcImdvb2dsZVwiLCBzaXplOiAyMCB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihUZXh0LCB7IHZhcmlhbnQ6IFwiY2FwdGlvbkJvbGRcIiwgY2hpbGRyZW46IFwiQ29udGludWUgd2l0aCBHb29nbGVcIiB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uUmlnaHRTdHlsZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEljb24yLCB7IHR5cGU6IFwiY2hldnJvbi1yaWdodFwiLCBzaXplOiAxNiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSB9KSB9KVxuICAgICAgICAgICAgXSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgYWxsb3dlZFByb3ZpZGVycy5pbmNsdWRlcyhcImFwcGxlXCIpICYmIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBjb25uZWN0V2l0aEF1dGhQcm92aWRlcihcImFwcGxlXCIpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGlzQ29ubmVjdGluZ1N0YXRlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBpc0Nvbm5lY3RpbmdTdGF0ZSAmJiBwcm92aWRlclR5cGUgPT09IFwiYXBwbGVcIixcbiAgICAgICAgICAgIGZ1bGxXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uQ29udGVudFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uTGVmdFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKEljb24yLCB7IHR5cGU6IFwiYXBwbGVcIiwgc2l6ZTogMjAgfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoVGV4dCwgeyB2YXJpYW50OiBcImNhcHRpb25Cb2xkXCIsIGNoaWxkcmVuOiBcIkNvbnRpbnVlIHdpdGggQXBwbGVcIiB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uUmlnaHRTdHlsZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEljb24yLCB7IHR5cGU6IFwiY2hldnJvbi1yaWdodFwiLCBzaXplOiAxNiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSB9KSB9KVxuICAgICAgICAgICAgXSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgYWxsb3dlZFByb3ZpZGVycy5pbmNsdWRlcyhcImluamVjdGVkXCIpICYmIChpc0V4dGVuc2lvbkluc3RhbGxlZC5pc0luc3RhbGxlZCB8fCBkaXNjb3ZlcmVkV2FsbGV0cy5sZW5ndGggPiAwKSAmJiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIHNob3dEaXZpZGVyICYmIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgc3R5bGU6IGRpdmlkZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHsgc3R5bGU6IGRpdmlkZXJMaW5lU3R5bGUgfSksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogZGl2aWRlclRleHRTdHlsZSwgY2hpbGRyZW46IFwiT1JcIiB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHsgc3R5bGU6IGRpdmlkZXJMaW5lU3R5bGUgfSlcbiAgICAgICAgICBdIH0pLFxuICAgICAgICAgIHdhbGxldHNUb1Nob3dJbmxpbmUubWFwKCh3YWxsZXQpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgICAgICAgQnV0dG9uLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBjb25uZWN0V2l0aFdhbGxldCh3YWxsZXQpLFxuICAgICAgICAgICAgICBkaXNhYmxlZDogaXNDb25uZWN0aW5nU3RhdGUsXG4gICAgICAgICAgICAgIGlzTG9hZGluZzogaXNDb25uZWN0aW5nU3RhdGUgJiYgcHJvdmlkZXJUeXBlID09PSBcImluamVjdGVkXCIgJiYgc2VsZWN0ZWRXYWxsZXRJZCA9PT0gd2FsbGV0LmlkLFxuICAgICAgICAgICAgICBmdWxsV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0QnV0dG9uQ29udGVudFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IHN0eWxlOiB3YWxsZXRCdXR0b25MZWZ0U3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICB3YWxsZXQuaWQgPT09IFwicGhhbnRvbVwiID8gLyogQF9fUFVSRV9fICovIGpzeDIoQm91bmRlZEljb24sIHsgdHlwZTogXCJwaGFudG9tXCIsIHNpemU6IDIwLCBiYWNrZ3JvdW5kOiBcIiNhYmEwZjJcIiwgY29sb3I6IFwid2hpdGVcIiB9KSA6IHdhbGxldC5pY29uID8gLyogQF9fUFVSRV9fICovIGpzeDIoXCJpbWdcIiwgeyBzcmM6IHdhbGxldC5pY29uLCBhbHQ6IHdhbGxldC5uYW1lLCBzdHlsZTogd2FsbGV0SWNvblN0eWxlIH0pIDogLyogQF9fUFVSRV9fICovIGpzeDIoQm91bmRlZEljb24sIHsgdHlwZTogXCJ3YWxsZXRcIiwgc2l6ZTogMTAsIGJhY2tncm91bmQ6IHRoZW1lLmF1eCwgY29sb3I6IHRoZW1lLnRleHQgfSksXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogd2FsbGV0TmFtZUNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoVGV4dCwgeyB2YXJpYW50OiBcImNhcHRpb25Cb2xkXCIsIGNoaWxkcmVuOiB3YWxsZXQubmFtZSB9KSB9KVxuICAgICAgICAgICAgICAgIF0gfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHdhbGxldEJ1dHRvblJpZ2h0U3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICB3YWxsZXQuYWRkcmVzc1R5cGVzICYmIHdhbGxldC5hZGRyZXNzVHlwZXMubGVuZ3RoID4gMCAmJiAvKiBAX19QVVJFX18gKi8ganN4MihcInNwYW5cIiwgeyBzdHlsZTogY2hhaW5JbmRpY2F0b3JzU3R5bGUsIGNoaWxkcmVuOiB3YWxsZXQuYWRkcmVzc1R5cGVzLm1hcCgoYWRkcmVzc1R5cGUpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwic3BhblwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihDaGFpbkljb24sIHsgYWRkcmVzc1R5cGUsIHNpemU6IDggfSkgfSwgYCR7d2FsbGV0LmlkfS1jaGFpbi0ke2FkZHJlc3NUeXBlfWApKSB9KSxcbiAgICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKEljb24yLCB7IHR5cGU6IFwiY2hldnJvbi1yaWdodFwiLCBzaXplOiAxNiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSB9KVxuICAgICAgICAgICAgICAgIF0gfSlcbiAgICAgICAgICAgICAgXSB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhbGxldC5pZFxuICAgICAgICAgICkpLFxuICAgICAgICAgIHNob3VsZFNob3dPdGhlcldhbGxldHNCdXR0b24gJiYgLyogQF9fUFVSRV9fICovIGpzeDIoQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldFNob3dPdGhlcldhbGxldHModHJ1ZSksIGRpc2FibGVkOiBpc0Nvbm5lY3RpbmdTdGF0ZSwgZnVsbFdpZHRoOiB0cnVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgc3R5bGU6IHdhbGxldEJ1dHRvbkNvbnRlbnRTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IHN0eWxlOiB3YWxsZXRCdXR0b25MZWZ0U3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKEJvdW5kZWRJY29uLCB7IHR5cGU6IFwid2FsbGV0XCIsIHNpemU6IDIwLCBiYWNrZ3JvdW5kOiB0aGVtZS5hdXgsIGNvbG9yOiB0aGVtZS50ZXh0IH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihUZXh0LCB7IHZhcmlhbnQ6IFwiY2FwdGlvbkJvbGRcIiwgY2hpbGRyZW46IFwiT3RoZXIgV2FsbGV0c1wiIH0pXG4gICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXCJzcGFuXCIsIHsgc3R5bGU6IHdhbGxldEJ1dHRvblJpZ2h0U3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihJY29uMiwgeyB0eXBlOiBcImNoZXZyb24tcmlnaHRcIiwgc2l6ZTogMTYsIGNvbG9yOiB0aGVtZS5zZWNvbmRhcnkgfSkgfSlcbiAgICAgICAgICBdIH0pIH0pXG4gICAgICAgIF0gfSlcbiAgICAgIF0gfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IHN0eWxlOiBmb290ZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoVGV4dCwgeyB2YXJpYW50OiBcImxhYmVsXCIsIGNvbG9yOiB0aGVtZS5zZWNvbmRhcnksIGNoaWxkcmVuOiBcIlBvd2VyZWQgYnlcIiB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoSWNvbjIsIHsgdHlwZTogXCJwaGFudG9tXCIsIHNpemU6IDE2IH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihUZXh0LCB7IHZhcmlhbnQ6IFwibGFiZWxcIiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSwgY2hpbGRyZW46IFwiUGhhbnRvbVwiIH0pXG4gICAgICBdIH0pXG4gICAgXSB9KVxuICBdIH0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9Db25uZWN0ZWRNb2RhbENvbnRlbnQudHN4XG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTYsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBCdXR0b24gYXMgQnV0dG9uMiwgVGV4dCBhcyBUZXh0MiwgdXNlVGhlbWUgYXMgdXNlVGhlbWUzLCBNb2RhbEhlYWRlciBhcyBNb2RhbEhlYWRlcjIgfSBmcm9tIFwiQHBoYW50b20vd2FsbGV0LXNkay11aVwiO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzY29ubmVjdC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZURpc2Nvbm5lY3QoKSB7XG4gIGNvbnN0IHsgc2RrIH0gPSB1c2VQaGFudG9tKCk7XG4gIGNvbnN0IFtpc0Rpc2Nvbm5lY3RpbmcsIHNldElzRGlzY29ubmVjdGluZ10gPSB1c2VTdGF0ZTUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlNShudWxsKTtcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrNChhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNESyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICAgIHNldElzRGlzY29ubmVjdGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2RrLmRpc2Nvbm5lY3QoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yMiA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgIHNldEVycm9yKGVycm9yMik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzRGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbc2RrXSk7XG4gIHJldHVybiB7XG4gICAgZGlzY29ubmVjdCxcbiAgICBpc0Rpc2Nvbm5lY3RpbmcsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQ29ubmVjdGVkTW9kYWxDb250ZW50LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMsIGpzeHMgYXMganN4czIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIENvbm5lY3RlZE1vZGFsQ29udGVudCh7IG9uQ2xvc2UsIGhpZGVDbG9zZUJ1dHRvbiA9IGZhbHNlIH0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZTMoKTtcbiAgY29uc3QgeyBhZGRyZXNzZXMgfSA9IHVzZVBoYW50b20oKTtcbiAgY29uc3QgeyBkaXNjb25uZWN0IH0gPSB1c2VEaXNjb25uZWN0KCk7XG4gIGNvbnN0IFtpc0Rpc2Nvbm5lY3RpbmcsIHNldElzRGlzY29ubmVjdGluZ10gPSB1c2VTdGF0ZTYoZmFsc2UpO1xuICBjb25zdCBbZGlzY29ubmVjdEVycm9yLCBzZXREaXNjb25uZWN0RXJyb3JdID0gdXNlU3RhdGU2KG51bGwpO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBzZXREaXNjb25uZWN0RXJyb3IobnVsbCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0SXNEaXNjb25uZWN0aW5nKHRydWUpO1xuICAgICAgc2V0RGlzY29ubmVjdEVycm9yKG51bGwpO1xuICAgICAgYXdhaXQgZGlzY29ubmVjdCgpO1xuICAgICAgb25DbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICBzZXREaXNjb25uZWN0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0Rpc2Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWNjb3VudExpc3RTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGdhcDogXCIxNnB4XCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIG1pbldpZHRoOiAwLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgfTtcbiAgY29uc3QgYWNjb3VudEl0ZW1TdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGdhcDogXCI4cHhcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgbWluV2lkdGg6IDAsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICB9O1xuICBjb25zdCBhZGRyZXNzVGV4dFN0eWxlID0ge1xuICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgd29yZEJyZWFrOiBcImJyZWFrLWFsbFwiLFxuICAgIG92ZXJmbG93V3JhcDogXCJicmVhay13b3JkXCIsXG4gICAgbWluV2lkdGg6IDBcbiAgfTtcbiAgY29uc3QgZXJyb3JDb250YWluZXJTdHlsZSA9IHtcbiAgICBwYWRkaW5nOiBcIjEycHhcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyMjAsIDUzLCA2OSwgMC4xKVwiLFxuICAgIGJvcmRlclJhZGl1czogdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlcjogXCIxcHggc29saWQgcmdiYSgyMjAsIDUzLCA2OSwgMC4zKVwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIG1pbldpZHRoOiAwXG4gIH07XG4gIGNvbnN0IGNvbnRlbnRXcmFwcGVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBnYXA6IFwiMjRweFwiXG4gIH07XG4gIGNvbnN0IGFjY291bnRMaXN0Q29udGFpbmVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGdhcDogXCIxMnB4XCIsXG4gICAgcGFkZGluZzogXCIwIDMycHggMjRweCAzMnB4XCIsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgbWluV2lkdGg6IDBcbiAgfTtcbiAgY29uc3QgZGlzY29ubmVjdEJ1dHRvbkNvbnRhaW5lclN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBnYXA6IFwiMTJweFwiLFxuICAgIHBhZGRpbmc6IFwiMCAzMnB4IDI0cHggMzJweFwiLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIG1pbldpZHRoOiAwXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czIoXCJkaXZcIiwgeyBzdHlsZTogY29udGVudFdyYXBwZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MyhNb2RhbEhlYWRlcjIsIHsgdGl0bGU6IFwiV2FsbGV0XCIsIG9uQ2xvc2UsIGhpZGVDbG9zZUJ1dHRvbiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4czIoXCJkaXZcIiwgeyBzdHlsZTogYWNjb3VudExpc3RDb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtcbiAgICAgIGRpc2Nvbm5lY3RFcnJvciAmJiAvKiBAX19QVVJFX18gKi8ganN4MyhcImRpdlwiLCB7IHN0eWxlOiBlcnJvckNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMoVGV4dDIsIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIGNvbG9yOiB0aGVtZS5lcnJvciwgY2hpbGRyZW46IFwiRmFpbGVkIHRvIGRpc2Nvbm5lY3RcIiB9KSB9KSxcbiAgICAgIGFkZHJlc3NlcyAmJiBhZGRyZXNzZXMubGVuZ3RoID4gMCAmJiAvKiBAX19QVVJFX18gKi8ganN4MyhcImRpdlwiLCB7IHN0eWxlOiBhY2NvdW50TGlzdFN0eWxlLCBjaGlsZHJlbjogYWRkcmVzc2VzLm1hcCgoYWNjb3VudCwgaW5kZXgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcImRpdlwiLCB7IHN0eWxlOiBhY2NvdW50SXRlbVN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MyhUZXh0MiwgeyB2YXJpYW50OiBcImxhYmVsXCIsIGNvbG9yOiB0aGVtZS5zZWNvbmRhcnksIHN0eWxlOiB7IHRleHRUcmFuc2Zvcm06IFwidXBwZXJjYXNlXCIgfSwgY2hpbGRyZW46IGFjY291bnQuYWRkcmVzc1R5cGUgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiZGl2XCIsIHsgc3R5bGU6IGFkZHJlc3NUZXh0U3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhUZXh0MiwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgY2hpbGRyZW46IGFjY291bnQuYWRkcmVzcyB9KSB9KVxuICAgICAgXSB9LCBpbmRleCkpIH0pXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4MyhcImRpdlwiLCB7IHN0eWxlOiBkaXNjb25uZWN0QnV0dG9uQ29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhCdXR0b24yLCB7IG9uQ2xpY2s6IGhhbmRsZURpc2Nvbm5lY3QsIGRpc2FibGVkOiBpc0Rpc2Nvbm5lY3RpbmcsIGlzTG9hZGluZzogaXNEaXNjb25uZWN0aW5nLCBmdWxsV2lkdGg6IHRydWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhUZXh0MiwgeyB2YXJpYW50OiBcImNhcHRpb25Cb2xkXCIsIGNoaWxkcmVuOiBpc0Rpc2Nvbm5lY3RpbmcgPyBcIkRpc2Nvbm5lY3RpbmcuLi5cIiA6IFwiRGlzY29ubmVjdFwiIH0pIH0pIH0pXG4gIF0gfSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1NwZW5kaW5nTGltaXRNb2RhbENvbnRlbnQudHN4XG5pbXBvcnQgeyBUZXh0IGFzIFRleHQzLCBCdXR0b24gYXMgQnV0dG9uMywgdXNlVGhlbWUgYXMgdXNlVGhlbWU0IH0gZnJvbSBcIkBwaGFudG9tL3dhbGxldC1zZGstdWlcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g0LCBqc3hzIGFzIGpzeHMzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBTcGVuZGluZ0xpbWl0TW9kYWxDb250ZW50KHsgb25DbG9zZSB9KSB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWU0KCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czMoXCJkaXZcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBcImZsZXhcIiwgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIiwgZ2FwOiAxNiwgcGFkZGluZzogMzIgfSwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4NChUZXh0MywgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSwgY2hpbGRyZW46IFwiWW91J3ZlIHJlYWNoZWQgdGhlIG1heGltdW0gZGFpbHkgbGltaXQgYWxsb3dlZCB0byBzcGVuZCBieSB0aGlzIGFwcGxpY2F0aW9uLlwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KEJ1dHRvbjMsIHsgZnVsbFdpZHRoOiB0cnVlLCBvbkNsaWNrOiBvbkNsb3NlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDQoVGV4dDMsIHsgdmFyaWFudDogXCJjYXB0aW9uQm9sZFwiLCBjaGlsZHJlbjogXCJDbG9zZVwiIH0pIH0pXG4gIF0gfSk7XG59XG5cbi8vIHNyYy9Nb2RhbFByb3ZpZGVyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUsIGpzeHMgYXMganN4czQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIE1vZGFsUHJvdmlkZXIoeyBjaGlsZHJlbiwgYXBwSWNvbiwgYXBwTmFtZSB9KSB7XG4gIGNvbnN0IHsgaXNDb25uZWN0ZWQsIGVycm9ycywgY2xlYXJFcnJvciB9ID0gdXNlUGhhbnRvbSgpO1xuICBjb25zdCBbaXNNb2RhbE9wZW4sIHNldElzTW9kYWxPcGVuXSA9IHVzZVN0YXRlNyhmYWxzZSk7XG4gIGNvbnN0IGlzTW9iaWxlID0gdXNlTWVtbzIoKCkgPT4gaXNNb2JpbGVEZXZpY2UyKCksIFtdKTtcbiAgY29uc3Qgb3Blbk1vZGFsID0gdXNlQ2FsbGJhY2s1KCgpID0+IHtcbiAgICBzZXRJc01vZGFsT3Blbih0cnVlKTtcbiAgfSwgW10pO1xuICBjb25zdCBjbG9zZU1vZGFsID0gdXNlQ2FsbGJhY2s1KCgpID0+IHtcbiAgICBzZXRJc01vZGFsT3BlbihmYWxzZSk7XG4gICAgY2xlYXJFcnJvcihcInNwZW5kaW5nTGltaXRcIik7XG4gIH0sIFtjbGVhckVycm9yXSk7XG4gIGNvbnN0IGlzU3BlbmRpbmdMaW1pdE9wZW4gPSAhIWVycm9ycy5zcGVuZGluZ0xpbWl0O1xuICBjb25zdCBtb2RhbENvbnRleHRWYWx1ZSA9IHVzZU1lbW8yKFxuICAgICgpID0+ICh7XG4gICAgICBpc01vZGFsT3BlbixcbiAgICAgIG9wZW5Nb2RhbCxcbiAgICAgIGNsb3NlTW9kYWxcbiAgICB9KSxcbiAgICBbaXNNb2RhbE9wZW4sIG9wZW5Nb2RhbCwgY2xvc2VNb2RhbF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzNChNb2RhbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1vZGFsQ29udGV4dFZhbHVlLCBjaGlsZHJlbjogW1xuICAgIGNoaWxkcmVuLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g1KFxuICAgICAgTW9kYWwsXG4gICAgICB7XG4gICAgICAgIGlzVmlzaWJsZTogaXNNb2RhbE9wZW4gfHwgaXNTcGVuZGluZ0xpbWl0T3BlbixcbiAgICAgICAgb25DbG9zZTogY2xvc2VNb2RhbCxcbiAgICAgICAgYXBwSWNvbixcbiAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgaXNNb2JpbGUsXG4gICAgICAgIGNoaWxkcmVuOiBpc1NwZW5kaW5nTGltaXRPcGVuID8gLyogQF9fUFVSRV9fICovIGpzeDUoU3BlbmRpbmdMaW1pdE1vZGFsQ29udGVudCwgeyBvbkNsb3NlOiBjbG9zZU1vZGFsIH0pIDogaXNDb25uZWN0ZWQgPyAvKiBAX19QVVJFX18gKi8ganN4NShDb25uZWN0ZWRNb2RhbENvbnRlbnQsIHsgb25DbG9zZTogY2xvc2VNb2RhbCB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3g1KENvbm5lY3RNb2RhbENvbnRlbnQsIHsgYXBwSWNvbiwgYXBwTmFtZSwgb25DbG9zZTogY2xvc2VNb2RhbCB9KVxuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn1cblxuLy8gc3JjL1BoYW50b21Qcm92aWRlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBQaGFudG9tUHJvdmlkZXIoeyBjaGlsZHJlbiwgY29uZmlnLCBkZWJ1Z0NvbmZpZywgdGhlbWUsIGFwcEljb24sIGFwcE5hbWUgfSkge1xuICBjb25zdCBtZW1vaXplZENvbmZpZyA9IHVzZU1lbW8zKCgpID0+IGNvbmZpZywgW2NvbmZpZ10pO1xuICBjb25zdCByZXNvbHZlZFRoZW1lID0gdXNlTWVtbzMoKCkgPT4gbWVyZ2VUaGVtZSh0aGVtZSB8fCBkYXJrVGhlbWUpLCBbdGhlbWVdKTtcbiAgY29uc3QgW3Nkaywgc2V0U2RrXSA9IHVzZVN0YXRlOChudWxsKTtcbiAgY29uc3QgW2lzQ2xpZW50LCBzZXRJc0NsaWVudF0gPSB1c2VTdGF0ZTgoZmFsc2UpO1xuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlOChmYWxzZSk7XG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZTgoZmFsc2UpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU4KHRydWUpO1xuICBjb25zdCBbZXJyb3JzLCBzZXRFcnJvcnNdID0gdXNlU3RhdGU4KHt9KTtcbiAgY29uc3QgW2FkZHJlc3Nlcywgc2V0QWRkcmVzc2VzXSA9IHVzZVN0YXRlOChbXSk7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlOChudWxsKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgc2V0SXNDbGllbnQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzZGtJbnN0YW5jZSA9IG5ldyBCcm93c2VyU0RLKG1lbW9pemVkQ29uZmlnKTtcbiAgICBzZXRTZGsoc2RrSW5zdGFuY2UpO1xuICB9LCBbaXNDbGllbnQsIG1lbW9pemVkQ29uZmlnXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghc2RrKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZUNvbm5lY3RTdGFydCA9ICgpID0+IHtcbiAgICAgIHNldElzQ29ubmVjdGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9ycygocHJldikgPT4gKHsgLi4ucHJldiwgY29ubmVjdDogdm9pZCAwIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SXNDb25uZWN0ZWQodHJ1ZSk7XG4gICAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgIHNldFVzZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IGFkZHJzID0gYXdhaXQgc2RrLmdldEFkZHJlc3NlcygpO1xuICAgICAgICBzZXRBZGRyZXNzZXMoYWRkcnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb25uZWN0aW5nOlwiLCBlcnIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHNkay5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGlzY29ubmVjdGluZzpcIiwgZXJyMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNvbm5lY3RFcnJvciA9IChlcnJvckRhdGEpID0+IHtcbiAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgICBjb25zdCBpc0F1dG9Db25uZWN0Tm9TZXNzaW9uID0gZXJyb3JEYXRhLnNvdXJjZSA9PT0gXCJhdXRvLWNvbm5lY3RcIiAmJiAoZXJyb3JEYXRhLmVycm9yID09PSBcIk5vIHZhbGlkIHNlc3Npb24gZm91bmRcIiB8fCBlcnJvckRhdGEuZXJyb3IgPT09IFwiTm8gdHJ1c3RlZCBjb25uZWN0aW9ucyBhdmFpbGFibGVcIik7XG4gICAgICBpZiAoaXNBdXRvQ29ubmVjdE5vU2Vzc2lvbikge1xuICAgICAgICBzZXRFcnJvcnMoKHByZXYpID0+ICh7IC4uLnByZXYsIGNvbm5lY3Q6IHZvaWQgMCB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvcnMoKHByZXYpID0+ICh7IC4uLnByZXYsIGNvbm5lY3Q6IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgXCJDb25uZWN0aW9uIGZhaWxlZFwiKSB9KSk7XG4gICAgICB9XG4gICAgICBzZXRBZGRyZXNzZXMoW10pO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9ICgpID0+IHtcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XG4gICAgICBzZXRFcnJvcnMoe30pO1xuICAgICAgc2V0QWRkcmVzc2VzKFtdKTtcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTcGVuZGluZ0xpbWl0UmVhY2hlZCA9ICgpID0+IHtcbiAgICAgIHNldEVycm9ycygocHJldikgPT4gKHsgLi4ucHJldiwgc3BlbmRpbmdMaW1pdDogdHJ1ZSB9KSk7XG4gICAgfTtcbiAgICBzZGsub24oXCJjb25uZWN0X3N0YXJ0XCIsIGhhbmRsZUNvbm5lY3RTdGFydCk7XG4gICAgc2RrLm9uKFwiY29ubmVjdFwiLCBoYW5kbGVDb25uZWN0KTtcbiAgICBzZGsub24oXCJjb25uZWN0X2Vycm9yXCIsIGhhbmRsZUNvbm5lY3RFcnJvcik7XG4gICAgc2RrLm9uKFwiZGlzY29ubmVjdFwiLCBoYW5kbGVEaXNjb25uZWN0KTtcbiAgICBzZGsub24oXCJzcGVuZGluZ19saW1pdF9yZWFjaGVkXCIsIGhhbmRsZVNwZW5kaW5nTGltaXRSZWFjaGVkKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2RrLm9mZihcImNvbm5lY3Rfc3RhcnRcIiwgaGFuZGxlQ29ubmVjdFN0YXJ0KTtcbiAgICAgIHNkay5vZmYoXCJjb25uZWN0XCIsIGhhbmRsZUNvbm5lY3QpO1xuICAgICAgc2RrLm9mZihcImNvbm5lY3RfZXJyb3JcIiwgaGFuZGxlQ29ubmVjdEVycm9yKTtcbiAgICAgIHNkay5vZmYoXCJkaXNjb25uZWN0XCIsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgc2RrLm9mZihcInNwZW5kaW5nX2xpbWl0X3JlYWNoZWRcIiwgaGFuZGxlU3BlbmRpbmdMaW1pdFJlYWNoZWQpO1xuICAgIH07XG4gIH0sIFtzZGtdKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFkZWJ1Z0NvbmZpZyB8fCAhc2RrKVxuICAgICAgcmV0dXJuO1xuICAgIHNkay5jb25maWd1cmVEZWJ1ZyhkZWJ1Z0NvbmZpZyk7XG4gIH0sIFtzZGssIGRlYnVnQ29uZmlnXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIXNkaylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpbml0aWFsaXplID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgc2RrLmF1dG9Db25uZWN0KCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQXV0by1jb25uZWN0IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9LCBbc2RrLCBpc0NsaWVudF0pO1xuICBjb25zdCBjbGVhckVycm9yID0gdXNlQ2FsbGJhY2s2KChrZXkpID0+IHtcbiAgICBzZXRFcnJvcnMoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfTtcbiAgICAgIGRlbGV0ZSBuZXh0W2tleV07XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8zKFxuICAgICgpID0+ICh7XG4gICAgICBzZGssXG4gICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgIGlzQ29ubmVjdGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGVycm9ycyxcbiAgICAgIGFkZHJlc3NlcyxcbiAgICAgIGlzQ2xpZW50LFxuICAgICAgdXNlcixcbiAgICAgIHRoZW1lOiByZXNvbHZlZFRoZW1lLFxuICAgICAgYWxsb3dlZFByb3ZpZGVyczogbWVtb2l6ZWRDb25maWcucHJvdmlkZXJzLFxuICAgICAgY2xlYXJFcnJvclxuICAgIH0pLFxuICAgIFtcbiAgICAgIHNkayxcbiAgICAgIGlzQ29ubmVjdGVkLFxuICAgICAgaXNDb25uZWN0aW5nLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgZXJyb3JzLFxuICAgICAgYWRkcmVzc2VzLFxuICAgICAgaXNDbGllbnQsXG4gICAgICB1c2VyLFxuICAgICAgcmVzb2x2ZWRUaGVtZSxcbiAgICAgIG1lbW9pemVkQ29uZmlnLnByb3ZpZGVycyxcbiAgICAgIGNsZWFyRXJyb3JcbiAgICBdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NihUaGVtZVByb3ZpZGVyLCB7IHRoZW1lOiByZXNvbHZlZFRoZW1lLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDYoUGhhbnRvbUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NihNb2RhbFByb3ZpZGVyLCB7IGFwcEljb24sIGFwcE5hbWUsIGNoaWxkcmVuIH0pIH0pIH0pO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlQWNjb3VudHMudHNcbmZ1bmN0aW9uIHVzZUFjY291bnRzKCkge1xuICBjb25zdCB7IGFkZHJlc3NlcywgaXNDb25uZWN0ZWQgfSA9IHVzZVBoYW50b20oKTtcbiAgcmV0dXJuIGlzQ29ubmVjdGVkID8gYWRkcmVzc2VzIDogbnVsbDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZUF1dG9Db25maXJtLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazcsIHVzZVN0YXRlIGFzIHVzZVN0YXRlOSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUF1dG9Db25maXJtKCkge1xuICBjb25zdCB7IHNkaywgdXNlciB9ID0gdXNlUGhhbnRvbSgpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU5KG51bGwpO1xuICBjb25zdCBbc3VwcG9ydGVkQ2hhaW5zLCBzZXRTdXBwb3J0ZWRDaGFpbnNdID0gdXNlU3RhdGU5KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU5KGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTkobnVsbCk7XG4gIGNvbnN0IGlzSW5qZWN0ZWQgPSB1c2VyPy5hdXRoUHJvdmlkZXIgPT09IFwiaW5qZWN0ZWRcIjtcbiAgY29uc3QgZW5hYmxlID0gdXNlQ2FsbGJhY2s3KFxuICAgIGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgIGlmICghc2RrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNESyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzSW5qZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0by1jb25maXJtIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBpbmplY3RlZCAoZXh0ZW5zaW9uKSBwcm92aWRlcnNcIik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZGsuZW5hYmxlQXV0b0NvbmZpcm0ocGFyYW1zKTtcbiAgICAgICAgc2V0U3RhdHVzKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCIpO1xuICAgICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3NkaywgaXNJbmplY3RlZF1cbiAgKTtcbiAgY29uc3QgZGlzYWJsZSA9IHVzZUNhbGxiYWNrNyhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFzZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNESyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICAgIGlmICghaXNJbmplY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0by1jb25maXJtIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBpbmplY3RlZCAoZXh0ZW5zaW9uKSBwcm92aWRlcnNcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIGF3YWl0IHNkay5kaXNhYmxlQXV0b0NvbmZpcm0oKTtcbiAgICAgIGNvbnN0IG5ld1N0YXR1cyA9IGF3YWl0IHNkay5nZXRBdXRvQ29uZmlybVN0YXR1cygpO1xuICAgICAgc2V0U3RhdHVzKG5ld1N0YXR1cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvcjIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihcIlVua25vd24gZXJyb3Igb2NjdXJyZWRcIik7XG4gICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgICAgdGhyb3cgZXJyb3IyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3NkaywgaXNJbmplY3RlZF0pO1xuICBjb25zdCByZWZldGNoID0gdXNlQ2FsbGJhY2s3KGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXNkayB8fCAhaXNJbmplY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBjb25zdCBbc3RhdHVzUmVzdWx0LCBzdXBwb3J0ZWRSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzZGsuZ2V0QXV0b0NvbmZpcm1TdGF0dXMoKSxcbiAgICAgICAgc2RrLmdldFN1cHBvcnRlZEF1dG9Db25maXJtQ2hhaW5zKClcbiAgICAgIF0pO1xuICAgICAgc2V0U3RhdHVzKHN0YXR1c1Jlc3VsdCk7XG4gICAgICBzZXRTdXBwb3J0ZWRDaGFpbnMoc3VwcG9ydGVkUmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yMiA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGF1dG8tY29uZmlybSBkYXRhXCIpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtzZGssIGlzSW5qZWN0ZWRdKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKHNkayAmJiBpc0luamVjdGVkKSB7XG4gICAgICByZWZldGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXR1cyhudWxsKTtcbiAgICAgIHNldFN1cHBvcnRlZENoYWlucyhudWxsKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH1cbiAgfSwgW3NkaywgaXNJbmplY3RlZCwgcmVmZXRjaF0pO1xuICByZXR1cm4ge1xuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlLFxuICAgIHN0YXR1cyxcbiAgICBzdXBwb3J0ZWRDaGFpbnMsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHJlZmV0Y2hcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVNvbGFuYS50c1xuaW1wb3J0IHsgQWRkcmVzc1R5cGUgfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1zZGtcIjtcbmZ1bmN0aW9uIHVzZVNvbGFuYSgpIHtcbiAgY29uc3QgeyBzZGssIGlzQ2xpZW50LCBpc0xvYWRpbmcgfSA9IHVzZVBoYW50b20oKTtcbiAgaWYgKCFpc0NsaWVudCB8fCAhc2RrIHx8IGlzTG9hZGluZykge1xuICAgIHJldHVybiB7XG4gICAgICBzb2xhbmE6IHt9LFxuICAgICAgaXNBdmFpbGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBlbmFibGVkQWRkcmVzc1R5cGVzID0gc2RrLmdldEVuYWJsZWRBZGRyZXNzVHlwZXMoKTtcbiAgY29uc3QgaXNBdmFpbGFibGUgPSBlbmFibGVkQWRkcmVzc1R5cGVzLmluY2x1ZGVzKEFkZHJlc3NUeXBlLnNvbGFuYSk7XG4gIGlmICghaXNBdmFpbGFibGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sYW5hOiB7fSxcbiAgICAgIGlzQXZhaWxhYmxlOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgc29sYW5hOiBzZGsuc29sYW5hLFxuICAgICAgaXNBdmFpbGFibGU6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzb2xhbmE6IHt9LFxuICAgICAgaXNBdmFpbGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvaG9va3MvdXNlRXRoZXJldW0udHNcbmltcG9ydCB7IEFkZHJlc3NUeXBlIGFzIEFkZHJlc3NUeXBlMiB9IGZyb20gXCJAcGhhbnRvbS9icm93c2VyLXNka1wiO1xuZnVuY3Rpb24gdXNlRXRoZXJldW0oKSB7XG4gIGNvbnN0IHsgc2RrLCBpc0NsaWVudCwgaXNMb2FkaW5nIH0gPSB1c2VQaGFudG9tKCk7XG4gIGlmICghaXNDbGllbnQgfHwgIXNkayB8fCBpc0xvYWRpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXRoZXJldW06IHt9LFxuICAgICAgaXNBdmFpbGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBlbmFibGVkQWRkcmVzc1R5cGVzID0gc2RrLmdldEVuYWJsZWRBZGRyZXNzVHlwZXMoKTtcbiAgY29uc3QgaXNBdmFpbGFibGUgPSBlbmFibGVkQWRkcmVzc1R5cGVzLmluY2x1ZGVzKEFkZHJlc3NUeXBlMi5ldGhlcmV1bSk7XG4gIGlmICghaXNBdmFpbGFibGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXRoZXJldW06IHt9LFxuICAgICAgaXNBdmFpbGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICBldGhlcmV1bTogc2RrLmV0aGVyZXVtLFxuICAgICAgaXNBdmFpbGFibGU6IHRydWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBldGhlcmV1bToge30sXG4gICAgICBpc0F2YWlsYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9ob29rcy9pbmRleC50c1xuaW1wb3J0IHsgdXNlVGhlbWUgYXMgdXNlVGhlbWU1IH0gZnJvbSBcIkBwaGFudG9tL3dhbGxldC1zZGstdWlcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29ubmVjdEJ1dHRvbi50c3hcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVRoZW1lIGFzIHVzZVRoZW1lNiB9IGZyb20gXCJAcGhhbnRvbS93YWxsZXQtc2RrLXVpXCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gQ29ubmVjdEJ1dHRvbih7IGFkZHJlc3NUeXBlLCBmdWxsV2lkdGggPSBmYWxzZSB9KSB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWU2KCk7XG4gIGNvbnN0IHsgb3BlbiB9ID0gdXNlTW9kYWwoKTtcbiAgY29uc3QgeyBpc0Nvbm5lY3RlZCwgYWRkcmVzc2VzIH0gPSB1c2VQaGFudG9tKCk7XG4gIGNvbnN0IGRpc3BsYXlBZGRyZXNzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGlmICghYWRkcmVzc2VzIHx8IGFkZHJlc3Nlcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoYWRkcmVzc1R5cGUpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzZXMuZmluZCgoYWRkcikgPT4gYWRkci5hZGRyZXNzVHlwZSA9PT0gYWRkcmVzc1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzc2VzWzBdO1xuICB9LCBbYWRkcmVzc2VzLCBhZGRyZXNzVHlwZV0pO1xuICBjb25zdCB0cnVuY2F0ZWRBZGRyZXNzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGlmICghZGlzcGxheUFkZHJlc3MpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBhZGRyID0gZGlzcGxheUFkZHJlc3MuYWRkcmVzcztcbiAgICBpZiAoYWRkci5sZW5ndGggPD0gMTIpXG4gICAgICByZXR1cm4gYWRkcjtcbiAgICByZXR1cm4gYCR7YWRkci5zbGljZSgwLCA2KX0uLi4ke2FkZHIuc2xpY2UoLTQpfWA7XG4gIH0sIFtkaXNwbGF5QWRkcmVzc10pO1xuICBjb25zdCBidXR0b25TdHlsZSA9IHtcbiAgICB3aWR0aDogZnVsbFdpZHRoID8gXCIxMDAlXCIgOiBcImF1dG9cIixcbiAgICBwYWRkaW5nOiBcIjEycHggMTZweFwiLFxuICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5ib3JkZXJSYWRpdXMsXG4gICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uQm9sZC5mb250RmFtaWx5LFxuICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LmNhcHRpb25Cb2xkLmZvbnRTaXplLFxuICAgIGZvbnRTdHlsZTogdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uQm9sZC5mb250U3R5bGUsXG4gICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uQm9sZC5mb250V2VpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbkJvbGQubGluZUhlaWdodCxcbiAgICBsZXR0ZXJTcGFjaW5nOiB0aGVtZS50eXBvZ3JhcGh5LmNhcHRpb25Cb2xkLmxldHRlclNwYWNpbmcsXG4gICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICB0cmFuc2l0aW9uOiBcImJhY2tncm91bmQtY29sb3IgMC4yc1wiLFxuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgZ2FwOiBcIjhweFwiLFxuICAgIGJhY2tncm91bmQ6IHRoZW1lLmF1eCxcbiAgICBjb2xvcjogdGhlbWUudGV4dFxuICB9O1xuICBjb25zdCBjb25uZWN0ZWRCdXR0b25TdHlsZSA9IHtcbiAgICAuLi5idXR0b25TdHlsZSxcbiAgICBiYWNrZ3JvdW5kOiB0aGVtZS5hdXgsXG4gICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICB9O1xuICBpZiAoaXNDb25uZWN0ZWQgJiYgZGlzcGxheUFkZHJlc3MpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoXCJidXR0b25cIiwgeyBzdHlsZTogY29ubmVjdGVkQnV0dG9uU3R5bGUsIG9uQ2xpY2s6IG9wZW4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NyhcInNwYW5cIiwgeyBzdHlsZTogeyBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiIH0sIGNoaWxkcmVuOiB0cnVuY2F0ZWRBZGRyZXNzIH0pIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NyhcImJ1dHRvblwiLCB7IHN0eWxlOiBidXR0b25TdHlsZSwgb25DbGljazogb3BlbiwgY2hpbGRyZW46IFwiQ29ubmVjdCBXYWxsZXRcIiB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQ29ubmVjdEJveC50c3hcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVRoZW1lIGFzIHVzZVRoZW1lNyB9IGZyb20gXCJAcGhhbnRvbS93YWxsZXQtc2RrLXVpXCI7XG5pbXBvcnQgeyBqc3ggYXMganN4OCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gQ29ubmVjdEJveCh7IG1heFdpZHRoID0gXCIzNTBweFwiLCB0cmFuc3BhcmVudCA9IGZhbHNlLCBhcHBJY29uLCBhcHBOYW1lIH0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZTcoKTtcbiAgY29uc3QgeyBpc0Nvbm5lY3RlZCB9ID0gdXNlUGhhbnRvbSgpO1xuICBjb25zdCBib3hTdHlsZSA9IHVzZU1lbW81KCgpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIG1heFdpZHRoOiB0eXBlb2YgbWF4V2lkdGggPT09IFwibnVtYmVyXCIgPyBgJHttYXhXaWR0aH1weGAgOiBtYXhXaWR0aCxcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH07XG4gICAgaWYgKCF0cmFuc3BhcmVudCkge1xuICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhlbWUuYmFja2dyb3VuZDtcbiAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHRoZW1lLmJvcmRlclJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LCBbbWF4V2lkdGgsIHRyYW5zcGFyZW50LCB0aGVtZS5iYWNrZ3JvdW5kLCB0aGVtZS5ib3JkZXJSYWRpdXNdKTtcbiAgY29uc3Qgbm9PcCA9ICgpID0+IHtcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFwiZGl2XCIsIHsgc3R5bGU6IGJveFN0eWxlLCBjaGlsZHJlbjogaXNDb25uZWN0ZWQgPyAvKiBAX19QVVJFX18gKi8ganN4OChDb25uZWN0ZWRNb2RhbENvbnRlbnQsIHsgb25DbG9zZTogbm9PcCwgaGlkZUNsb3NlQnV0dG9uOiB0cnVlIH0pIDogLyogQF9fUFVSRV9fICovIGpzeDgoQ29ubmVjdE1vZGFsQ29udGVudCwgeyBhcHBJY29uLCBhcHBOYW1lLCBvbkNsb3NlOiBub09wLCBoaWRlQ2xvc2VCdXR0b246IHRydWUgfSkgfSk7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGFya1RoZW1lIGFzIGRhcmtUaGVtZTIsIGxpZ2h0VGhlbWUsIG1lcmdlVGhlbWUgYXMgbWVyZ2VUaGVtZTIgfSBmcm9tIFwiQHBoYW50b20vd2FsbGV0LXNkay11aVwiO1xuaW1wb3J0IHsgTmV0d29ya0lkLCBBZGRyZXNzVHlwZSBhcyBBZGRyZXNzVHlwZTMsIERlYnVnTGV2ZWwsIGRlYnVnLCBpc01vYmlsZURldmljZSBhcyBpc01vYmlsZURldmljZTMgfSBmcm9tIFwiQHBoYW50b20vYnJvd3Nlci1zZGtcIjtcbmV4cG9ydCB7XG4gIEFkZHJlc3NUeXBlMyBhcyBBZGRyZXNzVHlwZSxcbiAgQ29ubmVjdEJveCxcbiAgQ29ubmVjdEJ1dHRvbixcbiAgRGVidWdMZXZlbCxcbiAgTmV0d29ya0lkLFxuICBQaGFudG9tUHJvdmlkZXIsXG4gIGRhcmtUaGVtZTIgYXMgZGFya1RoZW1lLFxuICBkZWJ1ZyxcbiAgaXNNb2JpbGVEZXZpY2UzIGFzIGlzTW9iaWxlRGV2aWNlLFxuICBsaWdodFRoZW1lLFxuICBtZXJnZVRoZW1lMiBhcyBtZXJnZVRoZW1lLFxuICB1c2VBY2NvdW50cyxcbiAgdXNlQXV0b0NvbmZpcm0sXG4gIHVzZUNvbm5lY3QsXG4gIHVzZURpc2Nvbm5lY3QsXG4gIHVzZURpc2NvdmVyZWRXYWxsZXRzLFxuICB1c2VFdGhlcmV1bSxcbiAgdXNlSXNFeHRlbnNpb25JbnN0YWxsZWQsXG4gIHVzZUlzUGhhbnRvbUxvZ2luQXZhaWxhYmxlLFxuICB1c2VNb2RhbCxcbiAgdXNlUGhhbnRvbSxcbiAgdXNlU29sYW5hLFxuICB1c2VUaGVtZTUgYXMgdXNlVGhlbWVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/react-sdk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/sdk-types/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@phantom/sdk-types/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Algorithm: () => (/* reexport safe */ _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_0__.Algorithm)\n/* harmony export */ });\n/* harmony import */ var _phantom_openapi_wallet_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @phantom/openapi-wallet-service */ \"(ssr)/./node_modules/@phantom/openapi-wallet-service/dist/esm/model/algorithm.js\");\n// src/index.ts\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vc2RrLXR5cGVzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDNEQ7QUFHMUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL3Nkay10eXBlcy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IEFsZ29yaXRobSB9IGZyb20gXCJAcGhhbnRvbS9vcGVuYXBpLXdhbGxldC1zZXJ2aWNlXCI7XG5leHBvcnQge1xuICBBbGdvcml0aG1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/sdk-types/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/utils/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@phantom/utils/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getChainPrefix: () => (/* binding */ getChainPrefix),\n/* harmony export */   getSecureTimestamp: () => (/* binding */ getSecureTimestamp),\n/* harmony export */   getSecureTimestampSync: () => (/* binding */ getSecureTimestampSync),\n/* harmony export */   isEthereumChain: () => (/* binding */ isEthereumChain),\n/* harmony export */   isSolanaChain: () => (/* binding */ isSolanaChain),\n/* harmony export */   randomString: () => (/* binding */ randomString),\n/* harmony export */   randomUUID: () => (/* binding */ randomUUID)\n/* harmony export */ });\n// src/uuid.ts\nfunction randomUUID() {\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === \"x\" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\nfunction randomString(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\n// src/time.ts\nvar TimeService = class {\n  constructor() {\n    this.cache = null;\n    this.CACHE_DURATION = 3e4;\n    // 30 seconds cache\n    this.TIME_API_URL = \"https://time.phantom.app/utc\";\n  }\n  static getInstance() {\n    if (!TimeService.instance) {\n      TimeService.instance = new TimeService();\n    }\n    return TimeService.instance;\n  }\n  /**\n   * Get current timestamp from Phantom's secure time API\n   * Includes basic caching to reduce API calls\n   */\n  async now() {\n    const now = Date.now();\n    if (this.cache && now - this.cache.fetchedAt < this.CACHE_DURATION) {\n      const elapsed = now - this.cache.fetchedAt;\n      return this.cache.timestamp + elapsed;\n    }\n    try {\n      const response = await fetch(this.TIME_API_URL);\n      if (!response.ok) {\n        throw new Error(`Time API responded with status: ${response.status}`);\n      }\n      const timestampText = await response.text();\n      const timestamp = parseInt(timestampText, 10);\n      if (isNaN(timestamp)) {\n        throw new Error(`Invalid timestamp received: ${timestampText}`);\n      }\n      this.cache = {\n        timestamp,\n        fetchedAt: now\n      };\n      return timestamp;\n    } catch (error) {\n      return Date.now();\n    }\n  }\n  /**\n   * Synchronous version that uses cached time if available,\n   * otherwise falls back to Date.now()\n   */\n  nowSync() {\n    if (this.cache) {\n      const elapsed = Date.now() - this.cache.fetchedAt;\n      if (elapsed < this.CACHE_DURATION) {\n        return this.cache.timestamp + elapsed;\n      }\n    }\n    return Date.now();\n  }\n  /**\n   * Clear the cache (useful for testing)\n   */\n  clearCache() {\n    this.cache = null;\n  }\n};\nvar timeService = TimeService.getInstance();\nvar getSecureTimestamp = () => timeService.now();\nvar getSecureTimestampSync = () => timeService.nowSync();\n\n// src/network.ts\nfunction getChainPrefix(networkId) {\n  return networkId.split(\":\")[0].toLowerCase();\n}\nfunction isEthereumChain(networkId) {\n  const network = getChainPrefix(networkId);\n  return network === \"eip155\";\n}\nfunction isSolanaChain(networkId) {\n  const network = getChainPrefix(networkId);\n  return network === \"solana\";\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vdXRpbHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsiL1VzZXJzL2x1a2UvRG9jdW1lbnRzL2RmbG93L2Nvb2tib29rL3NyYy9wcm9vZi9ub2RlX21vZHVsZXMvQHBoYW50b20vdXRpbHMvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V1aWQudHNcbmZ1bmN0aW9uIHJhbmRvbVVVSUQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIGNyeXB0by5yYW5kb21VVUlEKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgY29uc3QgdiA9IGMgPT09IFwieFwiID8gciA6IHIgJiAzIHwgODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCkge1xuICBjb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy90aW1lLnRzXG52YXIgVGltZVNlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIHRoaXMuQ0FDSEVfRFVSQVRJT04gPSAzZTQ7XG4gICAgLy8gMzAgc2Vjb25kcyBjYWNoZVxuICAgIHRoaXMuVElNRV9BUElfVVJMID0gXCJodHRwczovL3RpbWUucGhhbnRvbS5hcHAvdXRjXCI7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICghVGltZVNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFRpbWVTZXJ2aWNlLmluc3RhbmNlID0gbmV3IFRpbWVTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBUaW1lU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGltZXN0YW1wIGZyb20gUGhhbnRvbSdzIHNlY3VyZSB0aW1lIEFQSVxuICAgKiBJbmNsdWRlcyBiYXNpYyBjYWNoaW5nIHRvIHJlZHVjZSBBUEkgY2FsbHNcbiAgICovXG4gIGFzeW5jIG5vdygpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0aGlzLmNhY2hlICYmIG5vdyAtIHRoaXMuY2FjaGUuZmV0Y2hlZEF0IDwgdGhpcy5DQUNIRV9EVVJBVElPTikge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIHRoaXMuY2FjaGUuZmV0Y2hlZEF0O1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUudGltZXN0YW1wICsgZWxhcHNlZDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5USU1FX0FQSV9VUkwpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpbWUgQVBJIHJlc3BvbmRlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lc3RhbXBUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQodGltZXN0YW1wVGV4dCwgMTApO1xuICAgICAgaWYgKGlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRpbWVzdGFtcCByZWNlaXZlZDogJHt0aW1lc3RhbXBUZXh0fWApO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IHtcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBmZXRjaGVkQXQ6IG5vd1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aW1lc3RhbXA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3luY2hyb25vdXMgdmVyc2lvbiB0aGF0IHVzZXMgY2FjaGVkIHRpbWUgaWYgYXZhaWxhYmxlLFxuICAgKiBvdGhlcndpc2UgZmFsbHMgYmFjayB0byBEYXRlLm5vdygpXG4gICAqL1xuICBub3dTeW5jKCkge1xuICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHRoaXMuY2FjaGUuZmV0Y2hlZEF0O1xuICAgICAgaWYgKGVsYXBzZWQgPCB0aGlzLkNBQ0hFX0RVUkFUSU9OKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnRpbWVzdGFtcCArIGVsYXBzZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciB0aGUgY2FjaGUgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gIH1cbn07XG52YXIgdGltZVNlcnZpY2UgPSBUaW1lU2VydmljZS5nZXRJbnN0YW5jZSgpO1xudmFyIGdldFNlY3VyZVRpbWVzdGFtcCA9ICgpID0+IHRpbWVTZXJ2aWNlLm5vdygpO1xudmFyIGdldFNlY3VyZVRpbWVzdGFtcFN5bmMgPSAoKSA9PiB0aW1lU2VydmljZS5ub3dTeW5jKCk7XG5cbi8vIHNyYy9uZXR3b3JrLnRzXG5mdW5jdGlvbiBnZXRDaGFpblByZWZpeChuZXR3b3JrSWQpIHtcbiAgcmV0dXJuIG5ldHdvcmtJZC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGlzRXRoZXJldW1DaGFpbihuZXR3b3JrSWQpIHtcbiAgY29uc3QgbmV0d29yayA9IGdldENoYWluUHJlZml4KG5ldHdvcmtJZCk7XG4gIHJldHVybiBuZXR3b3JrID09PSBcImVpcDE1NVwiO1xufVxuZnVuY3Rpb24gaXNTb2xhbmFDaGFpbihuZXR3b3JrSWQpIHtcbiAgY29uc3QgbmV0d29yayA9IGdldENoYWluUHJlZml4KG5ldHdvcmtJZCk7XG4gIHJldHVybiBuZXR3b3JrID09PSBcInNvbGFuYVwiO1xufVxuZXhwb3J0IHtcbiAgZ2V0Q2hhaW5QcmVmaXgsXG4gIGdldFNlY3VyZVRpbWVzdGFtcCxcbiAgZ2V0U2VjdXJlVGltZXN0YW1wU3luYyxcbiAgaXNFdGhlcmV1bUNoYWluLFxuICBpc1NvbGFuYUNoYWluLFxuICByYW5kb21TdHJpbmcsXG4gIHJhbmRvbVVVSURcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/utils/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@phantom/wallet-sdk-ui/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@phantom/wallet-sdk-ui/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoundedIcon: () => (/* binding */ BoundedIcon),\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   LoginWithPhantomButton: () => (/* binding */ LoginWithPhantomButton),\n/* harmony export */   Modal: () => (/* binding */ Modal),\n/* harmony export */   ModalHeader: () => (/* binding */ ModalHeader),\n/* harmony export */   Skeleton: () => (/* binding */ Skeleton),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   ThemeProvider: () => (/* binding */ ThemeProvider),\n/* harmony export */   darkTheme: () => (/* binding */ darkTheme),\n/* harmony export */   hexToRgba: () => (/* binding */ hexToRgba),\n/* harmony export */   lightTheme: () => (/* binding */ lightTheme),\n/* harmony export */   mergeTheme: () => (/* binding */ mergeTheme),\n/* harmony export */   mergeThemeNative: () => (/* binding */ mergeThemeNative),\n/* harmony export */   useTheme: () => (/* binding */ useTheme)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/utils/index.ts\nvar hexToRgba = (hex, opacity) => {\n  const cleanHex = hex.replace(\"#\", \"\");\n  const r = parseInt(cleanHex.slice(0, 2), 16);\n  const g = parseInt(cleanHex.slice(2, 4), 16);\n  const b = parseInt(cleanHex.slice(4, 6), 16);\n  return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n};\n\n// src/themes/index.ts\nvar loginWithPhantomColor = \"#7C63E7\";\nvar darkTheme = {\n  background: \"#181818\",\n  text: \"#FFFFFF\",\n  secondary: \"#98979C\",\n  overlay: \"rgba(0, 0, 0, 0.7)\",\n  borderRadius: \"16px\",\n  error: \"#F00000\",\n  success: \"#1CC700\",\n  brand: loginWithPhantomColor\n};\nvar lightTheme = {\n  background: \"#FFFFFF\",\n  text: \"#181818\",\n  secondary: \"#98979C\",\n  overlay: \"rgba(0, 0, 0, 0.5)\",\n  borderRadius: \"16px\",\n  error: \"#F00000\",\n  success: \"#1CC700\",\n  brand: loginWithPhantomColor\n};\nfunction mergeTheme(customTheme) {\n  const secondary = customTheme?.secondary || darkTheme.secondary;\n  const isHex = secondary.startsWith(\"#\");\n  if (!isHex) {\n    throw new Error(\"Secondary color must be a hex color to derive auxiliary color.\");\n  }\n  return {\n    ...darkTheme,\n    ...customTheme,\n    aux: hexToRgba(secondary, 0.1),\n    typography: {\n      caption: {\n        fontFamily: '\"SF Pro Text\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n        fontSize: \"14px\",\n        fontStyle: \"normal\",\n        fontWeight: \"400\",\n        lineHeight: \"17px\",\n        letterSpacing: \"-0.14px\"\n      },\n      captionBold: {\n        fontFamily: '\"SF Pro Text\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n        fontSize: \"14px\",\n        fontStyle: \"normal\",\n        fontWeight: \"600\",\n        lineHeight: \"17px\",\n        letterSpacing: \"-0.14px\"\n      },\n      label: {\n        fontFamily: '\"SF Pro Text\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n        fontSize: \"12px\",\n        fontStyle: \"normal\",\n        fontWeight: \"400\",\n        lineHeight: \"15px\",\n        letterSpacing: \"-0.12px\"\n      }\n    }\n  };\n}\nfunction mergeThemeNative(customTheme) {\n  const secondary = customTheme?.secondary || darkTheme.secondary;\n  const isHex = secondary.startsWith(\"#\");\n  if (!isHex) {\n    throw new Error(\"Secondary color must be a hex color to derive auxiliary color.\");\n  }\n  return {\n    ...darkTheme,\n    ...customTheme,\n    aux: hexToRgba(secondary, 0.1),\n    typography: {\n      caption: {\n        fontFamily: \"System\",\n        fontSize: 14,\n        fontStyle: \"normal\",\n        fontWeight: \"400\",\n        lineHeight: 17,\n        letterSpacing: -0.14\n      },\n      captionBold: {\n        fontFamily: \"System\",\n        fontSize: 14,\n        fontStyle: \"normal\",\n        fontWeight: \"600\",\n        lineHeight: 17,\n        letterSpacing: -0.14\n      },\n      label: {\n        fontFamily: \"System\",\n        fontSize: 12,\n        fontStyle: \"normal\",\n        fontWeight: \"400\",\n        lineHeight: 15,\n        letterSpacing: -0.12\n      }\n    }\n  };\n}\n\n// src/themes/ThemeContext.tsx\n\n\nvar ThemeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction ThemeProvider({ children, theme }) {\n  const resolvedTheme = mergeTheme(theme || darkTheme);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ThemeContext.Provider, { value: { theme: resolvedTheme }, children });\n}\nfunction useTheme() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);\n  if (!context) {\n    throw new Error(\"useTheme must be used within a ThemeProvider\");\n  }\n  return context.theme;\n}\n\n// src/components/Button.web.tsx\n\n\n// src/components/Icon.web.tsx\n\nvar ICONS = {\n  phantom: {\n    viewBox: \"0 0 20 20\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        d: \"M2.36655 18.3271C4.91871 18.3271 6.8367 16.1076 7.98131 14.3537C7.8421 14.7417 7.76476 15.1298 7.76476 15.5023C7.76476 16.5267 8.35253 17.2562 9.5126 17.2562C11.1058 17.2562 12.8072 15.8593 13.6889 14.3537C13.627 14.571 13.5961 14.7728 13.5961 14.959C13.5961 15.673 13.9982 16.1231 14.818 16.1231C17.4011 16.1231 19.9997 11.5444 19.9997 7.53987C19.9997 4.42011 18.422 1.67285 14.4622 1.67285C7.50181 1.67285 0 10.1785 0 15.673C0 17.8305 1.16007 18.3271 2.36655 18.3271ZM12.0648 7.19841C12.0648 6.42235 12.4979 5.8791 13.132 5.8791C13.7507 5.8791 14.1838 6.42235 14.1838 7.19841C14.1838 7.97447 13.7507 8.53323 13.132 8.53323C12.4979 8.53323 12.0648 7.97447 12.0648 7.19841ZM15.3748 7.19841C15.3748 6.42235 15.8079 5.8791 16.4421 5.8791C17.0608 5.8791 17.4939 6.42235 17.4939 7.19841C17.4939 7.97447 17.0608 8.53323 16.4421 8.53323C15.8079 8.53323 15.3748 7.97447 15.3748 7.19841Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  google: {\n    viewBox: \"0 0 20 20\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\n        \"mask\",\n        {\n          id: \"mask0_google\",\n          style: { maskType: \"luminance\" },\n          maskUnits: \"userSpaceOnUse\",\n          x: \"0\",\n          y: \"0\",\n          width: \"20\",\n          height: \"20\",\n          children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              \"path\",\n              {\n                d: \"M18.8 10.2084C18.8 9.55837 18.7417 8.93337 18.6333 8.33337H10V11.8834H14.9333C14.7167 13.025 14.0667 13.9917 13.0917 14.6417V16.95H16.0667C17.8 15.35 18.8 13 18.8 10.2084Z\",\n                fill: \"#FFFFFE\"\n              }\n            ),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              \"path\",\n              {\n                d: \"M9.99998 19.1667C12.475 19.1667 14.55 18.35 16.0667 16.95L13.0917 14.6417C12.275 15.1917 11.2333 15.525 9.99998 15.525C7.61665 15.525 5.59165 13.9167 4.86665 11.75H1.81665V14.1167C3.32498 17.1083 6.41665 19.1667 9.99998 19.1667Z\",\n                fill: \"#FFFFFE\"\n              }\n            ),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              \"path\",\n              {\n                d: \"M4.86659 11.7417C4.68325 11.1917 4.57492 10.6084 4.57492 10.0001C4.57492 9.39172 4.68325 8.80839 4.86659 8.25839V5.89172H1.81659C1.19159 7.12506 0.833252 8.51672 0.833252 10.0001C0.833252 11.4834 1.19159 12.8751 1.81659 14.1084L4.19159 12.2584L4.86659 11.7417Z\",\n                fill: \"#FFFFFE\"\n              }\n            ),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n              \"path\",\n              {\n                d: \"M9.99998 4.48337C11.35 4.48337 12.55 4.95004 13.5083 5.85004L16.1333 3.22504C14.5417 1.74171 12.475 0.833374 9.99998 0.833374C6.41665 0.833374 3.32498 2.89171 1.81665 5.89171L4.86665 8.25837C5.59165 6.09171 7.61665 4.48337 9.99998 4.48337Z\",\n                fill: \"#FFFFFE\"\n              }\n            )\n          ]\n        }\n      ),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"g\", { mask: \"url(#mask0_google)\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"rect\", { width: \"20\", height: \"20\", fill: \"currentColor\" }) })\n    ] })\n  },\n  apple: {\n    viewBox: \"0 0 20 20\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"g\", { clipPath: \"url(#clip0_apple)\", children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n        \"path\",\n        {\n          d: \"M16.9876 6.91634C16.8812 6.99884 15.0039 8.05667 15.0039 10.4088C15.0039 13.1295 17.3927 14.092 17.4642 14.1158C17.4532 14.1745 17.0847 15.434 16.2047 16.7173C15.4201 17.8467 14.6006 18.9742 13.3539 18.9742C12.1072 18.9742 11.7864 18.25 10.3472 18.25C8.94473 18.25 8.44606 18.998 7.30573 18.998C6.1654 18.998 5.36973 17.953 4.4549 16.6697C3.39523 15.1627 2.53906 12.8215 2.53906 10.5995C2.53906 7.0355 4.8564 5.14534 7.13706 5.14534C8.3489 5.14534 9.35906 5.941 10.1199 5.941C10.8441 5.941 11.9734 5.09767 13.3521 5.09767C13.8746 5.09767 15.7519 5.14534 16.9876 6.91634ZM12.6976 3.58884C13.2677 2.91234 13.6711 1.97367 13.6711 1.035C13.6711 0.904837 13.6601 0.772837 13.6362 0.666504C12.7086 0.701337 11.6049 1.28434 10.9394 2.05617C10.4169 2.65017 9.92923 3.58884 9.92923 4.54034C9.92923 4.68334 9.95306 4.82634 9.96406 4.87217C10.0227 4.88317 10.1181 4.896 10.2134 4.896C11.0457 4.896 12.0926 4.33867 12.6976 3.58884Z\",\n          fill: \"currentColor\"\n        }\n      ),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"defs\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"clipPath\", { id: \"clip0_apple\", children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"rect\", { width: \"14.9233\", height: \"18.3333\", fill: \"white\", transform: \"translate(2.53906 0.833374)\" }) }) })\n    ] })\n  },\n  wallet: {\n    viewBox: \"0 0 19 15\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M0 3.33333C0 1.49238 1.49238 0 3.33333 0H15C16.8409 0 18.3333 1.49238 18.3333 3.33333V11.6667C18.3333 13.5076 16.8409 15 15 15H3.33333C1.49238 15 0 13.5076 0 11.6667V3.33333ZM1.66667 8.33333V11.6667C1.66667 12.5871 2.41286 13.3333 3.33333 13.3333H15C15.9205 13.3333 16.6667 12.5871 16.6667 11.6667V8.33333H13.3333C12.9727 8.33333 12.6218 8.4503 12.3333 8.66667L11.1667 9.54167C9.98148 10.4306 8.35185 10.4306 7.16667 9.54167L6 8.66667C5.71151 8.4503 5.36062 8.33333 5 8.33333H1.66667ZM16.6667 6.66667C16.6667 5.74619 15.9205 5 15 5H3.33333C2.41286 5 1.66667 5.74619 1.66667 6.66667H5C5.72123 6.66667 6.42301 6.90059 7 7.33333L8.16667 8.20833C8.75926 8.65278 9.57407 8.65278 10.1667 8.20833L11.3333 7.33333C11.9103 6.90059 12.6121 6.66667 13.3333 6.66667H16.6667ZM16.6667 3.77927V3.33333C16.6667 2.41286 15.9205 1.66667 15 1.66667H3.33333C2.41286 1.66667 1.66667 2.41286 1.66667 3.33333V3.77927C2.15696 3.49566 2.72619 3.33333 3.33333 3.33333H15C15.6071 3.33333 16.1764 3.49566 16.6667 3.77927Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  \"chevron-right\": {\n    viewBox: \"0 0 16 16\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M5.52876 2.86189C5.78911 2.60154 6.21122 2.60154 6.47157 2.86189L11.1382 7.52855C11.3986 7.7889 11.3986 8.21101 11.1382 8.47136L6.47157 13.138C6.21122 13.3984 5.78911 13.3984 5.52876 13.138C5.26841 12.8777 5.26841 12.4556 5.52876 12.1952L9.72402 7.99996L5.52876 3.8047C5.26841 3.54435 5.26841 3.12224 5.52876 2.86189Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  \"arrow-right\": {\n    viewBox: \"0 0 16 16\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        d: \"M8 3L13 8L8 13\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\"\n      }\n    )\n  },\n  x: {\n    viewBox: \"0 0 16 16\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M2.86201 2.86201C3.12236 2.60166 3.54447 2.60166 3.80482 2.86201L8.00008 7.05727L12.1953 2.86201C12.4557 2.60166 12.8778 2.60166 13.1382 2.86201C13.3985 3.12236 13.3985 3.54447 13.1382 3.80482L8.94289 8.00008L13.1382 12.1953C13.3985 12.4557 13.3985 12.8778 13.1382 13.1382C12.8778 13.3985 12.4557 13.3985 12.1953 13.1382L8.00008 8.94289L3.80482 13.1382C3.54447 13.3985 3.12236 13.3985 2.86201 13.1382C2.60166 12.8778 2.60166 12.4557 2.86201 12.1953L7.05727 8.00008L2.86201 3.80482C2.60166 3.54447 2.60166 3.12236 2.86201 2.86201Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  tiktok: {\n    viewBox: \"0 0 20 20\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        d: \"M17.0156 7.54948C15.4792 7.54167 14.0156 6.94271 12.8958 5.89323V13.0573C12.8958 16.1042 10.401 18.599 7.35417 18.599C6.24219 18.599 5.21615 18.276 4.35417 17.7292C2.91927 16.8333 1.8776 15.3281 1.60938 13.5521C1.57813 13.3307 1.5625 13.1042 1.5625 12.8724C1.5625 9.82552 4.05729 7.33073 7.10417 7.33073C7.35156 7.33073 7.59375 7.35156 7.83073 7.38802V10.2708C7.59635 10.2161 7.35417 10.1849 7.10417 10.1849C5.63542 10.1849 4.44271 11.3776 4.44271 12.8464C4.44271 13.8333 4.97396 14.6875 5.76563 15.138C6.15104 15.3568 6.59375 15.4818 7.0651 15.4818C8.47917 15.4818 9.64323 14.3776 9.73438 13.0026C9.74219 12.9271 9.74479 5.3724 9.74479 5.3724H12.5469C12.6354 6.21615 12.9401 6.99479 13.4036 7.65885C14.0469 8.57552 14.9818 9.25521 16.0677 9.54948V7.54948H17.0156Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  close: {\n    viewBox: \"0 0 24 24\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        d: \"M18 6L6 18M6 6L18 18\",\n        stroke: \"currentColor\",\n        strokeWidth: \"2\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\"\n      }\n    )\n  },\n  solana: {\n    viewBox: \"0 0 9 9\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M1.54607 6.17667C1.57509 6.14475 1.61047 6.11923 1.64992 6.10177C1.68937 6.08429 1.73204 6.07526 1.77519 6.07523L8.84482 6.08101C8.87493 6.08107 8.90437 6.08988 8.92958 6.10636C8.95478 6.12283 8.97465 6.14627 8.98678 6.17382C8.99891 6.20137 9.00278 6.23185 8.99792 6.26156C8.99306 6.29127 8.97968 6.31894 8.95939 6.34119L7.45389 7.99886C7.42484 8.0308 7.38944 8.05634 7.34995 8.0738C7.31046 8.09128 7.26775 8.1003 7.22457 8.1003L0.155133 8.09452C0.125026 8.09446 0.0955847 8.08565 0.0703861 8.06917C0.0451864 8.0527 0.0253137 8.02927 0.0131815 8.00171C0.00104843 7.97416 -0.00282139 7.94368 0.00204072 7.91397C0.00690283 7.88426 0.0202886 7.85659 0.0405712 7.83434L1.54607 6.17667ZM8.95939 4.79673C8.97968 4.81898 8.99306 4.84664 8.99792 4.87635C9.00278 4.90606 8.99891 4.93655 8.98678 4.9641C8.97465 4.99166 8.95478 5.01509 8.92958 5.03156C8.90437 5.04804 8.87493 5.05684 8.84482 5.0569L1.77538 5.06269C1.73221 5.06269 1.6895 5.05366 1.65001 5.03619C1.61052 5.01873 1.57512 4.99319 1.54607 4.96124L0.0405712 3.30261C0.0202886 3.28036 0.00690283 3.2527 0.00204072 3.22298C-0.00282139 3.19327 0.00104843 3.16279 0.0131815 3.13524C0.0253137 3.10768 0.0451864 3.08425 0.0703861 3.06778C0.0955847 3.0513 0.125026 3.04249 0.155133 3.04243L7.22476 3.03665C7.26792 3.03668 7.31059 3.04571 7.35004 3.06319C7.38949 3.08065 7.42487 3.10617 7.45389 3.1381L8.95939 4.79673ZM1.54607 0.101447C1.57509 0.0695195 1.61047 0.0440047 1.64992 0.0265358C1.68937 0.00906688 1.73204 2.87448e-05 1.77519 0L8.84482 0.00578593C8.87493 0.00584714 8.90437 0.0146497 8.92958 0.0311243C8.95478 0.0475988 8.97465 0.0710365 8.98678 0.0985903C8.99891 0.126144 9.00278 0.156628 8.99792 0.18634C8.99306 0.21605 8.97968 0.243711 8.95939 0.26596L7.45389 1.92363C7.42484 1.95558 7.38944 1.98111 7.34995 1.99858C7.31046 2.01605 7.26775 2.02508 7.22457 2.02508L0.155133 2.01929C0.125026 2.01923 0.0955847 2.01043 0.0703861 1.99395C0.0451864 1.97748 0.0253137 1.95404 0.0131815 1.92648C0.00104843 1.89893 -0.00282139 1.86845 0.00204072 1.83874C0.00690283 1.80903 0.0202886 1.78136 0.0405712 1.75912L1.54607 0.101447Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  ethereum: {\n    viewBox: \"0 0 7 11\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", { d: \"M6.44558 5.3474L3.22279 7.25238L0 5.34739L3.22279 0L6.44558 5.3474Z\", fill: \"currentColor\" }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", { d: \"M6.44755 5.95857L3.22282 10.5L0 5.95852L3.22282 7.8626L6.44755 5.95857Z\", fill: \"currentColor\" })\n    ] })\n  },\n  bitcoin: {\n    viewBox: \"0 0 8 11\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        d: \"M6.11234 4.86004C6.66737 4.57405 7.01465 4.07038 6.93353 3.23129C6.82428 2.08459 5.84538 1.70007 4.60964 1.59057L4.6094 0H3.65195L3.65168 1.54874C3.39976 1.54874 3.14296 1.55375 2.88733 1.55893L2.88712 0.000211106L1.93052 0.000120638L1.93035 1.5903C1.72303 1.59458 1.51944 1.59865 1.32064 1.59865V1.59395L0 1.5934L0.000178762 2.62728C0.000178762 2.62728 0.707241 2.61383 0.695593 2.62689C1.08327 2.62716 1.20985 2.85486 1.24625 3.0514L1.24655 4.86339V7.40864C1.22948 7.53199 1.15765 7.72907 0.886584 7.72943C0.898918 7.74041 0.190097 7.72931 0.190097 7.72931L0.000178762 8.88543H1.24595C1.47809 8.8857 1.70617 8.88935 1.92993 8.89116L1.93076 10.4997L2.88712 10.5L2.88685 8.90829C3.14997 8.91371 3.40393 8.91607 3.65201 8.91573L3.65174 10.5H4.60916L4.6097 8.89411C6.21908 8.80062 7.34578 8.39056 7.48586 6.86191C7.59876 5.63118 7.02606 5.08182 6.11234 4.86004ZM2.91021 2.69707C3.4502 2.69707 5.14847 2.52315 5.14871 3.66406C5.14847 4.75787 3.45074 4.63009 2.91021 4.63009V2.69707ZM2.90979 7.73728L2.91021 5.60594C3.559 5.60576 5.59394 5.41712 5.59421 6.67113C5.59448 7.87371 3.559 7.73679 2.90979 7.73728Z\",\n        fill: \"currentColor\"\n      }\n    )\n  },\n  sui: {\n    viewBox: \"0 0 8 9\",\n    path: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n      \"path\",\n      {\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\",\n        d: \"M5.63424 3.75325C6.00135 4.21419 6.22089 4.79712 6.22089 5.43123C6.22089 6.06533 5.99468 6.66605 5.61793 7.12957L5.58528 7.16963L5.57676 7.11882C5.56935 7.0758 5.56083 7.03205 5.55081 6.9883C5.36206 6.15914 4.74725 5.44829 3.73527 4.87239C3.05184 4.48452 2.66063 4.01802 2.55793 3.48738C2.49155 3.14438 2.54086 2.79988 2.63615 2.5047C2.73147 2.2099 2.87311 1.96257 2.99363 1.81387L3.38744 1.33254C3.45642 1.248 3.58584 1.248 3.65479 1.33254L5.63462 3.75325H5.63424ZM6.25684 3.2723L3.61809 0.0461671C3.56767 -0.015389 3.47346 -0.015389 3.42305 0.0461671L0.784654 3.2723L0.776128 3.28307C0.290724 3.88565 0 4.6514 0 5.485C0 7.42624 1.57636 9 3.52057 9C5.46479 9 7.04113 7.42624 7.04113 5.485C7.04113 4.6514 6.7504 3.88565 6.26501 3.28342L6.25647 3.27267L6.25684 3.2723ZM1.41616 3.74288L1.652 3.454L1.65905 3.5074C1.66461 3.54967 1.67166 3.59194 1.67981 3.63459C1.83259 4.43594 2.37807 5.10379 3.28992 5.62108C4.08273 6.07237 4.54439 6.59116 4.67714 7.15999C4.73277 7.39732 4.74241 7.63092 4.71831 7.83526L4.71683 7.84786L4.70533 7.85342C4.3475 8.02807 3.94515 8.12634 3.52019 8.12634C2.02913 8.12634 0.820254 6.9197 0.820254 5.43085C0.820254 4.79156 1.04312 4.20454 1.41542 3.74213L1.41616 3.74288Z\",\n        fill: \"currentColor\"\n      }\n    )\n  }\n};\nfunction Icon({ type, size = 20, color, style }) {\n  const icon = ICONS[type];\n  const iconStyle = {\n    width: `${size}px`,\n    height: `${size}px`,\n    display: \"inline-block\",\n    color: color || \"currentColor\",\n    ...style\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", { style: iconStyle, viewBox: icon.viewBox, fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\", children: icon.path });\n}\n\n// src/components/Text.web.tsx\n\nfunction Text({ children, variant = \"caption\", color, style }) {\n  const theme = useTheme();\n  const textStyle = {\n    ...theme.typography[variant],\n    color: color ?? theme.text,\n    margin: 0,\n    ...style\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: textStyle, children });\n}\n\n// src/components/Button.web.tsx\n\nvar useBaseButtonStyle = ({ fullWidth, disabled, fontSize, fontWeight }) => {\n  const theme = useTheme();\n  return {\n    height: \"56px\",\n    padding: \"12px 16px\",\n    width: fullWidth ? \"100%\" : \"auto\",\n    border: \"none\",\n    borderRadius: theme.borderRadius,\n    fontFamily: theme.typography.captionBold.fontFamily,\n    fontSize: fontSize ?? theme.typography.captionBold.fontSize,\n    fontStyle: theme.typography.captionBold.fontStyle,\n    fontWeight: fontWeight ?? theme.typography.captionBold.fontWeight,\n    lineHeight: theme.typography.captionBold.lineHeight,\n    letterSpacing: theme.typography.captionBold.letterSpacing,\n    cursor: disabled ? \"not-allowed\" : \"pointer\",\n    transition: \"background-color 0.2s\",\n    gap: \"8px\"\n  };\n};\nfunction Button({\n  children,\n  onClick,\n  disabled = false,\n  variant = \"primary\",\n  fullWidth = true,\n  isLoading = false\n}) {\n  const theme = useTheme();\n  const [isHovering, setIsHovering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const isInteractive = !disabled && !isLoading;\n  const baseStyle = useBaseButtonStyle({\n    fullWidth,\n    disabled: disabled || isLoading\n  });\n  const backgroundColor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!isInteractive) {\n      return variant === \"primary\" ? theme.aux : \"transparent\";\n    }\n    if (isHovering) {\n      return variant === \"primary\" ? hexToRgba(theme.secondary, 0.15) : hexToRgba(theme.secondary, 0.1);\n    }\n    return variant === \"primary\" ? theme.aux : \"transparent\";\n  }, [isInteractive, isHovering, variant, theme.aux, theme.secondary]);\n  const buttonStyle = {\n    ...baseStyle,\n    backgroundColor,\n    color: theme.text,\n    border: variant === \"secondary\" ? `1px solid ${theme.secondary}` : \"none\"\n  };\n  const handleMouseEnter = () => {\n    if (isInteractive) {\n      setIsHovering(true);\n    }\n  };\n  const handleMouseLeave = () => {\n    setIsHovering(false);\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"button\",\n    {\n      style: buttonStyle,\n      onClick,\n      disabled: disabled || isLoading,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave,\n      children: isLoading ? \"Connecting...\" : children\n    }\n  );\n}\nfunction LoginWithPhantomButton({\n  children = \"Continue with Phantom\",\n  onClick,\n  disabled = false,\n  fullWidth = true,\n  isLoading = false,\n  testId = \"login-with-phantom-button\"\n}) {\n  const theme = useTheme();\n  const [isHovering, setIsHovering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const isInteractive = !disabled && !isLoading;\n  const baseStyle = useBaseButtonStyle({\n    fullWidth,\n    disabled: disabled || isLoading\n  });\n  const backgroundColor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!isInteractive) {\n      return theme.brand;\n    }\n    if (isHovering) {\n      return hexToRgba(theme.brand, 0.85);\n    }\n    return theme.brand;\n  }, [isInteractive, isHovering, theme.brand]);\n  const buttonStyle = {\n    ...baseStyle,\n    backgroundColor,\n    color: \"#FFFFFF\"\n  };\n  const handleMouseEnter = () => {\n    if (isInteractive) {\n      setIsHovering(true);\n    }\n  };\n  const handleMouseLeave = () => {\n    setIsHovering(false);\n  };\n  const buttonContentStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    gap: \"8px\",\n    width: \"100%\"\n  };\n  const buttonLeftStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    gap: \"8px\"\n  };\n  const buttonRightStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    gap: \"8px\"\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    \"button\",\n    {\n      style: buttonStyle,\n      onClick,\n      disabled: disabled || isLoading,\n      onMouseEnter: handleMouseEnter,\n      onMouseLeave: handleMouseLeave,\n      \"data-testid\": testId,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { style: buttonContentStyle, children: [\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { style: buttonLeftStyle, children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Icon, { type: \"phantom\", size: 20 }),\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, { variant: \"captionBold\", color: \"#FFFFFF\", children: isLoading ? \"Connecting...\" : children })\n        ] }),\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: buttonRightStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Icon, { type: \"chevron-right\", size: 16, color: \"#FFFFFF\" }) })\n      ] })\n    }\n  );\n}\n\n// src/components/BoundedIcon.web.tsx\n\nfunction BoundedIcon({ type, size = 20, color, style, background }) {\n  const theme = useTheme();\n  const iconBackgroundStyle = {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    width: \"32px\",\n    height: \"32px\",\n    borderRadius: \"8px\",\n    backgroundColor: background ?? theme.aux\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: { ...iconBackgroundStyle, ...style }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Icon, { type, size, color }) });\n}\n\n// src/components/Skeleton.web.tsx\n\nfunction Skeleton({ width = \"100%\", height = \"20px\", borderRadius, style }) {\n  const theme = useTheme();\n  const skeletonStyle = {\n    width,\n    height,\n    borderRadius: borderRadius ?? theme.borderRadius,\n    backgroundColor: theme.aux,\n    animation: \"pulse 1.5s ease-in-out infinite\",\n    ...style\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", { children: `\n          @keyframes pulse {\n            0%, 100% {\n              opacity: 1;\n            }\n            50% {\n              opacity: 0.5;\n            }\n          }\n        ` }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: skeletonStyle })\n  ] });\n}\n\n// src/components/Modal.web.tsx\n\n\nfunction Modal({\n  appIcon: _appIcon,\n  appName: _appName,\n  isVisible,\n  onClose,\n  isMobile = false,\n  children\n}) {\n  const theme = useTheme();\n  const contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [contentHeight, setContentHeight] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"auto\");\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!isVisible || !contentRef.current)\n      return;\n    const measureHeight = () => {\n      if (contentRef.current) {\n        const height = contentRef.current.scrollHeight;\n        setContentHeight(height);\n      }\n    };\n    measureHeight();\n    const resizeObserver = new ResizeObserver(() => {\n      measureHeight();\n    });\n    if (contentRef.current) {\n      resizeObserver.observe(contentRef.current);\n    }\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [isVisible, children]);\n  if (!isVisible)\n    return null;\n  const overlayStyle = {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: theme.overlay,\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 9999,\n    padding: isMobile ? \"16px\" : \"0\"\n  };\n  const modalStyle = {\n    backgroundColor: theme.background,\n    borderRadius: theme.borderRadius,\n    maxWidth: isMobile ? \"100%\" : \"350px\",\n    width: \"100%\",\n    boxShadow: \"0 8px 32px rgba(0, 0, 0, 0.3)\",\n    position: \"relative\",\n    overflow: \"hidden\",\n    transition: \"max-width 0.1s ease-in-out\"\n  };\n  const modalContentWrapperStyle = {\n    height: typeof contentHeight === \"number\" ? `${contentHeight}px` : \"auto\",\n    transition: \"height 0.15s ease-in-out\",\n    overflow: \"hidden\"\n  };\n  const modalContentStyle = {\n    transition: \"opacity 0.15s ease-in-out\"\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: overlayStyle, onClick: onClose, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: modalStyle, onClick: (e) => e.stopPropagation(), children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: modalContentWrapperStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: contentRef, style: modalContentStyle, children }) }) }) });\n}\n\n// src/components/ModalHeader.web.tsx\n\nfunction ModalHeader({ goBack = false, onGoBack, title, onClose, hideCloseButton = false }) {\n  const theme = useTheme();\n  const headerStyle = {\n    position: \"relative\",\n    display: \"flex\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: \"28px 32px 0 32px\",\n    height: \"32px\"\n  };\n  const titleStyle = {\n    fontFeatureSettings: '\"liga\" off, \"clig\" off'\n  };\n  const backButtonStyle = {\n    position: \"absolute\",\n    left: \"32px\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    cursor: \"pointer\",\n    padding: \"8px\",\n    background: \"none\",\n    border: \"none\",\n    width: \"32px\",\n    height: \"32px\"\n  };\n  const closeButtonStyle = {\n    position: \"absolute\",\n    right: \"32px\",\n    background: \"none\",\n    border: \"none\",\n    color: theme.secondary,\n    fontSize: \"24px\",\n    cursor: \"pointer\",\n    padding: \"4px 8px\",\n    lineHeight: 1,\n    transition: \"color 0.2s\",\n    width: \"auto\"\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { style: headerStyle, children: [\n    goBack && onGoBack && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", { style: backButtonStyle, onClick: onGoBack, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Icon, { type: \"chevron-right\", size: 16, color: theme.secondary, style: { transform: \"rotate(180deg)\" } }) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { style: titleStyle, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Text, { variant: \"caption\", color: theme.secondary, children: title }) }),\n    onClose && !hideCloseButton && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", { style: closeButtonStyle, onClick: onClose, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Icon, { type: \"x\", size: 16, color: theme.secondary }) })\n  ] });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBoYW50b20vd2FsbGV0LXNkay11aS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrRDtBQUNWO0FBQ3hDLG1CQUFtQixvREFBYTtBQUNoQyx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0EseUJBQXlCLHNEQUFHLDBCQUEwQixTQUFTLHNCQUFzQixZQUFZO0FBQ2pHO0FBQ0E7QUFDQSxrQkFBa0IsaURBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQzs7QUFFMUM7QUFDZ0U7QUFDaEU7QUFD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LFVBQVUscURBQXFELEdBQUcsR0FBRyxHQUFHO0FBQzdWOztBQUVBO0FBQytEO0FBQy9ELHVCQUF1QixtRUFBbUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBSyxVQUFVO0FBQ3hDLDBDQUEwQyxzREFBSSxhQUFhLHFFQUFxRSxzREFBSSxTQUFTLGtFQUFrRSwrQkFBK0IsR0FBRztBQUNqUCxvQkFBb0Isc0RBQUksVUFBVSw2Q0FBNkMsc0RBQUksU0FBUyw2REFBNkQsR0FBRztBQUM1SixtREFBbUQsc0RBQUksYUFBYSxxRUFBcUUsc0RBQUksU0FBUyw2Q0FBNkMsR0FBRztBQUN0TSxLQUFLO0FBQ0w7QUFpQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sdWtlL0RvY3VtZW50cy9kZmxvdy9jb29rYm9vay9zcmMvcHJvb2Yvbm9kZV9tb2R1bGVzL0BwaGFudG9tL3dhbGxldC1zZGstdWkvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL2luZGV4LnRzXG52YXIgaGV4VG9SZ2JhID0gKGhleCwgb3BhY2l0eSkgPT4ge1xuICBjb25zdCBjbGVhbkhleCA9IGhleC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbiAgY29uc3QgciA9IHBhcnNlSW50KGNsZWFuSGV4LnNsaWNlKDAsIDIpLCAxNik7XG4gIGNvbnN0IGcgPSBwYXJzZUludChjbGVhbkhleC5zbGljZSgyLCA0KSwgMTYpO1xuICBjb25zdCBiID0gcGFyc2VJbnQoY2xlYW5IZXguc2xpY2UoNCwgNiksIDE2KTtcbiAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7b3BhY2l0eX0pYDtcbn07XG5cbi8vIHNyYy90aGVtZXMvaW5kZXgudHNcbnZhciBsb2dpbldpdGhQaGFudG9tQ29sb3IgPSBcIiM3QzYzRTdcIjtcbnZhciBkYXJrVGhlbWUgPSB7XG4gIGJhY2tncm91bmQ6IFwiIzE4MTgxOFwiLFxuICB0ZXh0OiBcIiNGRkZGRkZcIixcbiAgc2Vjb25kYXJ5OiBcIiM5ODk3OUNcIixcbiAgb3ZlcmxheTogXCJyZ2JhKDAsIDAsIDAsIDAuNylcIixcbiAgYm9yZGVyUmFkaXVzOiBcIjE2cHhcIixcbiAgZXJyb3I6IFwiI0YwMDAwMFwiLFxuICBzdWNjZXNzOiBcIiMxQ0M3MDBcIixcbiAgYnJhbmQ6IGxvZ2luV2l0aFBoYW50b21Db2xvclxufTtcbnZhciBsaWdodFRoZW1lID0ge1xuICBiYWNrZ3JvdW5kOiBcIiNGRkZGRkZcIixcbiAgdGV4dDogXCIjMTgxODE4XCIsXG4gIHNlY29uZGFyeTogXCIjOTg5NzlDXCIsXG4gIG92ZXJsYXk6IFwicmdiYSgwLCAwLCAwLCAwLjUpXCIsXG4gIGJvcmRlclJhZGl1czogXCIxNnB4XCIsXG4gIGVycm9yOiBcIiNGMDAwMDBcIixcbiAgc3VjY2VzczogXCIjMUNDNzAwXCIsXG4gIGJyYW5kOiBsb2dpbldpdGhQaGFudG9tQ29sb3Jcbn07XG5mdW5jdGlvbiBtZXJnZVRoZW1lKGN1c3RvbVRoZW1lKSB7XG4gIGNvbnN0IHNlY29uZGFyeSA9IGN1c3RvbVRoZW1lPy5zZWNvbmRhcnkgfHwgZGFya1RoZW1lLnNlY29uZGFyeTtcbiAgY29uc3QgaXNIZXggPSBzZWNvbmRhcnkuc3RhcnRzV2l0aChcIiNcIik7XG4gIGlmICghaXNIZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmRhcnkgY29sb3IgbXVzdCBiZSBhIGhleCBjb2xvciB0byBkZXJpdmUgYXV4aWxpYXJ5IGNvbG9yLlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRhcmtUaGVtZSxcbiAgICAuLi5jdXN0b21UaGVtZSxcbiAgICBhdXg6IGhleFRvUmdiYShzZWNvbmRhcnksIDAuMSksXG4gICAgdHlwb2dyYXBoeToge1xuICAgICAgY2FwdGlvbjoge1xuICAgICAgICBmb250RmFtaWx5OiAnXCJTRiBQcm8gVGV4dFwiLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFwiU2Vnb2UgVUlcIiwgUm9ib3RvLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgICAgICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiMTdweFwiLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIi0wLjE0cHhcIlxuICAgICAgfSxcbiAgICAgIGNhcHRpb25Cb2xkOiB7XG4gICAgICAgIGZvbnRGYW1pbHk6ICdcIlNGIFBybyBUZXh0XCIsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIHNhbnMtc2VyaWYnLFxuICAgICAgICBmb250U2l6ZTogXCIxNHB4XCIsXG4gICAgICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIixcbiAgICAgICAgbGluZUhlaWdodDogXCIxN3B4XCIsXG4gICAgICAgIGxldHRlclNwYWNpbmc6IFwiLTAuMTRweFwiXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZm9udEZhbWlseTogJ1wiU0YgUHJvIFRleHRcIiwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIFJvYm90bywgc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcIjE1cHhcIixcbiAgICAgICAgbGV0dGVyU3BhY2luZzogXCItMC4xMnB4XCJcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVRoZW1lTmF0aXZlKGN1c3RvbVRoZW1lKSB7XG4gIGNvbnN0IHNlY29uZGFyeSA9IGN1c3RvbVRoZW1lPy5zZWNvbmRhcnkgfHwgZGFya1RoZW1lLnNlY29uZGFyeTtcbiAgY29uc3QgaXNIZXggPSBzZWNvbmRhcnkuc3RhcnRzV2l0aChcIiNcIik7XG4gIGlmICghaXNIZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmRhcnkgY29sb3IgbXVzdCBiZSBhIGhleCBjb2xvciB0byBkZXJpdmUgYXV4aWxpYXJ5IGNvbG9yLlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRhcmtUaGVtZSxcbiAgICAuLi5jdXN0b21UaGVtZSxcbiAgICBhdXg6IGhleFRvUmdiYShzZWNvbmRhcnksIDAuMSksXG4gICAgdHlwb2dyYXBoeToge1xuICAgICAgY2FwdGlvbjoge1xuICAgICAgICBmb250RmFtaWx5OiBcIlN5c3RlbVwiLFxuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgZm9udFdlaWdodDogXCI0MDBcIixcbiAgICAgICAgbGluZUhlaWdodDogMTcsXG4gICAgICAgIGxldHRlclNwYWNpbmc6IC0wLjE0XG4gICAgICB9LFxuICAgICAgY2FwdGlvbkJvbGQ6IHtcbiAgICAgICAgZm9udEZhbWlseTogXCJTeXN0ZW1cIixcbiAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiNjAwXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDE3LFxuICAgICAgICBsZXR0ZXJTcGFjaW5nOiAtMC4xNFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGZvbnRGYW1pbHk6IFwiU3lzdGVtXCIsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxNSxcbiAgICAgICAgbGV0dGVyU3BhY2luZzogLTAuMTJcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy90aGVtZXMvVGhlbWVDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gVGhlbWVQcm92aWRlcih7IGNoaWxkcmVuLCB0aGVtZSB9KSB7XG4gIGNvbnN0IHJlc29sdmVkVGhlbWUgPSBtZXJnZVRoZW1lKHRoZW1lIHx8IGRhcmtUaGVtZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFRoZW1lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyB0aGVtZTogcmVzb2x2ZWRUaGVtZSB9LCBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VUaGVtZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgVGhlbWVQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC50aGVtZTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQnV0dG9uLndlYi50c3hcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL0ljb24ud2ViLnRzeFxuaW1wb3J0IHsgRnJhZ21lbnQsIGpzeCBhcyBqc3gyLCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSUNPTlMgPSB7XG4gIHBoYW50b206IHtcbiAgICB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLFxuICAgIHBhdGg6IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgXCJwYXRoXCIsXG4gICAgICB7XG4gICAgICAgIGQ6IFwiTTIuMzY2NTUgMTguMzI3MUM0LjkxODcxIDE4LjMyNzEgNi44MzY3IDE2LjEwNzYgNy45ODEzMSAxNC4zNTM3QzcuODQyMSAxNC43NDE3IDcuNzY0NzYgMTUuMTI5OCA3Ljc2NDc2IDE1LjUwMjNDNy43NjQ3NiAxNi41MjY3IDguMzUyNTMgMTcuMjU2MiA5LjUxMjYgMTcuMjU2MkMxMS4xMDU4IDE3LjI1NjIgMTIuODA3MiAxNS44NTkzIDEzLjY4ODkgMTQuMzUzN0MxMy42MjcgMTQuNTcxIDEzLjU5NjEgMTQuNzcyOCAxMy41OTYxIDE0Ljk1OUMxMy41OTYxIDE1LjY3MyAxMy45OTgyIDE2LjEyMzEgMTQuODE4IDE2LjEyMzFDMTcuNDAxMSAxNi4xMjMxIDE5Ljk5OTcgMTEuNTQ0NCAxOS45OTk3IDcuNTM5ODdDMTkuOTk5NyA0LjQyMDExIDE4LjQyMiAxLjY3Mjg1IDE0LjQ2MjIgMS42NzI4NUM3LjUwMTgxIDEuNjcyODUgMCAxMC4xNzg1IDAgMTUuNjczQzAgMTcuODMwNSAxLjE2MDA3IDE4LjMyNzEgMi4zNjY1NSAxOC4zMjcxWk0xMi4wNjQ4IDcuMTk4NDFDMTIuMDY0OCA2LjQyMjM1IDEyLjQ5NzkgNS44NzkxIDEzLjEzMiA1Ljg3OTFDMTMuNzUwNyA1Ljg3OTEgMTQuMTgzOCA2LjQyMjM1IDE0LjE4MzggNy4xOTg0MUMxNC4xODM4IDcuOTc0NDcgMTMuNzUwNyA4LjUzMzIzIDEzLjEzMiA4LjUzMzIzQzEyLjQ5NzkgOC41MzMyMyAxMi4wNjQ4IDcuOTc0NDcgMTIuMDY0OCA3LjE5ODQxWk0xNS4zNzQ4IDcuMTk4NDFDMTUuMzc0OCA2LjQyMjM1IDE1LjgwNzkgNS44NzkxIDE2LjQ0MjEgNS44NzkxQzE3LjA2MDggNS44NzkxIDE3LjQ5MzkgNi40MjIzNSAxNy40OTM5IDcuMTk4NDFDMTcuNDkzOSA3Ljk3NDQ3IDE3LjA2MDggOC41MzMyMyAxNi40NDIxIDguNTMzMjNDMTUuODA3OSA4LjUzMzIzIDE1LjM3NDggNy45NzQ0NyAxNS4zNzQ4IDcuMTk4NDFaXCIsXG4gICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgIH1cbiAgICApXG4gIH0sXG4gIGdvb2dsZToge1xuICAgIHZpZXdCb3g6IFwiMCAwIDIwIDIwXCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICBcIm1hc2tcIixcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcIm1hc2swX2dvb2dsZVwiLFxuICAgICAgICAgIHN0eWxlOiB7IG1hc2tUeXBlOiBcImx1bWluYW5jZVwiIH0sXG4gICAgICAgICAgbWFza1VuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgeDogXCIwXCIsXG4gICAgICAgICAgeTogXCIwXCIsXG4gICAgICAgICAgd2lkdGg6IFwiMjBcIixcbiAgICAgICAgICBoZWlnaHQ6IFwiMjBcIixcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICAgICAgICAgIFwicGF0aFwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZDogXCJNMTguOCAxMC4yMDg0QzE4LjggOS41NTgzNyAxOC43NDE3IDguOTMzMzcgMTguNjMzMyA4LjMzMzM3SDEwVjExLjg4MzRIMTQuOTMzM0MxNC43MTY3IDEzLjAyNSAxNC4wNjY3IDEzLjk5MTcgMTMuMDkxNyAxNC42NDE3VjE2Ljk1SDE2LjA2NjdDMTcuOCAxNS4zNSAxOC44IDEzIDE4LjggMTAuMjA4NFpcIixcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiNGRkZGRkVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICAgICAgICAgIFwicGF0aFwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZDogXCJNOS45OTk5OCAxOS4xNjY3QzEyLjQ3NSAxOS4xNjY3IDE0LjU1IDE4LjM1IDE2LjA2NjcgMTYuOTVMMTMuMDkxNyAxNC42NDE3QzEyLjI3NSAxNS4xOTE3IDExLjIzMzMgMTUuNTI1IDkuOTk5OTggMTUuNTI1QzcuNjE2NjUgMTUuNTI1IDUuNTkxNjUgMTMuOTE2NyA0Ljg2NjY1IDExLjc1SDEuODE2NjVWMTQuMTE2N0MzLjMyNDk4IDE3LjEwODMgNi40MTY2NSAxOS4xNjY3IDkuOTk5OTggMTkuMTY2N1pcIixcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiNGRkZGRkVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICAgICAgICAgIFwicGF0aFwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZDogXCJNNC44NjY1OSAxMS43NDE3QzQuNjgzMjUgMTEuMTkxNyA0LjU3NDkyIDEwLjYwODQgNC41NzQ5MiAxMC4wMDAxQzQuNTc0OTIgOS4zOTE3MiA0LjY4MzI1IDguODA4MzkgNC44NjY1OSA4LjI1ODM5VjUuODkxNzJIMS44MTY1OUMxLjE5MTU5IDcuMTI1MDYgMC44MzMyNTIgOC41MTY3MiAwLjgzMzI1MiAxMC4wMDAxQzAuODMzMjUyIDExLjQ4MzQgMS4xOTE1OSAxMi44NzUxIDEuODE2NTkgMTQuMTA4NEw0LjE5MTU5IDEyLjI1ODRMNC44NjY1OSAxMS43NDE3WlwiLFxuICAgICAgICAgICAgICAgIGZpbGw6IFwiI0ZGRkZGRVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgICAgICAgICAgXCJwYXRoXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkOiBcIk05Ljk5OTk4IDQuNDgzMzdDMTEuMzUgNC40ODMzNyAxMi41NSA0Ljk1MDA0IDEzLjUwODMgNS44NTAwNEwxNi4xMzMzIDMuMjI1MDRDMTQuNTQxNyAxLjc0MTcxIDEyLjQ3NSAwLjgzMzM3NCA5Ljk5OTk4IDAuODMzMzc0QzYuNDE2NjUgMC44MzMzNzQgMy4zMjQ5OCAyLjg5MTcxIDEuODE2NjUgNS44OTE3MUw0Ljg2NjY1IDguMjU4MzdDNS41OTE2NSA2LjA5MTcxIDcuNjE2NjUgNC40ODMzNyA5Ljk5OTk4IDQuNDgzMzdaXCIsXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjRkZGRkZFXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZ1wiLCB7IG1hc2s6IFwidXJsKCNtYXNrMF9nb29nbGUpXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcInJlY3RcIiwgeyB3aWR0aDogXCIyMFwiLCBoZWlnaHQ6IFwiMjBcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9KSB9KVxuICAgIF0gfSlcbiAgfSxcbiAgYXBwbGU6IHtcbiAgICB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLFxuICAgIHBhdGg6IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZ1wiLCB7IGNsaXBQYXRoOiBcInVybCgjY2xpcDBfYXBwbGUpXCIsIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgICAgXCJwYXRoXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBkOiBcIk0xNi45ODc2IDYuOTE2MzRDMTYuODgxMiA2Ljk5ODg0IDE1LjAwMzkgOC4wNTY2NyAxNS4wMDM5IDEwLjQwODhDMTUuMDAzOSAxMy4xMjk1IDE3LjM5MjcgMTQuMDkyIDE3LjQ2NDIgMTQuMTE1OEMxNy40NTMyIDE0LjE3NDUgMTcuMDg0NyAxNS40MzQgMTYuMjA0NyAxNi43MTczQzE1LjQyMDEgMTcuODQ2NyAxNC42MDA2IDE4Ljk3NDIgMTMuMzUzOSAxOC45NzQyQzEyLjEwNzIgMTguOTc0MiAxMS43ODY0IDE4LjI1IDEwLjM0NzIgMTguMjVDOC45NDQ3MyAxOC4yNSA4LjQ0NjA2IDE4Ljk5OCA3LjMwNTczIDE4Ljk5OEM2LjE2NTQgMTguOTk4IDUuMzY5NzMgMTcuOTUzIDQuNDU0OSAxNi42Njk3QzMuMzk1MjMgMTUuMTYyNyAyLjUzOTA2IDEyLjgyMTUgMi41MzkwNiAxMC41OTk1QzIuNTM5MDYgNy4wMzU1IDQuODU2NCA1LjE0NTM0IDcuMTM3MDYgNS4xNDUzNEM4LjM0ODkgNS4xNDUzNCA5LjM1OTA2IDUuOTQxIDEwLjExOTkgNS45NDFDMTAuODQ0MSA1Ljk0MSAxMS45NzM0IDUuMDk3NjcgMTMuMzUyMSA1LjA5NzY3QzEzLjg3NDYgNS4wOTc2NyAxNS43NTE5IDUuMTQ1MzQgMTYuOTg3NiA2LjkxNjM0Wk0xMi42OTc2IDMuNTg4ODRDMTMuMjY3NyAyLjkxMjM0IDEzLjY3MTEgMS45NzM2NyAxMy42NzExIDEuMDM1QzEzLjY3MTEgMC45MDQ4MzcgMTMuNjYwMSAwLjc3MjgzNyAxMy42MzYyIDAuNjY2NTA0QzEyLjcwODYgMC43MDEzMzcgMTEuNjA0OSAxLjI4NDM0IDEwLjkzOTQgMi4wNTYxN0MxMC40MTY5IDIuNjUwMTcgOS45MjkyMyAzLjU4ODg0IDkuOTI5MjMgNC41NDAzNEM5LjkyOTIzIDQuNjgzMzQgOS45NTMwNiA0LjgyNjM0IDkuOTY0MDYgNC44NzIxN0MxMC4wMjI3IDQuODgzMTcgMTAuMTE4MSA0Ljg5NiAxMC4yMTM0IDQuODk2QzExLjA0NTcgNC44OTYgMTIuMDkyNiA0LjMzODY3IDEyLjY5NzYgMy41ODg4NFpcIixcbiAgICAgICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MihcImRlZnNcIiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoXCJjbGlwUGF0aFwiLCB7IGlkOiBcImNsaXAwX2FwcGxlXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcInJlY3RcIiwgeyB3aWR0aDogXCIxNC45MjMzXCIsIGhlaWdodDogXCIxOC4zMzMzXCIsIGZpbGw6IFwid2hpdGVcIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgyLjUzOTA2IDAuODMzMzc0KVwiIH0pIH0pIH0pXG4gICAgXSB9KVxuICB9LFxuICB3YWxsZXQ6IHtcbiAgICB2aWV3Qm94OiBcIjAgMCAxOSAxNVwiLFxuICAgIHBhdGg6IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgXCJwYXRoXCIsXG4gICAgICB7XG4gICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgICBkOiBcIk0wIDMuMzMzMzNDMCAxLjQ5MjM4IDEuNDkyMzggMCAzLjMzMzMzIDBIMTVDMTYuODQwOSAwIDE4LjMzMzMgMS40OTIzOCAxOC4zMzMzIDMuMzMzMzNWMTEuNjY2N0MxOC4zMzMzIDEzLjUwNzYgMTYuODQwOSAxNSAxNSAxNUgzLjMzMzMzQzEuNDkyMzggMTUgMCAxMy41MDc2IDAgMTEuNjY2N1YzLjMzMzMzWk0xLjY2NjY3IDguMzMzMzNWMTEuNjY2N0MxLjY2NjY3IDEyLjU4NzEgMi40MTI4NiAxMy4zMzMzIDMuMzMzMzMgMTMuMzMzM0gxNUMxNS45MjA1IDEzLjMzMzMgMTYuNjY2NyAxMi41ODcxIDE2LjY2NjcgMTEuNjY2N1Y4LjMzMzMzSDEzLjMzMzNDMTIuOTcyNyA4LjMzMzMzIDEyLjYyMTggOC40NTAzIDEyLjMzMzMgOC42NjY2N0wxMS4xNjY3IDkuNTQxNjdDOS45ODE0OCAxMC40MzA2IDguMzUxODUgMTAuNDMwNiA3LjE2NjY3IDkuNTQxNjdMNiA4LjY2NjY3QzUuNzExNTEgOC40NTAzIDUuMzYwNjIgOC4zMzMzMyA1IDguMzMzMzNIMS42NjY2N1pNMTYuNjY2NyA2LjY2NjY3QzE2LjY2NjcgNS43NDYxOSAxNS45MjA1IDUgMTUgNUgzLjMzMzMzQzIuNDEyODYgNSAxLjY2NjY3IDUuNzQ2MTkgMS42NjY2NyA2LjY2NjY3SDVDNS43MjEyMyA2LjY2NjY3IDYuNDIzMDEgNi45MDA1OSA3IDcuMzMzMzNMOC4xNjY2NyA4LjIwODMzQzguNzU5MjYgOC42NTI3OCA5LjU3NDA3IDguNjUyNzggMTAuMTY2NyA4LjIwODMzTDExLjMzMzMgNy4zMzMzM0MxMS45MTAzIDYuOTAwNTkgMTIuNjEyMSA2LjY2NjY3IDEzLjMzMzMgNi42NjY2N0gxNi42NjY3Wk0xNi42NjY3IDMuNzc5MjdWMy4zMzMzM0MxNi42NjY3IDIuNDEyODYgMTUuOTIwNSAxLjY2NjY3IDE1IDEuNjY2NjdIMy4zMzMzM0MyLjQxMjg2IDEuNjY2NjcgMS42NjY2NyAyLjQxMjg2IDEuNjY2NjcgMy4zMzMzM1YzLjc3OTI3QzIuMTU2OTYgMy40OTU2NiAyLjcyNjE5IDMuMzMzMzMgMy4zMzMzMyAzLjMzMzMzSDE1QzE1LjYwNzEgMy4zMzMzMyAxNi4xNzY0IDMuNDk1NjYgMTYuNjY2NyAzLjc3OTI3WlwiLFxuICAgICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gICAgICB9XG4gICAgKVxuICB9LFxuICBcImNoZXZyb24tcmlnaHRcIjoge1xuICAgIHZpZXdCb3g6IFwiMCAwIDE2IDE2XCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICBcInBhdGhcIixcbiAgICAgIHtcbiAgICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICAgIGQ6IFwiTTUuNTI4NzYgMi44NjE4OUM1Ljc4OTExIDIuNjAxNTQgNi4yMTEyMiAyLjYwMTU0IDYuNDcxNTcgMi44NjE4OUwxMS4xMzgyIDcuNTI4NTVDMTEuMzk4NiA3Ljc4ODkgMTEuMzk4NiA4LjIxMTAxIDExLjEzODIgOC40NzEzNkw2LjQ3MTU3IDEzLjEzOEM2LjIxMTIyIDEzLjM5ODQgNS43ODkxMSAxMy4zOTg0IDUuNTI4NzYgMTMuMTM4QzUuMjY4NDEgMTIuODc3NyA1LjI2ODQxIDEyLjQ1NTYgNS41Mjg3NiAxMi4xOTUyTDkuNzI0MDIgNy45OTk5Nkw1LjUyODc2IDMuODA0N0M1LjI2ODQxIDMuNTQ0MzUgNS4yNjg0MSAzLjEyMjI0IDUuNTI4NzYgMi44NjE4OVpcIixcbiAgICAgICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICAgICAgfVxuICAgIClcbiAgfSxcbiAgXCJhcnJvdy1yaWdodFwiOiB7XG4gICAgdmlld0JveDogXCIwIDAgMTYgMTZcIixcbiAgICBwYXRoOiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgIFwicGF0aFwiLFxuICAgICAge1xuICAgICAgICBkOiBcIk04IDNMMTMgOEw4IDEzXCIsXG4gICAgICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMlwiLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICB9XG4gICAgKVxuICB9LFxuICB4OiB7XG4gICAgdmlld0JveDogXCIwIDAgMTYgMTZcIixcbiAgICBwYXRoOiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICAgIFwicGF0aFwiLFxuICAgICAge1xuICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgICAgZDogXCJNMi44NjIwMSAyLjg2MjAxQzMuMTIyMzYgMi42MDE2NiAzLjU0NDQ3IDIuNjAxNjYgMy44MDQ4MiAyLjg2MjAxTDguMDAwMDggNy4wNTcyN0wxMi4xOTUzIDIuODYyMDFDMTIuNDU1NyAyLjYwMTY2IDEyLjg3NzggMi42MDE2NiAxMy4xMzgyIDIuODYyMDFDMTMuMzk4NSAzLjEyMjM2IDEzLjM5ODUgMy41NDQ0NyAxMy4xMzgyIDMuODA0ODJMOC45NDI4OSA4LjAwMDA4TDEzLjEzODIgMTIuMTk1M0MxMy4zOTg1IDEyLjQ1NTcgMTMuMzk4NSAxMi44Nzc4IDEzLjEzODIgMTMuMTM4MkMxMi44Nzc4IDEzLjM5ODUgMTIuNDU1NyAxMy4zOTg1IDEyLjE5NTMgMTMuMTM4Mkw4LjAwMDA4IDguOTQyODlMMy44MDQ4MiAxMy4xMzgyQzMuNTQ0NDcgMTMuMzk4NSAzLjEyMjM2IDEzLjM5ODUgMi44NjIwMSAxMy4xMzgyQzIuNjAxNjYgMTIuODc3OCAyLjYwMTY2IDEyLjQ1NTcgMi44NjIwMSAxMi4xOTUzTDcuMDU3MjcgOC4wMDAwOEwyLjg2MjAxIDMuODA0ODJDMi42MDE2NiAzLjU0NDQ3IDIuNjAxNjYgMy4xMjIzNiAyLjg2MjAxIDIuODYyMDFaXCIsXG4gICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgIH1cbiAgICApXG4gIH0sXG4gIHRpa3Rvazoge1xuICAgIHZpZXdCb3g6IFwiMCAwIDIwIDIwXCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICBcInBhdGhcIixcbiAgICAgIHtcbiAgICAgICAgZDogXCJNMTcuMDE1NiA3LjU0OTQ4QzE1LjQ3OTIgNy41NDE2NyAxNC4wMTU2IDYuOTQyNzEgMTIuODk1OCA1Ljg5MzIzVjEzLjA1NzNDMTIuODk1OCAxNi4xMDQyIDEwLjQwMSAxOC41OTkgNy4zNTQxNyAxOC41OTlDNi4yNDIxOSAxOC41OTkgNS4yMTYxNSAxOC4yNzYgNC4zNTQxNyAxNy43MjkyQzIuOTE5MjcgMTYuODMzMyAxLjg3NzYgMTUuMzI4MSAxLjYwOTM4IDEzLjU1MjFDMS41NzgxMyAxMy4zMzA3IDEuNTYyNSAxMy4xMDQyIDEuNTYyNSAxMi44NzI0QzEuNTYyNSA5LjgyNTUyIDQuMDU3MjkgNy4zMzA3MyA3LjEwNDE3IDcuMzMwNzNDNy4zNTE1NiA3LjMzMDczIDcuNTkzNzUgNy4zNTE1NiA3LjgzMDczIDcuMzg4MDJWMTAuMjcwOEM3LjU5NjM1IDEwLjIxNjEgNy4zNTQxNyAxMC4xODQ5IDcuMTA0MTcgMTAuMTg0OUM1LjYzNTQyIDEwLjE4NDkgNC40NDI3MSAxMS4zNzc2IDQuNDQyNzEgMTIuODQ2NEM0LjQ0MjcxIDEzLjgzMzMgNC45NzM5NiAxNC42ODc1IDUuNzY1NjMgMTUuMTM4QzYuMTUxMDQgMTUuMzU2OCA2LjU5Mzc1IDE1LjQ4MTggNy4wNjUxIDE1LjQ4MThDOC40NzkxNyAxNS40ODE4IDkuNjQzMjMgMTQuMzc3NiA5LjczNDM4IDEzLjAwMjZDOS43NDIxOSAxMi45MjcxIDkuNzQ0NzkgNS4zNzI0IDkuNzQ0NzkgNS4zNzI0SDEyLjU0NjlDMTIuNjM1NCA2LjIxNjE1IDEyLjk0MDEgNi45OTQ3OSAxMy40MDM2IDcuNjU4ODVDMTQuMDQ2OSA4LjU3NTUyIDE0Ljk4MTggOS4yNTUyMSAxNi4wNjc3IDkuNTQ5NDhWNy41NDk0OEgxNy4wMTU2WlwiLFxuICAgICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gICAgICB9XG4gICAgKVxuICB9LFxuICBjbG9zZToge1xuICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICBcInBhdGhcIixcbiAgICAgIHtcbiAgICAgICAgZDogXCJNMTggNkw2IDE4TTYgNkwxOCAxOFwiLFxuICAgICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBcIjJcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgICAgfVxuICAgIClcbiAgfSxcbiAgc29sYW5hOiB7XG4gICAgdmlld0JveDogXCIwIDAgOSA5XCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICBcInBhdGhcIixcbiAgICAgIHtcbiAgICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgICAgIGQ6IFwiTTEuNTQ2MDcgNi4xNzY2N0MxLjU3NTA5IDYuMTQ0NzUgMS42MTA0NyA2LjExOTIzIDEuNjQ5OTIgNi4xMDE3N0MxLjY4OTM3IDYuMDg0MjkgMS43MzIwNCA2LjA3NTI2IDEuNzc1MTkgNi4wNzUyM0w4Ljg0NDgyIDYuMDgxMDFDOC44NzQ5MyA2LjA4MTA3IDguOTA0MzcgNi4wODk4OCA4LjkyOTU4IDYuMTA2MzZDOC45NTQ3OCA2LjEyMjgzIDguOTc0NjUgNi4xNDYyNyA4Ljk4Njc4IDYuMTczODJDOC45OTg5MSA2LjIwMTM3IDkuMDAyNzggNi4yMzE4NSA4Ljk5NzkyIDYuMjYxNTZDOC45OTMwNiA2LjI5MTI3IDguOTc5NjggNi4zMTg5NCA4Ljk1OTM5IDYuMzQxMTlMNy40NTM4OSA3Ljk5ODg2QzcuNDI0ODQgOC4wMzA4IDcuMzg5NDQgOC4wNTYzNCA3LjM0OTk1IDguMDczOEM3LjMxMDQ2IDguMDkxMjggNy4yNjc3NSA4LjEwMDMgNy4yMjQ1NyA4LjEwMDNMMC4xNTUxMzMgOC4wOTQ1MkMwLjEyNTAyNiA4LjA5NDQ2IDAuMDk1NTg0NyA4LjA4NTY1IDAuMDcwMzg2MSA4LjA2OTE3QzAuMDQ1MTg2NCA4LjA1MjcgMC4wMjUzMTM3IDguMDI5MjcgMC4wMTMxODE1IDguMDAxNzFDMC4wMDEwNDg0MyA3Ljk3NDE2IC0wLjAwMjgyMTM5IDcuOTQzNjggMC4wMDIwNDA3MiA3LjkxMzk3QzAuMDA2OTAyODMgNy44ODQyNiAwLjAyMDI4ODYgNy44NTY1OSAwLjA0MDU3MTIgNy44MzQzNEwxLjU0NjA3IDYuMTc2NjdaTTguOTU5MzkgNC43OTY3M0M4Ljk3OTY4IDQuODE4OTggOC45OTMwNiA0Ljg0NjY0IDguOTk3OTIgNC44NzYzNUM5LjAwMjc4IDQuOTA2MDYgOC45OTg5MSA0LjkzNjU1IDguOTg2NzggNC45NjQxQzguOTc0NjUgNC45OTE2NiA4Ljk1NDc4IDUuMDE1MDkgOC45Mjk1OCA1LjAzMTU2QzguOTA0MzcgNS4wNDgwNCA4Ljg3NDkzIDUuMDU2ODQgOC44NDQ4MiA1LjA1NjlMMS43NzUzOCA1LjA2MjY5QzEuNzMyMjEgNS4wNjI2OSAxLjY4OTUgNS4wNTM2NiAxLjY1MDAxIDUuMDM2MTlDMS42MTA1MiA1LjAxODczIDEuNTc1MTIgNC45OTMxOSAxLjU0NjA3IDQuOTYxMjRMMC4wNDA1NzEyIDMuMzAyNjFDMC4wMjAyODg2IDMuMjgwMzYgMC4wMDY5MDI4MyAzLjI1MjcgMC4wMDIwNDA3MiAzLjIyMjk4Qy0wLjAwMjgyMTM5IDMuMTkzMjcgMC4wMDEwNDg0MyAzLjE2Mjc5IDAuMDEzMTgxNSAzLjEzNTI0QzAuMDI1MzEzNyAzLjEwNzY4IDAuMDQ1MTg2NCAzLjA4NDI1IDAuMDcwMzg2MSAzLjA2Nzc4QzAuMDk1NTg0NyAzLjA1MTMgMC4xMjUwMjYgMy4wNDI0OSAwLjE1NTEzMyAzLjA0MjQzTDcuMjI0NzYgMy4wMzY2NUM3LjI2NzkyIDMuMDM2NjggNy4zMTA1OSAzLjA0NTcxIDcuMzUwMDQgMy4wNjMxOUM3LjM4OTQ5IDMuMDgwNjUgNy40MjQ4NyAzLjEwNjE3IDcuNDUzODkgMy4xMzgxTDguOTU5MzkgNC43OTY3M1pNMS41NDYwNyAwLjEwMTQ0N0MxLjU3NTA5IDAuMDY5NTE5NSAxLjYxMDQ3IDAuMDQ0MDA0NyAxLjY0OTkyIDAuMDI2NTM1OEMxLjY4OTM3IDAuMDA5MDY2ODggMS43MzIwNCAyLjg3NDQ4ZS0wNSAxLjc3NTE5IDBMOC44NDQ4MiAwLjAwNTc4NTkzQzguODc0OTMgMC4wMDU4NDcxNCA4LjkwNDM3IDAuMDE0NjQ5NyA4LjkyOTU4IDAuMDMxMTI0M0M4Ljk1NDc4IDAuMDQ3NTk4OCA4Ljk3NDY1IDAuMDcxMDM2NSA4Ljk4Njc4IDAuMDk4NTkwM0M4Ljk5ODkxIDAuMTI2MTQ0IDkuMDAyNzggMC4xNTY2MjggOC45OTc5MiAwLjE4NjM0QzguOTkzMDYgMC4yMTYwNSA4Ljk3OTY4IDAuMjQzNzExIDguOTU5MzkgMC4yNjU5Nkw3LjQ1Mzg5IDEuOTIzNjNDNy40MjQ4NCAxLjk1NTU4IDcuMzg5NDQgMS45ODExMSA3LjM0OTk1IDEuOTk4NThDNy4zMTA0NiAyLjAxNjA1IDcuMjY3NzUgMi4wMjUwOCA3LjIyNDU3IDIuMDI1MDhMMC4xNTUxMzMgMi4wMTkyOUMwLjEyNTAyNiAyLjAxOTIzIDAuMDk1NTg0NyAyLjAxMDQzIDAuMDcwMzg2MSAxLjk5Mzk1QzAuMDQ1MTg2NCAxLjk3NzQ4IDAuMDI1MzEzNyAxLjk1NDA0IDAuMDEzMTgxNSAxLjkyNjQ4QzAuMDAxMDQ4NDMgMS44OTg5MyAtMC4wMDI4MjEzOSAxLjg2ODQ1IDAuMDAyMDQwNzIgMS44Mzg3NEMwLjAwNjkwMjgzIDEuODA5MDMgMC4wMjAyODg2IDEuNzgxMzYgMC4wNDA1NzEyIDEuNzU5MTJMMS41NDYwNyAwLjEwMTQ0N1pcIixcbiAgICAgICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICAgICAgfVxuICAgIClcbiAgfSxcbiAgZXRoZXJldW06IHtcbiAgICB2aWV3Qm94OiBcIjAgMCA3IDExXCIsXG4gICAgcGF0aDogLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwicGF0aFwiLCB7IGQ6IFwiTTYuNDQ1NTggNS4zNDc0TDMuMjIyNzkgNy4yNTIzOEwwIDUuMzQ3MzlMMy4yMjI3OSAwTDYuNDQ1NTggNS4zNDc0WlwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIoXCJwYXRoXCIsIHsgZDogXCJNNi40NDc1NSA1Ljk1ODU3TDMuMjIyODIgMTAuNUwwIDUuOTU4NTJMMy4yMjI4MiA3Ljg2MjZMNi40NDc1NSA1Ljk1ODU3WlwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiIH0pXG4gICAgXSB9KVxuICB9LFxuICBiaXRjb2luOiB7XG4gICAgdmlld0JveDogXCIwIDAgOCAxMVwiLFxuICAgIHBhdGg6IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgXCJwYXRoXCIsXG4gICAgICB7XG4gICAgICAgIGQ6IFwiTTYuMTEyMzQgNC44NjAwNEM2LjY2NzM3IDQuNTc0MDUgNy4wMTQ2NSA0LjA3MDM4IDYuOTMzNTMgMy4yMzEyOUM2LjgyNDI4IDIuMDg0NTkgNS44NDUzOCAxLjcwMDA3IDQuNjA5NjQgMS41OTA1N0w0LjYwOTQgMEgzLjY1MTk1TDMuNjUxNjggMS41NDg3NEMzLjM5OTc2IDEuNTQ4NzQgMy4xNDI5NiAxLjU1Mzc1IDIuODg3MzMgMS41NTg5M0wyLjg4NzEyIDAuMDAwMjExMTA2TDEuOTMwNTIgMC4wMDAxMjA2MzhMMS45MzAzNSAxLjU5MDNDMS43MjMwMyAxLjU5NDU4IDEuNTE5NDQgMS41OTg2NSAxLjMyMDY0IDEuNTk4NjVWMS41OTM5NUwwIDEuNTkzNEwwLjAwMDE3ODc2MiAyLjYyNzI4QzAuMDAwMTc4NzYyIDIuNjI3MjggMC43MDcyNDEgMi42MTM4MyAwLjY5NTU5MyAyLjYyNjg5QzEuMDgzMjcgMi42MjcxNiAxLjIwOTg1IDIuODU0ODYgMS4yNDYyNSAzLjA1MTRMMS4yNDY1NSA0Ljg2MzM5VjcuNDA4NjRDMS4yMjk0OCA3LjUzMTk5IDEuMTU3NjUgNy43MjkwNyAwLjg4NjU4NCA3LjcyOTQzQzAuODk4OTE4IDcuNzQwNDEgMC4xOTAwOTcgNy43MjkzMSAwLjE5MDA5NyA3LjcyOTMxTDAuMDAwMTc4NzYyIDguODg1NDNIMS4yNDU5NUMxLjQ3ODA5IDguODg1NyAxLjcwNjE3IDguODg5MzUgMS45Mjk5MyA4Ljg5MTE2TDEuOTMwNzYgMTAuNDk5N0wyLjg4NzEyIDEwLjVMMi44ODY4NSA4LjkwODI5QzMuMTQ5OTcgOC45MTM3MSAzLjQwMzkzIDguOTE2MDcgMy42NTIwMSA4LjkxNTczTDMuNjUxNzQgMTAuNUg0LjYwOTE2TDQuNjA5NyA4Ljg5NDExQzYuMjE5MDggOC44MDA2MiA3LjM0NTc4IDguMzkwNTYgNy40ODU4NiA2Ljg2MTkxQzcuNTk4NzYgNS42MzExOCA3LjAyNjA2IDUuMDgxODIgNi4xMTIzNCA0Ljg2MDA0Wk0yLjkxMDIxIDIuNjk3MDdDMy40NTAyIDIuNjk3MDcgNS4xNDg0NyAyLjUyMzE1IDUuMTQ4NzEgMy42NjQwNkM1LjE0ODQ3IDQuNzU3ODcgMy40NTA3NCA0LjYzMDA5IDIuOTEwMjEgNC42MzAwOVYyLjY5NzA3Wk0yLjkwOTc5IDcuNzM3MjhMMi45MTAyMSA1LjYwNTk0QzMuNTU5IDUuNjA1NzYgNS41OTM5NCA1LjQxNzEyIDUuNTk0MjEgNi42NzExM0M1LjU5NDQ4IDcuODczNzEgMy41NTkgNy43MzY3OSAyLjkwOTc5IDcuNzM3MjhaXCIsXG4gICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgIH1cbiAgICApXG4gIH0sXG4gIHN1aToge1xuICAgIHZpZXdCb3g6IFwiMCAwIDggOVwiLFxuICAgIHBhdGg6IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgXCJwYXRoXCIsXG4gICAgICB7XG4gICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgICBkOiBcIk01LjYzNDI0IDMuNzUzMjVDNi4wMDEzNSA0LjIxNDE5IDYuMjIwODkgNC43OTcxMiA2LjIyMDg5IDUuNDMxMjNDNi4yMjA4OSA2LjA2NTMzIDUuOTk0NjggNi42NjYwNSA1LjYxNzkzIDcuMTI5NTdMNS41ODUyOCA3LjE2OTYzTDUuNTc2NzYgNy4xMTg4MkM1LjU2OTM1IDcuMDc1OCA1LjU2MDgzIDcuMDMyMDUgNS41NTA4MSA2Ljk4ODNDNS4zNjIwNiA2LjE1OTE0IDQuNzQ3MjUgNS40NDgyOSAzLjczNTI3IDQuODcyMzlDMy4wNTE4NCA0LjQ4NDUyIDIuNjYwNjMgNC4wMTgwMiAyLjU1NzkzIDMuNDg3MzhDMi40OTE1NSAzLjE0NDM4IDIuNTQwODYgMi43OTk4OCAyLjYzNjE1IDIuNTA0N0MyLjczMTQ3IDIuMjA5OSAyLjg3MzExIDEuOTYyNTcgMi45OTM2MyAxLjgxMzg3TDMuMzg3NDQgMS4zMzI1NEMzLjQ1NjQyIDEuMjQ4IDMuNTg1ODQgMS4yNDggMy42NTQ3OSAxLjMzMjU0TDUuNjM0NjIgMy43NTMyNUg1LjYzNDI0Wk02LjI1Njg0IDMuMjcyM0wzLjYxODA5IDAuMDQ2MTY3MUMzLjU2NzY3IC0wLjAxNTM4OSAzLjQ3MzQ2IC0wLjAxNTM4OSAzLjQyMzA1IDAuMDQ2MTY3MUwwLjc4NDY1NCAzLjI3MjNMMC43NzYxMjggMy4yODMwN0MwLjI5MDcyNCAzLjg4NTY1IDAgNC42NTE0IDAgNS40ODVDMCA3LjQyNjI0IDEuNTc2MzYgOSAzLjUyMDU3IDlDNS40NjQ3OSA5IDcuMDQxMTMgNy40MjYyNCA3LjA0MTEzIDUuNDg1QzcuMDQxMTMgNC42NTE0IDYuNzUwNCAzLjg4NTY1IDYuMjY1MDEgMy4yODM0Mkw2LjI1NjQ3IDMuMjcyNjdMNi4yNTY4NCAzLjI3MjNaTTEuNDE2MTYgMy43NDI4OEwxLjY1MiAzLjQ1NEwxLjY1OTA1IDMuNTA3NEMxLjY2NDYxIDMuNTQ5NjcgMS42NzE2NiAzLjU5MTk0IDEuNjc5ODEgMy42MzQ1OUMxLjgzMjU5IDQuNDM1OTQgMi4zNzgwNyA1LjEwMzc5IDMuMjg5OTIgNS42MjEwOEM0LjA4MjczIDYuMDcyMzcgNC41NDQzOSA2LjU5MTE2IDQuNjc3MTQgNy4xNTk5OUM0LjczMjc3IDcuMzk3MzIgNC43NDI0MSA3LjYzMDkyIDQuNzE4MzEgNy44MzUyNkw0LjcxNjgzIDcuODQ3ODZMNC43MDUzMyA3Ljg1MzQyQzQuMzQ3NSA4LjAyODA3IDMuOTQ1MTUgOC4xMjYzNCAzLjUyMDE5IDguMTI2MzRDMi4wMjkxMyA4LjEyNjM0IDAuODIwMjU0IDYuOTE5NyAwLjgyMDI1NCA1LjQzMDg1QzAuODIwMjU0IDQuNzkxNTYgMS4wNDMxMiA0LjIwNDU0IDEuNDE1NDIgMy43NDIxM0wxLjQxNjE2IDMuNzQyODhaXCIsXG4gICAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCJcbiAgICAgIH1cbiAgICApXG4gIH1cbn07XG5mdW5jdGlvbiBJY29uKHsgdHlwZSwgc2l6ZSA9IDIwLCBjb2xvciwgc3R5bGUgfSkge1xuICBjb25zdCBpY29uID0gSUNPTlNbdHlwZV07XG4gIGNvbnN0IGljb25TdHlsZSA9IHtcbiAgICB3aWR0aDogYCR7c2l6ZX1weGAsXG4gICAgaGVpZ2h0OiBgJHtzaXplfXB4YCxcbiAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgIGNvbG9yOiBjb2xvciB8fCBcImN1cnJlbnRDb2xvclwiLFxuICAgIC4uLnN0eWxlXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihcInN2Z1wiLCB7IHN0eWxlOiBpY29uU3R5bGUsIHZpZXdCb3g6IGljb24udmlld0JveCwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGNoaWxkcmVuOiBpY29uLnBhdGggfSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1RleHQud2ViLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIFRleHQoeyBjaGlsZHJlbiwgdmFyaWFudCA9IFwiY2FwdGlvblwiLCBjb2xvciwgc3R5bGUgfSkge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHRleHRTdHlsZSA9IHtcbiAgICAuLi50aGVtZS50eXBvZ3JhcGh5W3ZhcmlhbnRdLFxuICAgIGNvbG9yOiBjb2xvciA/PyB0aGVtZS50ZXh0LFxuICAgIG1hcmdpbjogMCxcbiAgICAuLi5zdHlsZVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMoXCJzcGFuXCIsIHsgc3R5bGU6IHRleHRTdHlsZSwgY2hpbGRyZW4gfSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0J1dHRvbi53ZWIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NCwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHVzZUJhc2VCdXR0b25TdHlsZSA9ICh7IGZ1bGxXaWR0aCwgZGlzYWJsZWQsIGZvbnRTaXplLCBmb250V2VpZ2h0IH0pID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogXCI1NnB4XCIsXG4gICAgcGFkZGluZzogXCIxMnB4IDE2cHhcIixcbiAgICB3aWR0aDogZnVsbFdpZHRoID8gXCIxMDAlXCIgOiBcImF1dG9cIixcbiAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgIGJvcmRlclJhZGl1czogdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbkJvbGQuZm9udEZhbWlseSxcbiAgICBmb250U2l6ZTogZm9udFNpemUgPz8gdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uQm9sZC5mb250U2l6ZSxcbiAgICBmb250U3R5bGU6IHRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbkJvbGQuZm9udFN0eWxlLFxuICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgPz8gdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uQm9sZC5mb250V2VpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuY2FwdGlvbkJvbGQubGluZUhlaWdodCxcbiAgICBsZXR0ZXJTcGFjaW5nOiB0aGVtZS50eXBvZ3JhcGh5LmNhcHRpb25Cb2xkLmxldHRlclNwYWNpbmcsXG4gICAgY3Vyc29yOiBkaXNhYmxlZCA/IFwibm90LWFsbG93ZWRcIiA6IFwicG9pbnRlclwiLFxuICAgIHRyYW5zaXRpb246IFwiYmFja2dyb3VuZC1jb2xvciAwLjJzXCIsXG4gICAgZ2FwOiBcIjhweFwiXG4gIH07XG59O1xuZnVuY3Rpb24gQnV0dG9uKHtcbiAgY2hpbGRyZW4sXG4gIG9uQ2xpY2ssXG4gIGRpc2FibGVkID0gZmFsc2UsXG4gIHZhcmlhbnQgPSBcInByaW1hcnlcIixcbiAgZnVsbFdpZHRoID0gdHJ1ZSxcbiAgaXNMb2FkaW5nID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBbaXNIb3ZlcmluZywgc2V0SXNIb3ZlcmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSAhZGlzYWJsZWQgJiYgIWlzTG9hZGluZztcbiAgY29uc3QgYmFzZVN0eWxlID0gdXNlQmFzZUJ1dHRvblN0eWxlKHtcbiAgICBmdWxsV2lkdGgsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IGlzTG9hZGluZ1xuICB9KTtcbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFpc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdmFyaWFudCA9PT0gXCJwcmltYXJ5XCIgPyB0aGVtZS5hdXggOiBcInRyYW5zcGFyZW50XCI7XG4gICAgfVxuICAgIGlmIChpc0hvdmVyaW5nKSB7XG4gICAgICByZXR1cm4gdmFyaWFudCA9PT0gXCJwcmltYXJ5XCIgPyBoZXhUb1JnYmEodGhlbWUuc2Vjb25kYXJ5LCAwLjE1KSA6IGhleFRvUmdiYSh0aGVtZS5zZWNvbmRhcnksIDAuMSk7XG4gICAgfVxuICAgIHJldHVybiB2YXJpYW50ID09PSBcInByaW1hcnlcIiA/IHRoZW1lLmF1eCA6IFwidHJhbnNwYXJlbnRcIjtcbiAgfSwgW2lzSW50ZXJhY3RpdmUsIGlzSG92ZXJpbmcsIHZhcmlhbnQsIHRoZW1lLmF1eCwgdGhlbWUuc2Vjb25kYXJ5XSk7XG4gIGNvbnN0IGJ1dHRvblN0eWxlID0ge1xuICAgIC4uLmJhc2VTdHlsZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgY29sb3I6IHRoZW1lLnRleHQsXG4gICAgYm9yZGVyOiB2YXJpYW50ID09PSBcInNlY29uZGFyeVwiID8gYDFweCBzb2xpZCAke3RoZW1lLnNlY29uZGFyeX1gIDogXCJub25lXCJcbiAgfTtcbiAgY29uc3QgaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHtcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgc2V0SXNIb3ZlcmluZyh0cnVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgc2V0SXNIb3ZlcmluZyhmYWxzZSk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChcbiAgICBcImJ1dHRvblwiLFxuICAgIHtcbiAgICAgIHN0eWxlOiBidXR0b25TdHlsZSxcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWQgfHwgaXNMb2FkaW5nLFxuICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVNb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVNb3VzZUxlYXZlLFxuICAgICAgY2hpbGRyZW46IGlzTG9hZGluZyA/IFwiQ29ubmVjdGluZy4uLlwiIDogY2hpbGRyZW5cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBMb2dpbldpdGhQaGFudG9tQnV0dG9uKHtcbiAgY2hpbGRyZW4gPSBcIkNvbnRpbnVlIHdpdGggUGhhbnRvbVwiLFxuICBvbkNsaWNrLFxuICBkaXNhYmxlZCA9IGZhbHNlLFxuICBmdWxsV2lkdGggPSB0cnVlLFxuICBpc0xvYWRpbmcgPSBmYWxzZSxcbiAgdGVzdElkID0gXCJsb2dpbi13aXRoLXBoYW50b20tYnV0dG9uXCJcbn0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBbaXNIb3ZlcmluZywgc2V0SXNIb3ZlcmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSAhZGlzYWJsZWQgJiYgIWlzTG9hZGluZztcbiAgY29uc3QgYmFzZVN0eWxlID0gdXNlQmFzZUJ1dHRvblN0eWxlKHtcbiAgICBmdWxsV2lkdGgsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IGlzTG9hZGluZ1xuICB9KTtcbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFpc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGhlbWUuYnJhbmQ7XG4gICAgfVxuICAgIGlmIChpc0hvdmVyaW5nKSB7XG4gICAgICByZXR1cm4gaGV4VG9SZ2JhKHRoZW1lLmJyYW5kLCAwLjg1KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoZW1lLmJyYW5kO1xuICB9LCBbaXNJbnRlcmFjdGl2ZSwgaXNIb3ZlcmluZywgdGhlbWUuYnJhbmRdKTtcbiAgY29uc3QgYnV0dG9uU3R5bGUgPSB7XG4gICAgLi4uYmFzZVN0eWxlLFxuICAgIGJhY2tncm91bmRDb2xvcixcbiAgICBjb2xvcjogXCIjRkZGRkZGXCJcbiAgfTtcbiAgY29uc3QgaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHtcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgc2V0SXNIb3ZlcmluZyh0cnVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgc2V0SXNIb3ZlcmluZyhmYWxzZSk7XG4gIH07XG4gIGNvbnN0IGJ1dHRvbkNvbnRlbnRTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICBnYXA6IFwiOHB4XCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIGNvbnN0IGJ1dHRvbkxlZnRTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGdhcDogXCI4cHhcIlxuICB9O1xuICBjb25zdCBidXR0b25SaWdodFN0eWxlID0ge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgZ2FwOiBcIjhweFwiXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChcbiAgICBcImJ1dHRvblwiLFxuICAgIHtcbiAgICAgIHN0eWxlOiBidXR0b25TdHlsZSxcbiAgICAgIG9uQ2xpY2ssXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWQgfHwgaXNMb2FkaW5nLFxuICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVNb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVNb3VzZUxlYXZlLFxuICAgICAgXCJkYXRhLXRlc3RpZFwiOiB0ZXN0SWQsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMyKFwic3BhblwiLCB7IHN0eWxlOiBidXR0b25Db250ZW50U3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcInNwYW5cIiwgeyBzdHlsZTogYnV0dG9uTGVmdFN0eWxlLCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KEljb24sIHsgdHlwZTogXCJwaGFudG9tXCIsIHNpemU6IDIwIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFRleHQsIHsgdmFyaWFudDogXCJjYXB0aW9uQm9sZFwiLCBjb2xvcjogXCIjRkZGRkZGXCIsIGNoaWxkcmVuOiBpc0xvYWRpbmcgPyBcIkNvbm5lY3RpbmcuLi5cIiA6IGNoaWxkcmVuIH0pXG4gICAgICAgIF0gfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFwic3BhblwiLCB7IHN0eWxlOiBidXR0b25SaWdodFN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDQoSWNvbiwgeyB0eXBlOiBcImNoZXZyb24tcmlnaHRcIiwgc2l6ZTogMTYsIGNvbG9yOiBcIiNGRkZGRkZcIiB9KSB9KVxuICAgICAgXSB9KVxuICAgIH1cbiAgKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQm91bmRlZEljb24ud2ViLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIEJvdW5kZWRJY29uKHsgdHlwZSwgc2l6ZSA9IDIwLCBjb2xvciwgc3R5bGUsIGJhY2tncm91bmQgfSkge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGljb25CYWNrZ3JvdW5kU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICB3aWR0aDogXCIzMnB4XCIsXG4gICAgaGVpZ2h0OiBcIjMycHhcIixcbiAgICBib3JkZXJSYWRpdXM6IFwiOHB4XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kID8/IHRoZW1lLmF1eFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDUoXCJkaXZcIiwgeyBzdHlsZTogeyAuLi5pY29uQmFja2dyb3VuZFN0eWxlLCAuLi5zdHlsZSB9LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDUoSWNvbiwgeyB0eXBlLCBzaXplLCBjb2xvciB9KSB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvU2tlbGV0b24ud2ViLnRzeFxuaW1wb3J0IHsgRnJhZ21lbnQgYXMgRnJhZ21lbnQyLCBqc3ggYXMganN4NiwganN4cyBhcyBqc3hzMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gU2tlbGV0b24oeyB3aWR0aCA9IFwiMTAwJVwiLCBoZWlnaHQgPSBcIjIwcHhcIiwgYm9yZGVyUmFkaXVzLCBzdHlsZSB9KSB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3Qgc2tlbGV0b25TdHlsZSA9IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMgPz8gdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUuYXV4LFxuICAgIGFuaW1hdGlvbjogXCJwdWxzZSAxLjVzIGVhc2UtaW4tb3V0IGluZmluaXRlXCIsXG4gICAgLi4uc3R5bGVcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMyhGcmFnbWVudDIsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4NihcInN0eWxlXCIsIHsgY2hpbGRyZW46IGBcbiAgICAgICAgICBAa2V5ZnJhbWVzIHB1bHNlIHtcbiAgICAgICAgICAgIDAlLCAxMDAlIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDUwJSB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGAgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeDYoXCJkaXZcIiwgeyBzdHlsZTogc2tlbGV0b25TdHlsZSB9KVxuICBdIH0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9Nb2RhbC53ZWIudHN4XG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gTW9kYWwoe1xuICBhcHBJY29uOiBfYXBwSWNvbixcbiAgYXBwTmFtZTogX2FwcE5hbWUsXG4gIGlzVmlzaWJsZSxcbiAgb25DbG9zZSxcbiAgaXNNb2JpbGUgPSBmYWxzZSxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbY29udGVudEhlaWdodCwgc2V0Q29udGVudEhlaWdodF0gPSB1c2VTdGF0ZTIoXCJhdXRvXCIpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNWaXNpYmxlIHx8ICFjb250ZW50UmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbWVhc3VyZUhlaWdodCA9ICgpID0+IHtcbiAgICAgIGlmIChjb250ZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGVudFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgc2V0Q29udGVudEhlaWdodChoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWVhc3VyZUhlaWdodCgpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIG1lYXN1cmVIZWlnaHQoKTtcbiAgICB9KTtcbiAgICBpZiAoY29udGVudFJlZi5jdXJyZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGNvbnRlbnRSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW2lzVmlzaWJsZSwgY2hpbGRyZW5dKTtcbiAgaWYgKCFpc1Zpc2libGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG92ZXJsYXlTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLm92ZXJsYXksXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICB6SW5kZXg6IDk5OTksXG4gICAgcGFkZGluZzogaXNNb2JpbGUgPyBcIjE2cHhcIiA6IFwiMFwiXG4gIH07XG4gIGNvbnN0IG1vZGFsU3R5bGUgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5iYWNrZ3JvdW5kLFxuICAgIGJvcmRlclJhZGl1czogdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgIG1heFdpZHRoOiBpc01vYmlsZSA/IFwiMTAwJVwiIDogXCIzNTBweFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBib3hTaGFkb3c6IFwiMCA4cHggMzJweCByZ2JhKDAsIDAsIDAsIDAuMylcIixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHRyYW5zaXRpb246IFwibWF4LXdpZHRoIDAuMXMgZWFzZS1pbi1vdXRcIlxuICB9O1xuICBjb25zdCBtb2RhbENvbnRlbnRXcmFwcGVyU3R5bGUgPSB7XG4gICAgaGVpZ2h0OiB0eXBlb2YgY29udGVudEhlaWdodCA9PT0gXCJudW1iZXJcIiA/IGAke2NvbnRlbnRIZWlnaHR9cHhgIDogXCJhdXRvXCIsXG4gICAgdHJhbnNpdGlvbjogXCJoZWlnaHQgMC4xNXMgZWFzZS1pbi1vdXRcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICB9O1xuICBjb25zdCBtb2RhbENvbnRlbnRTdHlsZSA9IHtcbiAgICB0cmFuc2l0aW9uOiBcIm9wYWNpdHkgMC4xNXMgZWFzZS1pbi1vdXRcIlxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoXCJkaXZcIiwgeyBzdHlsZTogb3ZlcmxheVN0eWxlLCBvbkNsaWNrOiBvbkNsb3NlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDcoXCJkaXZcIiwgeyBzdHlsZTogbW9kYWxTdHlsZSwgb25DbGljazogKGUpID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NyhcImRpdlwiLCB7IHN0eWxlOiBtb2RhbENvbnRlbnRXcmFwcGVyU3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NyhcImRpdlwiLCB7IHJlZjogY29udGVudFJlZiwgc3R5bGU6IG1vZGFsQ29udGVudFN0eWxlLCBjaGlsZHJlbiB9KSB9KSB9KSB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTW9kYWxIZWFkZXIud2ViLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDgsIGpzeHMgYXMganN4czQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIE1vZGFsSGVhZGVyKHsgZ29CYWNrID0gZmFsc2UsIG9uR29CYWNrLCB0aXRsZSwgb25DbG9zZSwgaGlkZUNsb3NlQnV0dG9uID0gZmFsc2UgfSkge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGhlYWRlclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBwYWRkaW5nOiBcIjI4cHggMzJweCAwIDMycHhcIixcbiAgICBoZWlnaHQ6IFwiMzJweFwiXG4gIH07XG4gIGNvbnN0IHRpdGxlU3R5bGUgPSB7XG4gICAgZm9udEZlYXR1cmVTZXR0aW5nczogJ1wibGlnYVwiIG9mZiwgXCJjbGlnXCIgb2ZmJ1xuICB9O1xuICBjb25zdCBiYWNrQnV0dG9uU3R5bGUgPSB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBsZWZ0OiBcIjMycHhcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgcGFkZGluZzogXCI4cHhcIixcbiAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgIHdpZHRoOiBcIjMycHhcIixcbiAgICBoZWlnaHQ6IFwiMzJweFwiXG4gIH07XG4gIGNvbnN0IGNsb3NlQnV0dG9uU3R5bGUgPSB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICByaWdodDogXCIzMnB4XCIsXG4gICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICBjb2xvcjogdGhlbWUuc2Vjb25kYXJ5LFxuICAgIGZvbnRTaXplOiBcIjI0cHhcIixcbiAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgIHBhZGRpbmc6IFwiNHB4IDhweFwiLFxuICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgdHJhbnNpdGlvbjogXCJjb2xvciAwLjJzXCIsXG4gICAgd2lkdGg6IFwiYXV0b1wiXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4czQoXCJkaXZcIiwgeyBzdHlsZTogaGVhZGVyU3R5bGUsIGNoaWxkcmVuOiBbXG4gICAgZ29CYWNrICYmIG9uR29CYWNrICYmIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFwiYnV0dG9uXCIsIHsgc3R5bGU6IGJhY2tCdXR0b25TdHlsZSwgb25DbGljazogb25Hb0JhY2ssIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OChJY29uLCB7IHR5cGU6IFwiY2hldnJvbi1yaWdodFwiLCBzaXplOiAxNiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSwgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInJvdGF0ZSgxODBkZWcpXCIgfSB9KSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4OChcImRpdlwiLCB7IHN0eWxlOiB0aXRsZVN0eWxlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoVGV4dCwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgY29sb3I6IHRoZW1lLnNlY29uZGFyeSwgY2hpbGRyZW46IHRpdGxlIH0pIH0pLFxuICAgIG9uQ2xvc2UgJiYgIWhpZGVDbG9zZUJ1dHRvbiAmJiAvKiBAX19QVVJFX18gKi8ganN4OChcImJ1dHRvblwiLCB7IHN0eWxlOiBjbG9zZUJ1dHRvblN0eWxlLCBvbkNsaWNrOiBvbkNsb3NlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDgoSWNvbiwgeyB0eXBlOiBcInhcIiwgc2l6ZTogMTYsIGNvbG9yOiB0aGVtZS5zZWNvbmRhcnkgfSkgfSlcbiAgXSB9KTtcbn1cbmV4cG9ydCB7XG4gIEJvdW5kZWRJY29uLFxuICBCdXR0b24sXG4gIEljb24sXG4gIExvZ2luV2l0aFBoYW50b21CdXR0b24sXG4gIE1vZGFsLFxuICBNb2RhbEhlYWRlcixcbiAgU2tlbGV0b24sXG4gIFRleHQsXG4gIFRoZW1lUHJvdmlkZXIsXG4gIGRhcmtUaGVtZSxcbiAgaGV4VG9SZ2JhLFxuICBsaWdodFRoZW1lLFxuICBtZXJnZVRoZW1lLFxuICBtZXJnZVRoZW1lTmF0aXZlLFxuICB1c2VUaGVtZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@phantom/wallet-sdk-ui/dist/index.mjs\n");

/***/ })

};
;